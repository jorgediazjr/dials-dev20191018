/* *****************************************************
   THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT.
   *****************************************************

   Generated by:
     gltbx.generate_functions_bpl
 */

#include <gltbx/special_wrapper_support.h>
#include <gltbx/pointer_args_bpl.h>
#include <gltbx/error.h>

namespace gltbx { namespace gl { namespace {

  void
  gl_Accum(
    boost::python::object const& py_op,
    boost::python::object const& py_value)
  {
    boost::python::extract<GLenum> op_proxy(py_op);
    GLenum op = op_proxy();
    boost::python::extract<GLfloat> value_proxy(py_value);
    GLfloat value = value_proxy();
    glAccum(op, value);
  }

  void
  gl_AlphaFunc(
    boost::python::object const& py_func,
    boost::python::object const& py_ref)
  {
    boost::python::extract<GLenum> func_proxy(py_func);
    GLenum func = func_proxy();
    boost::python::extract<GLclampf> ref_proxy(py_ref);
    GLclampf ref = ref_proxy();
    glAlphaFunc(func, ref);
  }

  GLboolean
  gl_AreTexturesResident(
    boost::python::object const& py_n,
    boost::python::object const& py_textures,
    boost::python::object const& py_residences)
  {
    boost::python::extract<GLsizei> n_proxy(py_n);
    GLsizei n = n_proxy();
    boost_python::converter<GLuint> textures_proxy(
      "textures", py_textures, 0, true);
    const GLuint* textures = textures_proxy.get();
    boost_python::converter<GLboolean> residences_proxy(
      "residences", py_residences, 0, false);
    GLboolean* residences = residences_proxy.get();
    GLboolean result = glAreTexturesResident(n, textures, residences);
    residences_proxy.write_back();
    return result;
  }

  void
  gl_ArrayElement(
    boost::python::object const& py_i)
  {
    boost::python::extract<GLint> i_proxy(py_i);
    GLint i = i_proxy();
    glArrayElement(i);
  }

  void
  gl_Begin(
    boost::python::object const& py_mode)
  {
    boost::python::extract<GLenum> mode_proxy(py_mode);
    GLenum mode = mode_proxy();
    glBegin(mode);
  }

  void
  gl_End()
  {
    glEnd();
  }

  void
  gl_BindTexture(
    boost::python::object const& py_target,
    boost::python::object const& py_texture)
  {
    boost::python::extract<GLenum> target_proxy(py_target);
    GLenum target = target_proxy();
    boost::python::extract<GLuint> texture_proxy(py_texture);
    GLuint texture = texture_proxy();
    glBindTexture(target, texture);
  }

  void
  gl_Bitmap(
    boost::python::object const& py_width,
    boost::python::object const& py_height,
    boost::python::object const& py_xorig,
    boost::python::object const& py_yorig,
    boost::python::object const& py_xmove,
    boost::python::object const& py_ymove,
    boost::python::object const& py_bitmap)
  {
    boost::python::extract<GLsizei> width_proxy(py_width);
    GLsizei width = width_proxy();
    boost::python::extract<GLsizei> height_proxy(py_height);
    GLsizei height = height_proxy();
    boost::python::extract<GLfloat> xorig_proxy(py_xorig);
    GLfloat xorig = xorig_proxy();
    boost::python::extract<GLfloat> yorig_proxy(py_yorig);
    GLfloat yorig = yorig_proxy();
    boost::python::extract<GLfloat> xmove_proxy(py_xmove);
    GLfloat xmove = xmove_proxy();
    boost::python::extract<GLfloat> ymove_proxy(py_ymove);
    GLfloat ymove = ymove_proxy();
    boost_python::converter_str<GLubyte> bitmap_proxy(
      "bitmap", py_bitmap, 0, true);
    const GLubyte* bitmap = bitmap_proxy.get();
    glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
  }

#if defined(GL_XXX)
  void
  gl_BlendColorEXT(
    boost::python::object const& py_red,
    boost::python::object const& py_green,
    boost::python::object const& py_blue,
    boost::python::object const& py_alpha)
  {
    boost::python::extract<GLclampf> red_proxy(py_red);
    GLclampf red = red_proxy();
    boost::python::extract<GLclampf> green_proxy(py_green);
    GLclampf green = green_proxy();
    boost::python::extract<GLclampf> blue_proxy(py_blue);
    GLclampf blue = blue_proxy();
    boost::python::extract<GLclampf> alpha_proxy(py_alpha);
    GLclampf alpha = alpha_proxy();
    glBlendColorEXT(red, green, blue, alpha);
  }
#endif

  void
  gl_BlendFunc(
    boost::python::object const& py_sfactor,
    boost::python::object const& py_dfactor)
  {
    boost::python::extract<GLenum> sfactor_proxy(py_sfactor);
    GLenum sfactor = sfactor_proxy();
    boost::python::extract<GLenum> dfactor_proxy(py_dfactor);
    GLenum dfactor = dfactor_proxy();
    glBlendFunc(sfactor, dfactor);
  }

  void
  gl_CallList(
    boost::python::object const& py_list)
  {
    boost::python::extract<GLuint> list_proxy(py_list);
    GLuint list = list_proxy();
    glCallList(list);
  }

  void
  gl_CallLists(
    boost::python::object const& py_n,
    boost::python::object const& py_type,
    boost::python::object const& py_lists)
  {
  
    boost::python::extract<GLsizei> n_proxy(py_n);
    GLsizei n = n_proxy();
    boost::python::extract<GLenum> type_proxy(py_type);
    GLenum type = type_proxy();
    if      (type == GL_BYTE) {
      boost_python::converter_str<GLubyte> lists_proxy(
        "lists", py_lists, 0, true);
      const GLvoid* lists = reinterpret_cast<const GLvoid*>(
        lists_proxy.get());
      glCallLists(n, type, lists);
    }
    else if (type == GL_UNSIGNED_BYTE) {
      boost_python::converter_str<GLbyte> lists_proxy(
        "lists", py_lists, 0, true);
      const GLvoid* lists = reinterpret_cast<const GLvoid*>(
        lists_proxy.get());
      glCallLists(n, type, lists);
    }
    else {
      throw std::runtime_error(
        "Conversion not implemented for given GLenum type:"
        " glCallLists(): const GLvoid* lists");
    }
  }

  void
  gl_ClearAccum(
    boost::python::object const& py_red,
    boost::python::object const& py_green,
    boost::python::object const& py_blue,
    boost::python::object const& py_alpha)
  {
    boost::python::extract<GLfloat> red_proxy(py_red);
    GLfloat red = red_proxy();
    boost::python::extract<GLfloat> green_proxy(py_green);
    GLfloat green = green_proxy();
    boost::python::extract<GLfloat> blue_proxy(py_blue);
    GLfloat blue = blue_proxy();
    boost::python::extract<GLfloat> alpha_proxy(py_alpha);
    GLfloat alpha = alpha_proxy();
    glClearAccum(red, green, blue, alpha);
  }

  void
  gl_ClearColor(
    boost::python::object const& py_red,
    boost::python::object const& py_green,
    boost::python::object const& py_blue,
    boost::python::object const& py_alpha)
  {
    boost::python::extract<GLclampf> red_proxy(py_red);
    GLclampf red = red_proxy();
    boost::python::extract<GLclampf> green_proxy(py_green);
    GLclampf green = green_proxy();
    boost::python::extract<GLclampf> blue_proxy(py_blue);
    GLclampf blue = blue_proxy();
    boost::python::extract<GLclampf> alpha_proxy(py_alpha);
    GLclampf alpha = alpha_proxy();
    glClearColor(red, green, blue, alpha);
  }

  void
  gl_ClearDepth(
    boost::python::object const& py_depth)
  {
    boost::python::extract<GLclampd> depth_proxy(py_depth);
    GLclampd depth = depth_proxy();
    glClearDepth(depth);
  }

  void
  gl_Clear(
    boost::python::object const& py_mask)
  {
    boost::python::extract<GLbitfield> mask_proxy(py_mask);
    GLbitfield mask = mask_proxy();
    glClear(mask);
  }

  void
  gl_ClearIndex(
    boost::python::object const& py_c)
  {
    boost::python::extract<GLfloat> c_proxy(py_c);
    GLfloat c = c_proxy();
    glClearIndex(c);
  }

  void
  gl_ClearStencil(
    boost::python::object const& py_s)
  {
    boost::python::extract<GLint> s_proxy(py_s);
    GLint s = s_proxy();
    glClearStencil(s);
  }

  void
  gl_ClipPlane(
    boost::python::object const& py_plane,
    boost::python::object const& py_equation)
  {
    boost::python::extract<GLenum> plane_proxy(py_plane);
    GLenum plane = plane_proxy();
    boost_python::converter<GLdouble> equation_proxy(
      "equation", py_equation, 4, true);
    const GLdouble* equation = equation_proxy.get();
    glClipPlane(plane, equation);
  }

  void
  gl_Color3b(
    boost::python::object const& py_red,
    boost::python::object const& py_green,
    boost::python::object const& py_blue)
  {
    boost::python::extract<GLbyte> red_proxy(py_red);
    GLbyte red = red_proxy();
    boost::python::extract<GLbyte> green_proxy(py_green);
    GLbyte green = green_proxy();
    boost::python::extract<GLbyte> blue_proxy(py_blue);
    GLbyte blue = blue_proxy();
    glColor3b(red, green, blue);
  }

  void
  gl_Color3d(
    boost::python::object const& py_red,
    boost::python::object const& py_green,
    boost::python::object const& py_blue)
  {
    boost::python::extract<GLdouble> red_proxy(py_red);
    GLdouble red = red_proxy();
    boost::python::extract<GLdouble> green_proxy(py_green);
    GLdouble green = green_proxy();
    boost::python::extract<GLdouble> blue_proxy(py_blue);
    GLdouble blue = blue_proxy();
    glColor3d(red, green, blue);
  }

  void
  gl_Color3f(
    boost::python::object const& py_red,
    boost::python::object const& py_green,
    boost::python::object const& py_blue)
  {
    boost::python::extract<GLfloat> red_proxy(py_red);
    GLfloat red = red_proxy();
    boost::python::extract<GLfloat> green_proxy(py_green);
    GLfloat green = green_proxy();
    boost::python::extract<GLfloat> blue_proxy(py_blue);
    GLfloat blue = blue_proxy();
    glColor3f(red, green, blue);
  }

} // namespace <anonymous>

namespace boost_python {

  void
  wrap_functions_00()
  {
    using namespace boost::python;
    def("glAccum", gl_Accum, (
      arg("op"), arg("value")));
    def("glAlphaFunc", gl_AlphaFunc, (
      arg("func"), arg("ref")));
    def("glAreTexturesResident", gl_AreTexturesResident, (
      arg("n"), arg("textures"), arg("residences")));
    def("glArrayElement", gl_ArrayElement, (
      arg("i")));
    def("glBegin", gl_Begin, (
      arg("mode")));
    def("glEnd", gl_End);
    def("glBindTexture", gl_BindTexture, (
      arg("target"), arg("texture")));
    def("glBitmap", gl_Bitmap, (
      arg("width"), arg("height"), arg("xorig"), arg("yorig"), arg("xmove"),
      arg("ymove"), arg("bitmap")));
#if defined(GL_XXX)
    def("glBlendColorEXT", gl_BlendColorEXT, (
      arg("red"), arg("green"), arg("blue"), arg("alpha")));
#endif
    def("glBlendFunc", gl_BlendFunc, (
      arg("sfactor"), arg("dfactor")));
    def("glCallList", gl_CallList, (
      arg("list")));
    def("glCallLists", gl_CallLists, (
      arg("n"), arg("type"), arg("lists")));
    def("glClearAccum", gl_ClearAccum, (
      arg("red"), arg("green"), arg("blue"), arg("alpha")));
    def("glClearColor", gl_ClearColor, (
      arg("red"), arg("green"), arg("blue"), arg("alpha")));
    def("glClearDepth", gl_ClearDepth, (
      arg("depth")));
    def("glClear", gl_Clear, (
      arg("mask")));
    def("glClearIndex", gl_ClearIndex, (
      arg("c")));
    def("glClearStencil", gl_ClearStencil, (
      arg("s")));
    def("glClipPlane", gl_ClipPlane, (
      arg("plane"), arg("equation")));
    def("glColor3b", gl_Color3b, (
      arg("red"), arg("green"), arg("blue")));
    def("glColor3d", gl_Color3d, (
      arg("red"), arg("green"), arg("blue")));
    def("glColor3f", gl_Color3f, (
      arg("red"), arg("green"), arg("blue")));
  }

}}} // namespace gltbx::gl::boost_python
