/* *****************************************************
   THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT.
   *****************************************************

   Generated by:
     gltbx.generate_functions_bpl
 */

#include <gltbx/special_wrapper_support.h>
#include <gltbx/pointer_args_bpl.h>
#include <gltbx/error.h>

#if defined(__GNUC__) && __GNUC__ == 2 \
     && __GNUC_MINOR__ == 96 && __GNUC_PATCHLEVEL__ == 0
#define GLTBX_NO_OPAQUE_POINTERS
#else
#include <boost/python/return_value_policy.hpp>
#include <boost/python/return_opaque_pointer.hpp>
BOOST_PYTHON_OPAQUE_SPECIALIZED_TYPE_ID(GLUnurbs)
BOOST_PYTHON_OPAQUE_SPECIALIZED_TYPE_ID(GLUquadric)
BOOST_PYTHON_OPAQUE_SPECIALIZED_TYPE_ID(GLUtesselator)
#endif

namespace gltbx { namespace glu { namespace {

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_BeginCurve(
    boost::python::object const& py_nurb)
  {
    boost::python::extract<GLUnurbs*> nurb_proxy(py_nurb);
    GLUnurbs* nurb = nurb_proxy();
    gluBeginCurve(nurb);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_EndCurve(
    boost::python::object const& py_nurb)
  {
    boost::python::extract<GLUnurbs*> nurb_proxy(py_nurb);
    GLUnurbs* nurb = nurb_proxy();
    gluEndCurve(nurb);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_BeginPolygon(
    boost::python::object const& py_tess)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    gluBeginPolygon(tess);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_EndPolygon(
    boost::python::object const& py_tess)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    gluEndPolygon(tess);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_BeginSurface(
    boost::python::object const& py_nurb)
  {
    boost::python::extract<GLUnurbs*> nurb_proxy(py_nurb);
    GLUnurbs* nurb = nurb_proxy();
    gluBeginSurface(nurb);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_EndSurface(
    boost::python::object const& py_nurb)
  {
    boost::python::extract<GLUnurbs*> nurb_proxy(py_nurb);
    GLUnurbs* nurb = nurb_proxy();
    gluEndSurface(nurb);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_BeginTrim(
    boost::python::object const& py_nurb)
  {
    boost::python::extract<GLUnurbs*> nurb_proxy(py_nurb);
    GLUnurbs* nurb = nurb_proxy();
    gluBeginTrim(nurb);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_EndTrim(
    boost::python::object const& py_nurb)
  {
    boost::python::extract<GLUnurbs*> nurb_proxy(py_nurb);
    GLUnurbs* nurb = nurb_proxy();
    gluEndTrim(nurb);
  }
#endif

  GLint
  glu_Build1DMipmaps(
    boost::python::object const& py_target,
    boost::python::object const& py_internalFormat,
    boost::python::object const& py_width,
    boost::python::object const& py_format,
    boost::python::object const& py_type,
    boost::python::object const& py_data)
  {
    boost::python::extract<GLenum> target_proxy(py_target);
    GLenum target = target_proxy();
    boost::python::extract<GLint> internalFormat_proxy(py_internalFormat);
    GLint internalFormat = internalFormat_proxy();
    boost::python::extract<GLsizei> width_proxy(py_width);
    GLsizei width = width_proxy();
    boost::python::extract<GLenum> format_proxy(py_format);
    GLenum format = format_proxy();
    boost::python::extract<GLenum> type_proxy(py_type);
    GLenum type = type_proxy();
    throw std::runtime_error(
      "Conversion not implemented:"
      " gluBuild1DMipmaps(): const void* data");
  //  const void* data = 0;
  //  return gluBuild1DMipmaps(target, internalFormat, width, format, type,
  //    data);
  }

  GLint
  glu_Build2DMipmaps(
    boost::python::object const& py_target,
    boost::python::object const& py_internalFormat,
    boost::python::object const& py_width,
    boost::python::object const& py_height,
    boost::python::object const& py_format,
    boost::python::object const& py_type,
    boost::python::object const& py_data)
  {
    boost::python::extract<GLenum> target_proxy(py_target);
    GLenum target = target_proxy();
    boost::python::extract<GLint> internalFormat_proxy(py_internalFormat);
    GLint internalFormat = internalFormat_proxy();
    boost::python::extract<GLsizei> width_proxy(py_width);
    GLsizei width = width_proxy();
    boost::python::extract<GLsizei> height_proxy(py_height);
    GLsizei height = height_proxy();
    boost::python::extract<GLenum> format_proxy(py_format);
    GLenum format = format_proxy();
    boost::python::extract<GLenum> type_proxy(py_type);
    GLenum type = type_proxy();
    throw std::runtime_error(
      "Conversion not implemented:"
      " gluBuild2DMipmaps(): const void* data");
  //  const void* data = 0;
  //  return gluBuild2DMipmaps(target, internalFormat, width, height,
  //    format, type, data);
  }

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_Cylinder(
    boost::python::object const& py_quad,
    boost::python::object const& py_base,
    boost::python::object const& py_top,
    boost::python::object const& py_height,
    boost::python::object const& py_slices,
    boost::python::object const& py_stacks)
  {
    boost::python::extract<GLUquadric*> quad_proxy(py_quad);
    GLUquadric* quad = quad_proxy();
    boost::python::extract<GLdouble> base_proxy(py_base);
    GLdouble base = base_proxy();
    boost::python::extract<GLdouble> top_proxy(py_top);
    GLdouble top = top_proxy();
    boost::python::extract<GLdouble> height_proxy(py_height);
    GLdouble height = height_proxy();
    boost::python::extract<GLint> slices_proxy(py_slices);
    GLint slices = slices_proxy();
    boost::python::extract<GLint> stacks_proxy(py_stacks);
    GLint stacks = stacks_proxy();
    gluCylinder(quad, base, top, height, slices, stacks);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_DeleteNurbsRenderer(
    boost::python::object const& py_nurb)
  {
    boost::python::extract<GLUnurbs*> nurb_proxy(py_nurb);
    GLUnurbs* nurb = nurb_proxy();
    gluDeleteNurbsRenderer(nurb);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_DeleteQuadric(
    boost::python::object const& py_quad)
  {
    boost::python::extract<GLUquadric*> quad_proxy(py_quad);
    GLUquadric* quad = quad_proxy();
    gluDeleteQuadric(quad);
  }
#endif

} // namespace <anonymous>

namespace boost_python {

  void
  wrap_functions_00()
  {
    using namespace boost::python;
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluBeginCurve", glu_BeginCurve, (
      arg("nurb")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluEndCurve", glu_EndCurve, (
      arg("nurb")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluBeginPolygon", glu_BeginPolygon, (
      arg("tess")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluEndPolygon", glu_EndPolygon, (
      arg("tess")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluBeginSurface", glu_BeginSurface, (
      arg("nurb")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluEndSurface", glu_EndSurface, (
      arg("nurb")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluBeginTrim", glu_BeginTrim, (
      arg("nurb")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluEndTrim", glu_EndTrim, (
      arg("nurb")));
#endif
    def("gluBuild1DMipmaps", glu_Build1DMipmaps, (
      arg("target"), arg("internalFormat"), arg("width"), arg("format"),
      arg("type"), arg("data")));
    def("gluBuild2DMipmaps", glu_Build2DMipmaps, (
      arg("target"), arg("internalFormat"), arg("width"), arg("height"),
      arg("format"), arg("type"), arg("data")));
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluCylinder", glu_Cylinder, (
      arg("quad"), arg("base"), arg("top"), arg("height"), arg("slices"),
      arg("stacks")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluDeleteNurbsRenderer", glu_DeleteNurbsRenderer, (
      arg("nurb")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluDeleteQuadric", glu_DeleteQuadric, (
      arg("quad")));
#endif
  }

}}} // namespace gltbx::glu::boost_python
