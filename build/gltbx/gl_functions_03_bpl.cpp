/* *****************************************************
   THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT.
   *****************************************************

   Generated by:
     gltbx.generate_functions_bpl
 */

#include <gltbx/special_wrapper_support.h>
#include <gltbx/pointer_args_bpl.h>
#include <gltbx/error.h>

namespace gltbx { namespace gl { namespace {

  void
  gl_DrawBuffer(
    boost::python::object const& py_mode)
  {
    boost::python::extract<GLenum> mode_proxy(py_mode);
    GLenum mode = mode_proxy();
    glDrawBuffer(mode);
  }

  void
  gl_DrawElements(
    boost::python::object const& py_mode,
    boost::python::object const& py_count,
    boost::python::object const& py_type,
    boost::python::object const& py_indices)
  {
    boost::python::extract<GLenum> mode_proxy(py_mode);
    GLenum mode = mode_proxy();
    boost::python::extract<GLsizei> count_proxy(py_count);
    GLsizei count = count_proxy();
    boost::python::extract<GLenum> type_proxy(py_type);
    GLenum type = type_proxy();
    throw std::runtime_error(
      "Conversion not implemented:"
      " glDrawElements(): const GLvoid* indices");
  //  const GLvoid* indices = 0;
  //  glDrawElements(mode, count, type, indices);
  }

  void
  gl_DrawPixels(
    boost::python::object const& py_width,
    boost::python::object const& py_height,
    boost::python::object const& py_format,
    boost::python::object const& py_type,
    boost::python::object const& py_pixels)
  {
  
    boost::python::extract<GLsizei> width_proxy(py_width);
    GLsizei width = width_proxy();
    boost::python::extract<GLsizei> height_proxy(py_height);
    GLsizei height = height_proxy();
    boost::python::extract<GLenum> format_proxy(py_format);
    GLenum format = format_proxy();
    boost::python::extract<GLenum> type_proxy(py_type);
    GLenum type = type_proxy();
    if      (type == GL_BYTE) {
      boost_python::converter_str<GLubyte> pixels_proxy(
        "pixels", py_pixels, 0, true);
      const GLvoid* pixels = reinterpret_cast<const GLvoid*>(
        pixels_proxy.get());
      glDrawPixels(width, height, format, type, pixels);
    }
    else if (type == GL_UNSIGNED_BYTE) {
      boost_python::converter_str<GLbyte> pixels_proxy(
        "pixels", py_pixels, 0, true);
      const GLvoid* pixels = reinterpret_cast<const GLvoid*>(
        pixels_proxy.get());
      glDrawPixels(width, height, format, type, pixels);
    }
    else {
      throw std::runtime_error(
        "Conversion not implemented for given GLenum type:"
        " glDrawPixels(): const GLvoid* pixels");
    }
  }

  void
  gl_EdgeFlag(
    boost::python::object const& py_flag)
  {
    boost::python::extract<GLboolean> flag_proxy(py_flag);
    GLboolean flag = flag_proxy();
    glEdgeFlag(flag);
  }

  void
  gl_EdgeFlagv(
    boost::python::object const& py_flag)
  {
    boost_python::converter<GLboolean> flag_proxy(
      "flag", py_flag, 1, true);
    const GLboolean* flag = flag_proxy.get();
    glEdgeFlagv(flag);
  }

#if defined(GLTBX_XXX)
  void
  gl_EdgeFlagPointer(
    boost::python::object const& py_stride,
    boost::python::object const& py_pointer)
  {
    boost::python::extract<GLsizei> stride_proxy(py_stride);
    GLsizei stride = stride_proxy();
    throw std::runtime_error(
      "Conversion not implemented:"
      " glEdgeFlagPointer(): const GLvoid* pointer");
  //  const GLvoid* pointer = 0;
  //  glEdgeFlagPointer(stride, pointer);
  }
#endif

  void
  gl_EnableClientState(
    boost::python::object const& py_cap)
  {
    boost::python::extract<GLenum> cap_proxy(py_cap);
    GLenum cap = cap_proxy();
    glEnableClientState(cap);
  }

  void
  gl_DisableClientState(
    boost::python::object const& py_cap)
  {
    boost::python::extract<GLenum> cap_proxy(py_cap);
    GLenum cap = cap_proxy();
    glDisableClientState(cap);
  }

  void
  gl_Enable(
    boost::python::object const& py_cap)
  {
    boost::python::extract<GLenum> cap_proxy(py_cap);
    GLenum cap = cap_proxy();
    glEnable(cap);
  }

  void
  gl_Disable(
    boost::python::object const& py_cap)
  {
    boost::python::extract<GLenum> cap_proxy(py_cap);
    GLenum cap = cap_proxy();
    glDisable(cap);
  }

  void
  gl_EvalCoord1d(
    boost::python::object const& py_u)
  {
    boost::python::extract<GLdouble> u_proxy(py_u);
    GLdouble u = u_proxy();
    glEvalCoord1d(u);
  }

  void
  gl_EvalCoord1f(
    boost::python::object const& py_u)
  {
    boost::python::extract<GLfloat> u_proxy(py_u);
    GLfloat u = u_proxy();
    glEvalCoord1f(u);
  }

  void
  gl_EvalCoord2d(
    boost::python::object const& py_u,
    boost::python::object const& py_v)
  {
    boost::python::extract<GLdouble> u_proxy(py_u);
    GLdouble u = u_proxy();
    boost::python::extract<GLdouble> v_proxy(py_v);
    GLdouble v = v_proxy();
    glEvalCoord2d(u, v);
  }

  void
  gl_EvalCoord2f(
    boost::python::object const& py_u,
    boost::python::object const& py_v)
  {
    boost::python::extract<GLfloat> u_proxy(py_u);
    GLfloat u = u_proxy();
    boost::python::extract<GLfloat> v_proxy(py_v);
    GLfloat v = v_proxy();
    glEvalCoord2f(u, v);
  }

  void
  gl_EvalCoord1dv(
    boost::python::object const& py_u)
  {
    boost_python::converter<GLdouble> u_proxy(
      "u", py_u, 1, true);
    const GLdouble* u = u_proxy.get();
    glEvalCoord1dv(u);
  }

  void
  gl_EvalCoord1fv(
    boost::python::object const& py_u)
  {
    boost_python::converter<GLfloat> u_proxy(
      "u", py_u, 1, true);
    const GLfloat* u = u_proxy.get();
    glEvalCoord1fv(u);
  }

  void
  gl_EvalCoord2dv(
    boost::python::object const& py_u)
  {
    boost_python::converter<GLdouble> u_proxy(
      "u", py_u, 2, true);
    const GLdouble* u = u_proxy.get();
    glEvalCoord2dv(u);
  }

  void
  gl_EvalCoord2fv(
    boost::python::object const& py_u)
  {
    boost_python::converter<GLfloat> u_proxy(
      "u", py_u, 2, true);
    const GLfloat* u = u_proxy.get();
    glEvalCoord2fv(u);
  }

  void
  gl_EvalMesh1(
    boost::python::object const& py_mode,
    boost::python::object const& py_i1,
    boost::python::object const& py_i2)
  {
    boost::python::extract<GLenum> mode_proxy(py_mode);
    GLenum mode = mode_proxy();
    boost::python::extract<GLint> i1_proxy(py_i1);
    GLint i1 = i1_proxy();
    boost::python::extract<GLint> i2_proxy(py_i2);
    GLint i2 = i2_proxy();
    glEvalMesh1(mode, i1, i2);
  }

  void
  gl_EvalMesh2(
    boost::python::object const& py_mode,
    boost::python::object const& py_i1,
    boost::python::object const& py_i2,
    boost::python::object const& py_j1,
    boost::python::object const& py_j2)
  {
    boost::python::extract<GLenum> mode_proxy(py_mode);
    GLenum mode = mode_proxy();
    boost::python::extract<GLint> i1_proxy(py_i1);
    GLint i1 = i1_proxy();
    boost::python::extract<GLint> i2_proxy(py_i2);
    GLint i2 = i2_proxy();
    boost::python::extract<GLint> j1_proxy(py_j1);
    GLint j1 = j1_proxy();
    boost::python::extract<GLint> j2_proxy(py_j2);
    GLint j2 = j2_proxy();
    glEvalMesh2(mode, i1, i2, j1, j2);
  }

  void
  gl_EvalPoint1(
    boost::python::object const& py_i)
  {
    boost::python::extract<GLint> i_proxy(py_i);
    GLint i = i_proxy();
    glEvalPoint1(i);
  }

  void
  gl_EvalPoint2(
    boost::python::object const& py_i,
    boost::python::object const& py_j)
  {
    boost::python::extract<GLint> i_proxy(py_i);
    GLint i = i_proxy();
    boost::python::extract<GLint> j_proxy(py_j);
    GLint j = j_proxy();
    glEvalPoint2(i, j);
  }

} // namespace <anonymous>

namespace boost_python {

  void
  wrap_functions_03()
  {
    using namespace boost::python;
    def("glDrawBuffer", gl_DrawBuffer, (
      arg("mode")));
    def("glDrawElements", gl_DrawElements, (
      arg("mode"), arg("count"), arg("type"), arg("indices")));
    def("glDrawPixels", gl_DrawPixels, (
      arg("width"), arg("height"), arg("format"), arg("type"), arg("pixels")));
    def("glEdgeFlag", gl_EdgeFlag, (
      arg("flag")));
    def("glEdgeFlagv", gl_EdgeFlagv, (
      arg("flag")));
#if defined(GLTBX_XXX)
    def("glEdgeFlagPointer", gl_EdgeFlagPointer, (
      arg("stride"), arg("pointer")));
#endif
    def("glEnableClientState", gl_EnableClientState, (
      arg("cap")));
    def("glDisableClientState", gl_DisableClientState, (
      arg("cap")));
    def("glEnable", gl_Enable, (
      arg("cap")));
    def("glDisable", gl_Disable, (
      arg("cap")));
    def("glEvalCoord1d", gl_EvalCoord1d, (
      arg("u")));
    def("glEvalCoord1f", gl_EvalCoord1f, (
      arg("u")));
    def("glEvalCoord2d", gl_EvalCoord2d, (
      arg("u"), arg("v")));
    def("glEvalCoord2f", gl_EvalCoord2f, (
      arg("u"), arg("v")));
    def("glEvalCoord1dv", gl_EvalCoord1dv, (
      arg("u")));
    def("glEvalCoord1fv", gl_EvalCoord1fv, (
      arg("u")));
    def("glEvalCoord2dv", gl_EvalCoord2dv, (
      arg("u")));
    def("glEvalCoord2fv", gl_EvalCoord2fv, (
      arg("u")));
    def("glEvalMesh1", gl_EvalMesh1, (
      arg("mode"), arg("i1"), arg("i2")));
    def("glEvalMesh2", gl_EvalMesh2, (
      arg("mode"), arg("i1"), arg("i2"), arg("j1"), arg("j2")));
    def("glEvalPoint1", gl_EvalPoint1, (
      arg("i")));
    def("glEvalPoint2", gl_EvalPoint2, (
      arg("i"), arg("j")));
  }

}}} // namespace gltbx::gl::boost_python
