/* *****************************************************
   THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT.
   *****************************************************

   Generated by:
     gltbx.generate_functions_bpl
 */

#include <gltbx/special_wrapper_support.h>
#include <gltbx/pointer_args_bpl.h>
#include <gltbx/error.h>

#if defined(__GNUC__) && __GNUC__ == 2 \
     && __GNUC_MINOR__ == 96 && __GNUC_PATCHLEVEL__ == 0
#define GLTBX_NO_OPAQUE_POINTERS
#else
#include <boost/python/return_value_policy.hpp>
#include <boost/python/return_opaque_pointer.hpp>
BOOST_PYTHON_OPAQUE_SPECIALIZED_TYPE_ID(GLUnurbs)
BOOST_PYTHON_OPAQUE_SPECIALIZED_TYPE_ID(GLUquadric)
BOOST_PYTHON_OPAQUE_SPECIALIZED_TYPE_ID(GLUtesselator)
#endif

namespace gltbx { namespace glu { namespace {

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_QuadricOrientation(
    boost::python::object const& py_quad,
    boost::python::object const& py_orientation)
  {
    boost::python::extract<GLUquadric*> quad_proxy(py_quad);
    GLUquadric* quad = quad_proxy();
    boost::python::extract<GLenum> orientation_proxy(py_orientation);
    GLenum orientation = orientation_proxy();
    gluQuadricOrientation(quad, orientation);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_QuadricTexture(
    boost::python::object const& py_quad,
    boost::python::object const& py_texture)
  {
    boost::python::extract<GLUquadric*> quad_proxy(py_quad);
    GLUquadric* quad = quad_proxy();
    boost::python::extract<GLboolean> texture_proxy(py_texture);
    GLboolean texture = texture_proxy();
    gluQuadricTexture(quad, texture);
  }
#endif

  GLint
  glu_ScaleImage(
    boost::python::object const& py_format,
    boost::python::object const& py_wIn,
    boost::python::object const& py_hIn,
    boost::python::object const& py_typeIn,
    boost::python::object const& py_dataIn,
    boost::python::object const& py_wOut,
    boost::python::object const& py_hOut,
    boost::python::object const& py_typeOut,
    boost::python::object const& py_dataOut)
  {
    boost::python::extract<GLenum> format_proxy(py_format);
    GLenum format = format_proxy();
    boost::python::extract<GLsizei> wIn_proxy(py_wIn);
    GLsizei wIn = wIn_proxy();
    boost::python::extract<GLsizei> hIn_proxy(py_hIn);
    GLsizei hIn = hIn_proxy();
    boost::python::extract<GLenum> typeIn_proxy(py_typeIn);
    GLenum typeIn = typeIn_proxy();
    throw std::runtime_error(
      "Conversion not implemented:"
      " gluScaleImage(): const void* dataIn");
  //  const void* dataIn = 0;
  //  boost::python::extract<GLsizei> wOut_proxy(py_wOut);
  //  GLsizei wOut = wOut_proxy();
  //  boost::python::extract<GLsizei> hOut_proxy(py_hOut);
  //  GLsizei hOut = hOut_proxy();
  //  boost::python::extract<GLenum> typeOut_proxy(py_typeOut);
  //  GLenum typeOut = typeOut_proxy();
  //  throw std::runtime_error(
  //    "Conversion not implemented:"
  //    " gluScaleImage(): GLvoid* dataOut");
  //  GLvoid* dataOut = 0;
  //  return gluScaleImage(format, wIn, hIn, typeIn, dataIn, wOut, hOut,
  //    typeOut, dataOut);
  }

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_Sphere(
    boost::python::object const& py_quad,
    boost::python::object const& py_radius,
    boost::python::object const& py_slices,
    boost::python::object const& py_stacks)
  {
    boost::python::extract<GLUquadric*> quad_proxy(py_quad);
    GLUquadric* quad = quad_proxy();
    boost::python::extract<GLdouble> radius_proxy(py_radius);
    GLdouble radius = radius_proxy();
    boost::python::extract<GLint> slices_proxy(py_slices);
    GLint slices = slices_proxy();
    boost::python::extract<GLint> stacks_proxy(py_stacks);
    GLint stacks = stacks_proxy();
    gluSphere(quad, radius, slices, stacks);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessBeginContour(
    boost::python::object const& py_tess)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    gluTessBeginContour(tess);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessEndContour(
    boost::python::object const& py_tess)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    gluTessEndContour(tess);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessBeginPolygon(
    boost::python::object const& py_tess,
    boost::python::object const& py_data)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    throw std::runtime_error(
      "Conversion not implemented:"
      " gluTessBeginPolygon(): GLvoid* data");
  //  GLvoid* data = 0;
  //  gluTessBeginPolygon(tess, data);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessCallback(
    boost::python::object const& py_tess,
    boost::python::object const& py_which,
    boost::python::object const& py_fn)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    boost::python::extract<GLenum> which_proxy(py_which);
    GLenum which = which_proxy();
    throw std::runtime_error(
      "Conversion not implemented:"
      " gluTessCallback(): glu_function_pointer fn");
  //  glu_function_pointer fn = 0;
  //  gluTessCallback(tess, which, fn);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessEndPolygon(
    boost::python::object const& py_tess)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    gluTessEndPolygon(tess);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessNormal(
    boost::python::object const& py_tess,
    boost::python::object const& py_valueX,
    boost::python::object const& py_valueY,
    boost::python::object const& py_valueZ)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    boost::python::extract<GLdouble> valueX_proxy(py_valueX);
    GLdouble valueX = valueX_proxy();
    boost::python::extract<GLdouble> valueY_proxy(py_valueY);
    GLdouble valueY = valueY_proxy();
    boost::python::extract<GLdouble> valueZ_proxy(py_valueZ);
    GLdouble valueZ = valueZ_proxy();
    gluTessNormal(tess, valueX, valueY, valueZ);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessProperty(
    boost::python::object const& py_tess,
    boost::python::object const& py_which,
    boost::python::object const& py_data)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    boost::python::extract<GLenum> which_proxy(py_which);
    GLenum which = which_proxy();
    boost::python::extract<GLdouble> data_proxy(py_data);
    GLdouble data = data_proxy();
    gluTessProperty(tess, which, data);
  }
#endif

#if !defined(GLTBX_NO_OPAQUE_POINTERS)
  void
  glu_TessVertex(
    boost::python::object const& py_tess,
    boost::python::object const& py_location,
    boost::python::object const& py_data)
  {
    boost::python::extract<GLUtesselator*> tess_proxy(py_tess);
    GLUtesselator* tess = tess_proxy();
    boost_python::converter<GLdouble> location_proxy(
      "location", py_location, 0, false);
    GLdouble* location = location_proxy.get();
    throw std::runtime_error(
      "Conversion not implemented:"
      " gluTessVertex(): GLvoid* data");
  //  GLvoid* data = 0;
  //  gluTessVertex(tess, location, data);
  //  location_proxy.write_back();
  }
#endif

  GLint
  glu_UnProject(
    boost::python::object const& py_winX,
    boost::python::object const& py_winY,
    boost::python::object const& py_winZ,
    boost::python::object const& py_model,
    boost::python::object const& py_proj,
    boost::python::object const& py_view,
    boost::python::object const& py_objX,
    boost::python::object const& py_objY,
    boost::python::object const& py_objZ)
  {
    boost::python::extract<GLdouble> winX_proxy(py_winX);
    GLdouble winX = winX_proxy();
    boost::python::extract<GLdouble> winY_proxy(py_winY);
    GLdouble winY = winY_proxy();
    boost::python::extract<GLdouble> winZ_proxy(py_winZ);
    GLdouble winZ = winZ_proxy();
    boost_python::converter<GLdouble> model_proxy(
      "model", py_model, 16, true);
    const GLdouble* model = model_proxy.get();
    boost_python::converter<GLdouble> proj_proxy(
      "proj", py_proj, 16, true);
    const GLdouble* proj = proj_proxy.get();
    boost_python::converter<GLint> view_proxy(
      "view", py_view, 4, true);
    const GLint* view = view_proxy.get();
    boost_python::converter<GLdouble> objX_proxy(
      "objX", py_objX, 1, false);
    GLdouble* objX = objX_proxy.get();
    boost_python::converter<GLdouble> objY_proxy(
      "objY", py_objY, 1, false);
    GLdouble* objY = objY_proxy.get();
    boost_python::converter<GLdouble> objZ_proxy(
      "objZ", py_objZ, 1, false);
    GLdouble* objZ = objZ_proxy.get();
    GLint result = gluUnProject(winX, winY, winZ, model, proj, view, objX,
      objY, objZ);
    objX_proxy.write_back();
    objY_proxy.write_back();
    objZ_proxy.write_back();
    return result;
  }

} // namespace <anonymous>

namespace boost_python {

  void
  wrap_functions_03()
  {
    using namespace boost::python;
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluQuadricOrientation", glu_QuadricOrientation, (
      arg("quad"), arg("orientation")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluQuadricTexture", glu_QuadricTexture, (
      arg("quad"), arg("texture")));
#endif
    def("gluScaleImage", glu_ScaleImage, (
      arg("format"), arg("wIn"), arg("hIn"), arg("typeIn"), arg("dataIn"),
      arg("wOut"), arg("hOut"), arg("typeOut"), arg("dataOut")));
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluSphere", glu_Sphere, (
      arg("quad"), arg("radius"), arg("slices"), arg("stacks")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessBeginContour", glu_TessBeginContour, (
      arg("tess")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessEndContour", glu_TessEndContour, (
      arg("tess")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessBeginPolygon", glu_TessBeginPolygon, (
      arg("tess"), arg("data")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessCallback", glu_TessCallback, (
      arg("tess"), arg("which"), arg("fn")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessEndPolygon", glu_TessEndPolygon, (
      arg("tess")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessNormal", glu_TessNormal, (
      arg("tess"), arg("valueX"), arg("valueY"), arg("valueZ")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessProperty", glu_TessProperty, (
      arg("tess"), arg("which"), arg("data")));
#endif
#if !defined(GLTBX_NO_OPAQUE_POINTERS)
    def("gluTessVertex", glu_TessVertex, (
      arg("tess"), arg("location"), arg("data")));
#endif
    def("gluUnProject", glu_UnProject, (
      arg("winX"), arg("winY"), arg("winZ"), arg("model"), arg("proj"),
      arg("view"), arg("objX"), arg("objY"), arg("objZ")));
  }

}}} // namespace gltbx::glu::boost_python
