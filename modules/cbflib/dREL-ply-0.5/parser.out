Created by PLY version 3.2 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> final_input
Rule 1     final_input -> input
Rule 2     input -> statement
Rule 3     input -> input statement
Rule 4     statement -> stmt_list
Rule 5     statement -> compound_stmt
Rule 6     stmt_list -> simple_stmt
Rule 7     stmt_list -> stmt_list ; simple_stmt
Rule 8     stmt_list -> stmt_list ; simple_stmt ;
Rule 9     simple_stmt -> assignment_stmt
Rule 10    simple_stmt -> augmented_assignment_stmt
Rule 11    simple_stmt -> fancy_drel_assignment_stmt
Rule 12    simple_stmt -> print_stmt
Rule 13    simple_stmt -> BREAK
Rule 14    simple_stmt -> NEXT
Rule 15    print_stmt -> PRINT expression
Rule 16    expression_list -> expression
Rule 17    expression_list -> expression_list , expression
Rule 18    expression -> or_test
Rule 19    target -> primary
Rule 20    target -> ( target_list )
Rule 21    target -> [ target_list ]
Rule 22    or_test -> and_test
Rule 23    or_test -> or_test OR and_test
Rule 24    and_test -> not_test
Rule 25    and_test -> and_test AND not_test
Rule 26    not_test -> comparison
Rule 27    not_test -> NOT not_test
Rule 28    comparison -> a_expr
Rule 29    comparison -> a_expr comp_operator a_expr
Rule 30    comp_operator -> <
Rule 31    comp_operator -> >
Rule 32    comp_operator -> GTE
Rule 33    comp_operator -> LTE
Rule 34    comp_operator -> NEQ
Rule 35    comp_operator -> ISEQUAL
Rule 36    comp_operator -> IN
Rule 37    comp_operator -> NOT IN
Rule 38    a_expr -> m_expr
Rule 39    a_expr -> a_expr + m_expr
Rule 40    a_expr -> a_expr - m_expr
Rule 41    m_expr -> u_expr
Rule 42    m_expr -> m_expr * u_expr
Rule 43    m_expr -> m_expr / u_expr
Rule 44    m_expr -> m_expr ^ u_expr
Rule 45    u_expr -> power
Rule 46    u_expr -> - u_expr
Rule 47    u_expr -> + u_expr
Rule 48    power -> primary
Rule 49    power -> primary POWER u_expr
Rule 50    primary -> atom
Rule 51    primary -> primary_att
Rule 52    primary -> subscription
Rule 53    primary -> slicing
Rule 54    primary -> call
Rule 55    primary_att -> attributeref
Rule 56    atom -> ID
Rule 57    atom -> item_tag
Rule 58    atom -> literal
Rule 59    atom -> enclosure
Rule 60    item_tag -> ITEM_TAG
Rule 61    literal -> stringliteral
Rule 62    literal -> INTEGER
Rule 63    literal -> HEXINT
Rule 64    literal -> OCTINT
Rule 65    literal -> BININT
Rule 66    literal -> REAL
Rule 67    literal -> IMAGINARY
Rule 68    stringliteral -> STRPREFIX SHORTSTRING
Rule 69    stringliteral -> STRPREFIX LONGSTRING
Rule 70    stringliteral -> SHORTSTRING
Rule 71    stringliteral -> LONGSTRING
Rule 72    enclosure -> parenth_form
Rule 73    enclosure -> string_conversion
Rule 74    enclosure -> list_display
Rule 75    parenth_form -> ( expression_list )
Rule 76    parenth_form -> ( )
Rule 77    string_conversion -> ` expression_list `
Rule 78    list_display -> [ listmaker ]
Rule 79    list_display -> [ ]
Rule 80    listmaker -> expression listmaker2
Rule 81    listmaker -> expression list_for
Rule 82    listmaker2 -> , expression
Rule 83    listmaker2 -> listmaker2 , expression
Rule 84    listmaker2 -> <empty>
Rule 85    list_for -> FOR expression_list IN testlist
Rule 86    list_for -> FOR expression_list IN testlist list_iter
Rule 87    testlist -> or_test
Rule 88    testlist -> testlist , or_test
Rule 89    testlist -> testlist , or_test ,
Rule 90    list_iter -> list_for
Rule 91    list_iter -> list_if
Rule 92    list_if -> IF or_test
Rule 93    list_if -> IF or_test list_iter
Rule 94    attributeref -> primary attribute_tag
Rule 95    attribute_tag -> . ID
Rule 96    attribute_tag -> REAL
Rule 97    subscription -> primary [ expression_list ]
Rule 98    slicing -> simple_slicing
Rule 99    slicing -> extended_slicing
Rule 100   simple_slicing -> primary [ short_slice ]
Rule 101   short_slice -> :
Rule 102   short_slice -> expression : expression
Rule 103   short_slice -> : expression
Rule 104   short_slice -> expression :
Rule 105   extended_slicing -> primary [ slice_list ]
Rule 106   slice_list -> slice_item
Rule 107   slice_list -> slice_list , slice_item
Rule 108   slice_item -> expression
Rule 109   slice_item -> proper_slice
Rule 110   slice_item -> ELLIPSIS
Rule 111   proper_slice -> short_slice
Rule 112   proper_slice -> long_slice
Rule 113   long_slice -> short_slice :
Rule 114   long_slice -> short_slice : expression
Rule 115   call -> primary ( )
Rule 116   call -> primary ( argument_list )
Rule 117   argument_list -> func_arg
Rule 118   argument_list -> argument_list , func_arg
Rule 119   func_arg -> expression
Rule 120   augmented_assignment_stmt -> target AUGOP expression_list
Rule 121   fancy_drel_assignment_stmt -> primary ( dotlist )
Rule 122   dotlist -> . ID = expression
Rule 123   dotlist -> dotlist , . ID = expression
Rule 124   assignment_stmt -> target_list = expression_list
Rule 125   target_list -> target
Rule 126   target_list -> target_list , target
Rule 127   compound_stmt -> if_stmt
Rule 128   compound_stmt -> for_stmt
Rule 129   compound_stmt -> do_stmt
Rule 130   compound_stmt -> loop_stmt
Rule 131   compound_stmt -> with_stmt
Rule 132   compound_stmt -> where_stmt
Rule 133   compound_stmt -> switch_stmt
Rule 134   compound_stmt -> funcdef
Rule 135   if_stmt -> IF expression suite
Rule 136   if_stmt -> if_stmt ELSE suite
Rule 137   suite -> simple_stmt
Rule 138   suite -> compound_stmt
Rule 139   suite -> open_brace statement_block close_brace
Rule 140   open_brace -> {
Rule 141   close_brace -> }
Rule 142   statement_block -> statement
Rule 143   statement_block -> statement_block statement
Rule 144   for_stmt -> FOR target_list IN expression_list suite
Rule 145   loop_stmt -> loop_head suite
Rule 146   loop_head -> LOOP ID AS ID
Rule 147   loop_head -> LOOP ID AS ID : ID
Rule 148   loop_head -> LOOP ID AS ID : ID comp_operator ID
Rule 149   do_stmt -> do_stmt_head suite
Rule 150   do_stmt_head -> DO ID = expression , expression
Rule 151   do_stmt_head -> DO ID = expression , expression , expression
Rule 152   with_stmt -> with_head suite
Rule 153   with_head -> WITH ID AS ID
Rule 154   where_stmt -> WHERE expression suite ELSE suite
Rule 155   switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace
Rule 156   caselist -> CASE target_list suite
Rule 157   caselist -> caselist CASE target_list suite
Rule 158   funcdef -> FUNCTION ID ( arglist ) suite
Rule 159   arglist -> ID : list_display
Rule 160   arglist -> arglist , ID : list_display

Terminals, with rules where they appear

(                    : 20 75 76 115 116 121 158
)                    : 20 75 76 115 116 121 158
*                    : 42
+                    : 39 47
,                    : 17 82 83 88 89 89 107 118 123 126 150 151 151 160
-                    : 40 46
.                    : 95 122 123
/                    : 43
:                    : 101 102 103 104 113 114 147 148 159 160
;                    : 7 8 8
<                    : 30
=                    : 122 123 124 150 151
>                    : 31
AND                  : 25
AS                   : 146 147 148 153
AUGOP                : 120
BININT               : 65
BREAK                : 13
CASE                 : 156 157
COMMENT              : 
DEFAULT              : 155
DO                   : 150 151
ELLIPSIS             : 110
ELSE                 : 136 154
FOR                  : 85 86 144
FUNCTION             : 158
GTE                  : 32
HEXINT               : 63
ID                   : 56 95 122 123 146 146 147 147 147 148 148 148 148 150 151 153 153 155 158 159 160
IF                   : 92 93 135
IMAGINARY            : 67
IN                   : 36 37 85 86 144
INTEGER              : 62
ISEQUAL              : 35
ITEM_TAG             : 60
LONGSTRING           : 69 71
LOOP                 : 146 147 148
LTE                  : 33
NEQ                  : 34
NEXT                 : 14
NOT                  : 27 37
OCTINT               : 64
OR                   : 23
POWER                : 49
PRINT                : 15
REAL                 : 66 96
SHORTSTRING          : 68 70
STRPREFIX            : 68 69
SWITCH               : 155
WHERE                : 154
WITH                 : 153
[                    : 21 78 79 97 100 105
]                    : 21 78 79 97 100 105
^                    : 44
`                    : 77 77
error                : 
{                    : 140
}                    : 141

Nonterminals, with rules where they appear

a_expr               : 28 29 29 39 40
and_test             : 22 23 25
arglist              : 158 160
argument_list        : 116 118
assignment_stmt      : 9
atom                 : 50
attribute_tag        : 94
attributeref         : 55
augmented_assignment_stmt : 10
call                 : 54
caselist             : 155 157
close_brace          : 139 155
comp_operator        : 29 148
comparison           : 26
compound_stmt        : 5 138
do_stmt              : 129
do_stmt_head         : 149
dotlist              : 121 123
enclosure            : 59
expression           : 15 16 17 80 81 82 83 102 102 103 104 108 114 119 122 123 135 150 150 151 151 151 154
expression_list      : 17 75 77 85 86 97 120 124 144
extended_slicing     : 99
fancy_drel_assignment_stmt : 11
final_input          : 0
for_stmt             : 128
func_arg             : 117 118
funcdef              : 134
if_stmt              : 127 136
input                : 1 3
item_tag             : 57
list_display         : 74 159 160
list_for             : 81 90
list_if              : 91
list_iter            : 86 93
listmaker            : 78
listmaker2           : 80 83
literal              : 58
long_slice           : 112
loop_head            : 145
loop_stmt            : 130
m_expr               : 38 39 40 42 43 44
not_test             : 24 25 27
open_brace           : 139 155
or_test              : 18 23 87 88 89 92 93
parenth_form         : 72
power                : 45
primary              : 19 48 49 94 97 100 105 115 116 121
primary_att          : 51
print_stmt           : 12
proper_slice         : 109
short_slice          : 100 111 113 114
simple_slicing       : 98
simple_stmt          : 6 7 8 137
slice_item           : 106 107
slice_list           : 105 107
slicing              : 53
statement            : 2 3 142 143
statement_block      : 139 143
stmt_list            : 4 7 8
string_conversion    : 73
stringliteral        : 61
subscription         : 52
suite                : 135 136 144 145 149 152 154 154 155 156 157 158
switch_stmt          : 133
target               : 120 125 126
target_list          : 20 21 124 126 144 156 157
testlist             : 85 86 88 89
u_expr               : 41 42 43 44 46 47 49
where_stmt           : 132
with_head            : 152
with_stmt            : 131

Parsing method: LALR

state 0

    (0) S' -> . final_input
    (1) final_input -> . input
    (2) input -> . statement
    (3) input -> . input statement
    (4) statement -> . stmt_list
    (5) statement -> . compound_stmt
    (6) stmt_list -> . simple_stmt
    (7) stmt_list -> . stmt_list ; simple_stmt
    (8) stmt_list -> . stmt_list ; simple_stmt ;
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    PRINT           shift and go to state 28
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    final_input                    shift and go to state 1
    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    primary                        shift and go to state 42
    augmented_assignment_stmt      shift and go to state 27
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    subscription                   shift and go to state 53
    parenth_form                   shift and go to state 8
    print_stmt                     shift and go to state 50
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    statement                      shift and go to state 48
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 35
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    simple_stmt                    shift and go to state 14
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    input                          shift and go to state 11
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    stmt_list                      shift and go to state 62
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    with_stmt                      shift and go to state 24
    atom                           shift and go to state 2

state 1

    (0) S' -> final_input .



state 2

    (50) primary -> atom .

    (               reduce using rule 50 (primary -> atom .)
    [               reduce using rule 50 (primary -> atom .)
    .               reduce using rule 50 (primary -> atom .)
    REAL            reduce using rule 50 (primary -> atom .)
    AUGOP           reduce using rule 50 (primary -> atom .)
    =               reduce using rule 50 (primary -> atom .)
    ,               reduce using rule 50 (primary -> atom .)
    POWER           reduce using rule 50 (primary -> atom .)
    *               reduce using rule 50 (primary -> atom .)
    /               reduce using rule 50 (primary -> atom .)
    ^               reduce using rule 50 (primary -> atom .)
    +               reduce using rule 50 (primary -> atom .)
    -               reduce using rule 50 (primary -> atom .)
    <               reduce using rule 50 (primary -> atom .)
    >               reduce using rule 50 (primary -> atom .)
    GTE             reduce using rule 50 (primary -> atom .)
    LTE             reduce using rule 50 (primary -> atom .)
    NEQ             reduce using rule 50 (primary -> atom .)
    ISEQUAL         reduce using rule 50 (primary -> atom .)
    IN              reduce using rule 50 (primary -> atom .)
    NOT             reduce using rule 50 (primary -> atom .)
    AND             reduce using rule 50 (primary -> atom .)
    OR              reduce using rule 50 (primary -> atom .)
    ;               reduce using rule 50 (primary -> atom .)
    BREAK           reduce using rule 50 (primary -> atom .)
    NEXT            reduce using rule 50 (primary -> atom .)
    IF              reduce using rule 50 (primary -> atom .)
    FOR             reduce using rule 50 (primary -> atom .)
    WHERE           reduce using rule 50 (primary -> atom .)
    SWITCH          reduce using rule 50 (primary -> atom .)
    FUNCTION        reduce using rule 50 (primary -> atom .)
    PRINT           reduce using rule 50 (primary -> atom .)
    DO              reduce using rule 50 (primary -> atom .)
    LOOP            reduce using rule 50 (primary -> atom .)
    WITH            reduce using rule 50 (primary -> atom .)
    ID              reduce using rule 50 (primary -> atom .)
    ITEM_TAG        reduce using rule 50 (primary -> atom .)
    INTEGER         reduce using rule 50 (primary -> atom .)
    HEXINT          reduce using rule 50 (primary -> atom .)
    OCTINT          reduce using rule 50 (primary -> atom .)
    BININT          reduce using rule 50 (primary -> atom .)
    IMAGINARY       reduce using rule 50 (primary -> atom .)
    STRPREFIX       reduce using rule 50 (primary -> atom .)
    SHORTSTRING     reduce using rule 50 (primary -> atom .)
    LONGSTRING      reduce using rule 50 (primary -> atom .)
    `               reduce using rule 50 (primary -> atom .)
    $end            reduce using rule 50 (primary -> atom .)
    }               reduce using rule 50 (primary -> atom .)
    ELSE            reduce using rule 50 (primary -> atom .)
    DEFAULT         reduce using rule 50 (primary -> atom .)
    CASE            reduce using rule 50 (primary -> atom .)
    )               reduce using rule 50 (primary -> atom .)
    :               reduce using rule 50 (primary -> atom .)
    ]               reduce using rule 50 (primary -> atom .)
    {               reduce using rule 50 (primary -> atom .)


state 3

    (134) compound_stmt -> funcdef .

    BREAK           reduce using rule 134 (compound_stmt -> funcdef .)
    NEXT            reduce using rule 134 (compound_stmt -> funcdef .)
    IF              reduce using rule 134 (compound_stmt -> funcdef .)
    FOR             reduce using rule 134 (compound_stmt -> funcdef .)
    WHERE           reduce using rule 134 (compound_stmt -> funcdef .)
    SWITCH          reduce using rule 134 (compound_stmt -> funcdef .)
    FUNCTION        reduce using rule 134 (compound_stmt -> funcdef .)
    PRINT           reduce using rule 134 (compound_stmt -> funcdef .)
    DO              reduce using rule 134 (compound_stmt -> funcdef .)
    LOOP            reduce using rule 134 (compound_stmt -> funcdef .)
    WITH            reduce using rule 134 (compound_stmt -> funcdef .)
    (               reduce using rule 134 (compound_stmt -> funcdef .)
    [               reduce using rule 134 (compound_stmt -> funcdef .)
    ID              reduce using rule 134 (compound_stmt -> funcdef .)
    ITEM_TAG        reduce using rule 134 (compound_stmt -> funcdef .)
    INTEGER         reduce using rule 134 (compound_stmt -> funcdef .)
    HEXINT          reduce using rule 134 (compound_stmt -> funcdef .)
    OCTINT          reduce using rule 134 (compound_stmt -> funcdef .)
    BININT          reduce using rule 134 (compound_stmt -> funcdef .)
    REAL            reduce using rule 134 (compound_stmt -> funcdef .)
    IMAGINARY       reduce using rule 134 (compound_stmt -> funcdef .)
    STRPREFIX       reduce using rule 134 (compound_stmt -> funcdef .)
    SHORTSTRING     reduce using rule 134 (compound_stmt -> funcdef .)
    LONGSTRING      reduce using rule 134 (compound_stmt -> funcdef .)
    `               reduce using rule 134 (compound_stmt -> funcdef .)
    $end            reduce using rule 134 (compound_stmt -> funcdef .)
    }               reduce using rule 134 (compound_stmt -> funcdef .)
    ELSE            reduce using rule 134 (compound_stmt -> funcdef .)
    DEFAULT         reduce using rule 134 (compound_stmt -> funcdef .)
    CASE            reduce using rule 134 (compound_stmt -> funcdef .)


state 4

    (149) do_stmt -> do_stmt_head . suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 65
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 5

    (153) with_head -> WITH . ID AS ID

    ID              shift and go to state 70


state 6

    (20) target -> ( . target_list )
    (75) parenth_form -> ( . expression_list )
    (76) parenth_form -> ( . )
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (18) expression -> . or_test
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr

    )               shift and go to state 76
    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    NOT             shift and go to state 72
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20
    -               shift and go to state 79
    +               shift and go to state 77

    primary_att                    shift and go to state 41
    primary                        shift and go to state 73
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    target_list                    shift and go to state 81
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    target                         shift and go to state 84
    expression_list                shift and go to state 85
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 87

state 7

    (14) simple_stmt -> NEXT .

    ;               reduce using rule 14 (simple_stmt -> NEXT .)
    BREAK           reduce using rule 14 (simple_stmt -> NEXT .)
    NEXT            reduce using rule 14 (simple_stmt -> NEXT .)
    IF              reduce using rule 14 (simple_stmt -> NEXT .)
    FOR             reduce using rule 14 (simple_stmt -> NEXT .)
    WHERE           reduce using rule 14 (simple_stmt -> NEXT .)
    SWITCH          reduce using rule 14 (simple_stmt -> NEXT .)
    FUNCTION        reduce using rule 14 (simple_stmt -> NEXT .)
    PRINT           reduce using rule 14 (simple_stmt -> NEXT .)
    DO              reduce using rule 14 (simple_stmt -> NEXT .)
    LOOP            reduce using rule 14 (simple_stmt -> NEXT .)
    WITH            reduce using rule 14 (simple_stmt -> NEXT .)
    (               reduce using rule 14 (simple_stmt -> NEXT .)
    [               reduce using rule 14 (simple_stmt -> NEXT .)
    ID              reduce using rule 14 (simple_stmt -> NEXT .)
    ITEM_TAG        reduce using rule 14 (simple_stmt -> NEXT .)
    INTEGER         reduce using rule 14 (simple_stmt -> NEXT .)
    HEXINT          reduce using rule 14 (simple_stmt -> NEXT .)
    OCTINT          reduce using rule 14 (simple_stmt -> NEXT .)
    BININT          reduce using rule 14 (simple_stmt -> NEXT .)
    REAL            reduce using rule 14 (simple_stmt -> NEXT .)
    IMAGINARY       reduce using rule 14 (simple_stmt -> NEXT .)
    STRPREFIX       reduce using rule 14 (simple_stmt -> NEXT .)
    SHORTSTRING     reduce using rule 14 (simple_stmt -> NEXT .)
    LONGSTRING      reduce using rule 14 (simple_stmt -> NEXT .)
    `               reduce using rule 14 (simple_stmt -> NEXT .)
    $end            reduce using rule 14 (simple_stmt -> NEXT .)
    }               reduce using rule 14 (simple_stmt -> NEXT .)
    ELSE            reduce using rule 14 (simple_stmt -> NEXT .)
    DEFAULT         reduce using rule 14 (simple_stmt -> NEXT .)
    CASE            reduce using rule 14 (simple_stmt -> NEXT .)


state 8

    (72) enclosure -> parenth_form .

    POWER           reduce using rule 72 (enclosure -> parenth_form .)
    [               reduce using rule 72 (enclosure -> parenth_form .)
    (               reduce using rule 72 (enclosure -> parenth_form .)
    .               reduce using rule 72 (enclosure -> parenth_form .)
    REAL            reduce using rule 72 (enclosure -> parenth_form .)
    *               reduce using rule 72 (enclosure -> parenth_form .)
    /               reduce using rule 72 (enclosure -> parenth_form .)
    ^               reduce using rule 72 (enclosure -> parenth_form .)
    +               reduce using rule 72 (enclosure -> parenth_form .)
    -               reduce using rule 72 (enclosure -> parenth_form .)
    <               reduce using rule 72 (enclosure -> parenth_form .)
    >               reduce using rule 72 (enclosure -> parenth_form .)
    GTE             reduce using rule 72 (enclosure -> parenth_form .)
    LTE             reduce using rule 72 (enclosure -> parenth_form .)
    NEQ             reduce using rule 72 (enclosure -> parenth_form .)
    ISEQUAL         reduce using rule 72 (enclosure -> parenth_form .)
    IN              reduce using rule 72 (enclosure -> parenth_form .)
    NOT             reduce using rule 72 (enclosure -> parenth_form .)
    AND             reduce using rule 72 (enclosure -> parenth_form .)
    OR              reduce using rule 72 (enclosure -> parenth_form .)
    )               reduce using rule 72 (enclosure -> parenth_form .)
    ,               reduce using rule 72 (enclosure -> parenth_form .)
    BREAK           reduce using rule 72 (enclosure -> parenth_form .)
    NEXT            reduce using rule 72 (enclosure -> parenth_form .)
    {               reduce using rule 72 (enclosure -> parenth_form .)
    PRINT           reduce using rule 72 (enclosure -> parenth_form .)
    IF              reduce using rule 72 (enclosure -> parenth_form .)
    FOR             reduce using rule 72 (enclosure -> parenth_form .)
    WHERE           reduce using rule 72 (enclosure -> parenth_form .)
    SWITCH          reduce using rule 72 (enclosure -> parenth_form .)
    FUNCTION        reduce using rule 72 (enclosure -> parenth_form .)
    DO              reduce using rule 72 (enclosure -> parenth_form .)
    LOOP            reduce using rule 72 (enclosure -> parenth_form .)
    WITH            reduce using rule 72 (enclosure -> parenth_form .)
    ID              reduce using rule 72 (enclosure -> parenth_form .)
    ITEM_TAG        reduce using rule 72 (enclosure -> parenth_form .)
    INTEGER         reduce using rule 72 (enclosure -> parenth_form .)
    HEXINT          reduce using rule 72 (enclosure -> parenth_form .)
    OCTINT          reduce using rule 72 (enclosure -> parenth_form .)
    BININT          reduce using rule 72 (enclosure -> parenth_form .)
    IMAGINARY       reduce using rule 72 (enclosure -> parenth_form .)
    STRPREFIX       reduce using rule 72 (enclosure -> parenth_form .)
    SHORTSTRING     reduce using rule 72 (enclosure -> parenth_form .)
    LONGSTRING      reduce using rule 72 (enclosure -> parenth_form .)
    `               reduce using rule 72 (enclosure -> parenth_form .)
    ;               reduce using rule 72 (enclosure -> parenth_form .)
    $end            reduce using rule 72 (enclosure -> parenth_form .)
    }               reduce using rule 72 (enclosure -> parenth_form .)
    ELSE            reduce using rule 72 (enclosure -> parenth_form .)
    DEFAULT         reduce using rule 72 (enclosure -> parenth_form .)
    CASE            reduce using rule 72 (enclosure -> parenth_form .)
    ]               reduce using rule 72 (enclosure -> parenth_form .)
    :               reduce using rule 72 (enclosure -> parenth_form .)
    AUGOP           reduce using rule 72 (enclosure -> parenth_form .)
    =               reduce using rule 72 (enclosure -> parenth_form .)


state 9

    (55) primary_att -> attributeref .

    POWER           reduce using rule 55 (primary_att -> attributeref .)
    [               reduce using rule 55 (primary_att -> attributeref .)
    (               reduce using rule 55 (primary_att -> attributeref .)
    .               reduce using rule 55 (primary_att -> attributeref .)
    REAL            reduce using rule 55 (primary_att -> attributeref .)
    *               reduce using rule 55 (primary_att -> attributeref .)
    /               reduce using rule 55 (primary_att -> attributeref .)
    ^               reduce using rule 55 (primary_att -> attributeref .)
    +               reduce using rule 55 (primary_att -> attributeref .)
    -               reduce using rule 55 (primary_att -> attributeref .)
    <               reduce using rule 55 (primary_att -> attributeref .)
    >               reduce using rule 55 (primary_att -> attributeref .)
    GTE             reduce using rule 55 (primary_att -> attributeref .)
    LTE             reduce using rule 55 (primary_att -> attributeref .)
    NEQ             reduce using rule 55 (primary_att -> attributeref .)
    ISEQUAL         reduce using rule 55 (primary_att -> attributeref .)
    IN              reduce using rule 55 (primary_att -> attributeref .)
    NOT             reduce using rule 55 (primary_att -> attributeref .)
    AND             reduce using rule 55 (primary_att -> attributeref .)
    OR              reduce using rule 55 (primary_att -> attributeref .)
    ,               reduce using rule 55 (primary_att -> attributeref .)
    BREAK           reduce using rule 55 (primary_att -> attributeref .)
    NEXT            reduce using rule 55 (primary_att -> attributeref .)
    {               reduce using rule 55 (primary_att -> attributeref .)
    PRINT           reduce using rule 55 (primary_att -> attributeref .)
    IF              reduce using rule 55 (primary_att -> attributeref .)
    FOR             reduce using rule 55 (primary_att -> attributeref .)
    WHERE           reduce using rule 55 (primary_att -> attributeref .)
    SWITCH          reduce using rule 55 (primary_att -> attributeref .)
    FUNCTION        reduce using rule 55 (primary_att -> attributeref .)
    DO              reduce using rule 55 (primary_att -> attributeref .)
    LOOP            reduce using rule 55 (primary_att -> attributeref .)
    WITH            reduce using rule 55 (primary_att -> attributeref .)
    ID              reduce using rule 55 (primary_att -> attributeref .)
    ITEM_TAG        reduce using rule 55 (primary_att -> attributeref .)
    INTEGER         reduce using rule 55 (primary_att -> attributeref .)
    HEXINT          reduce using rule 55 (primary_att -> attributeref .)
    OCTINT          reduce using rule 55 (primary_att -> attributeref .)
    BININT          reduce using rule 55 (primary_att -> attributeref .)
    IMAGINARY       reduce using rule 55 (primary_att -> attributeref .)
    STRPREFIX       reduce using rule 55 (primary_att -> attributeref .)
    SHORTSTRING     reduce using rule 55 (primary_att -> attributeref .)
    LONGSTRING      reduce using rule 55 (primary_att -> attributeref .)
    `               reduce using rule 55 (primary_att -> attributeref .)
    AUGOP           reduce using rule 55 (primary_att -> attributeref .)
    =               reduce using rule 55 (primary_att -> attributeref .)
    ;               reduce using rule 55 (primary_att -> attributeref .)
    $end            reduce using rule 55 (primary_att -> attributeref .)
    }               reduce using rule 55 (primary_att -> attributeref .)
    ELSE            reduce using rule 55 (primary_att -> attributeref .)
    DEFAULT         reduce using rule 55 (primary_att -> attributeref .)
    CASE            reduce using rule 55 (primary_att -> attributeref .)
    ]               reduce using rule 55 (primary_att -> attributeref .)
    )               reduce using rule 55 (primary_att -> attributeref .)
    :               reduce using rule 55 (primary_att -> attributeref .)


state 10

    (68) stringliteral -> STRPREFIX . SHORTSTRING
    (69) stringliteral -> STRPREFIX . LONGSTRING

    SHORTSTRING     shift and go to state 88
    LONGSTRING      shift and go to state 89


state 11

    (1) final_input -> input .
    (3) input -> input . statement
    (4) statement -> . stmt_list
    (5) statement -> . compound_stmt
    (6) stmt_list -> . simple_stmt
    (7) stmt_list -> . stmt_list ; simple_stmt
    (8) stmt_list -> . stmt_list ; simple_stmt ;
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    $end            reduce using rule 1 (final_input -> input .)
    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    PRINT           shift and go to state 28
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    primary                        shift and go to state 42
    augmented_assignment_stmt      shift and go to state 27
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    subscription                   shift and go to state 53
    parenth_form                   shift and go to state 8
    print_stmt                     shift and go to state 50
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    statement                      shift and go to state 90
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 35
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    simple_stmt                    shift and go to state 14
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    stmt_list                      shift and go to state 62
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    with_stmt                      shift and go to state 24
    atom                           shift and go to state 2

state 12

    (145) loop_stmt -> loop_head . suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 91
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 13

    (129) compound_stmt -> do_stmt .

    BREAK           reduce using rule 129 (compound_stmt -> do_stmt .)
    NEXT            reduce using rule 129 (compound_stmt -> do_stmt .)
    IF              reduce using rule 129 (compound_stmt -> do_stmt .)
    FOR             reduce using rule 129 (compound_stmt -> do_stmt .)
    WHERE           reduce using rule 129 (compound_stmt -> do_stmt .)
    SWITCH          reduce using rule 129 (compound_stmt -> do_stmt .)
    FUNCTION        reduce using rule 129 (compound_stmt -> do_stmt .)
    PRINT           reduce using rule 129 (compound_stmt -> do_stmt .)
    DO              reduce using rule 129 (compound_stmt -> do_stmt .)
    LOOP            reduce using rule 129 (compound_stmt -> do_stmt .)
    WITH            reduce using rule 129 (compound_stmt -> do_stmt .)
    (               reduce using rule 129 (compound_stmt -> do_stmt .)
    [               reduce using rule 129 (compound_stmt -> do_stmt .)
    ID              reduce using rule 129 (compound_stmt -> do_stmt .)
    ITEM_TAG        reduce using rule 129 (compound_stmt -> do_stmt .)
    INTEGER         reduce using rule 129 (compound_stmt -> do_stmt .)
    HEXINT          reduce using rule 129 (compound_stmt -> do_stmt .)
    OCTINT          reduce using rule 129 (compound_stmt -> do_stmt .)
    BININT          reduce using rule 129 (compound_stmt -> do_stmt .)
    REAL            reduce using rule 129 (compound_stmt -> do_stmt .)
    IMAGINARY       reduce using rule 129 (compound_stmt -> do_stmt .)
    STRPREFIX       reduce using rule 129 (compound_stmt -> do_stmt .)
    SHORTSTRING     reduce using rule 129 (compound_stmt -> do_stmt .)
    LONGSTRING      reduce using rule 129 (compound_stmt -> do_stmt .)
    `               reduce using rule 129 (compound_stmt -> do_stmt .)
    $end            reduce using rule 129 (compound_stmt -> do_stmt .)
    }               reduce using rule 129 (compound_stmt -> do_stmt .)
    ELSE            reduce using rule 129 (compound_stmt -> do_stmt .)
    DEFAULT         reduce using rule 129 (compound_stmt -> do_stmt .)
    CASE            reduce using rule 129 (compound_stmt -> do_stmt .)


state 14

    (6) stmt_list -> simple_stmt .

    ;               reduce using rule 6 (stmt_list -> simple_stmt .)
    }               reduce using rule 6 (stmt_list -> simple_stmt .)
    BREAK           reduce using rule 6 (stmt_list -> simple_stmt .)
    NEXT            reduce using rule 6 (stmt_list -> simple_stmt .)
    IF              reduce using rule 6 (stmt_list -> simple_stmt .)
    FOR             reduce using rule 6 (stmt_list -> simple_stmt .)
    WHERE           reduce using rule 6 (stmt_list -> simple_stmt .)
    SWITCH          reduce using rule 6 (stmt_list -> simple_stmt .)
    FUNCTION        reduce using rule 6 (stmt_list -> simple_stmt .)
    PRINT           reduce using rule 6 (stmt_list -> simple_stmt .)
    DO              reduce using rule 6 (stmt_list -> simple_stmt .)
    LOOP            reduce using rule 6 (stmt_list -> simple_stmt .)
    WITH            reduce using rule 6 (stmt_list -> simple_stmt .)
    (               reduce using rule 6 (stmt_list -> simple_stmt .)
    [               reduce using rule 6 (stmt_list -> simple_stmt .)
    ID              reduce using rule 6 (stmt_list -> simple_stmt .)
    ITEM_TAG        reduce using rule 6 (stmt_list -> simple_stmt .)
    INTEGER         reduce using rule 6 (stmt_list -> simple_stmt .)
    HEXINT          reduce using rule 6 (stmt_list -> simple_stmt .)
    OCTINT          reduce using rule 6 (stmt_list -> simple_stmt .)
    BININT          reduce using rule 6 (stmt_list -> simple_stmt .)
    REAL            reduce using rule 6 (stmt_list -> simple_stmt .)
    IMAGINARY       reduce using rule 6 (stmt_list -> simple_stmt .)
    STRPREFIX       reduce using rule 6 (stmt_list -> simple_stmt .)
    SHORTSTRING     reduce using rule 6 (stmt_list -> simple_stmt .)
    LONGSTRING      reduce using rule 6 (stmt_list -> simple_stmt .)
    `               reduce using rule 6 (stmt_list -> simple_stmt .)
    $end            reduce using rule 6 (stmt_list -> simple_stmt .)


state 15

    (130) compound_stmt -> loop_stmt .

    BREAK           reduce using rule 130 (compound_stmt -> loop_stmt .)
    NEXT            reduce using rule 130 (compound_stmt -> loop_stmt .)
    IF              reduce using rule 130 (compound_stmt -> loop_stmt .)
    FOR             reduce using rule 130 (compound_stmt -> loop_stmt .)
    WHERE           reduce using rule 130 (compound_stmt -> loop_stmt .)
    SWITCH          reduce using rule 130 (compound_stmt -> loop_stmt .)
    FUNCTION        reduce using rule 130 (compound_stmt -> loop_stmt .)
    PRINT           reduce using rule 130 (compound_stmt -> loop_stmt .)
    DO              reduce using rule 130 (compound_stmt -> loop_stmt .)
    LOOP            reduce using rule 130 (compound_stmt -> loop_stmt .)
    WITH            reduce using rule 130 (compound_stmt -> loop_stmt .)
    (               reduce using rule 130 (compound_stmt -> loop_stmt .)
    [               reduce using rule 130 (compound_stmt -> loop_stmt .)
    ID              reduce using rule 130 (compound_stmt -> loop_stmt .)
    ITEM_TAG        reduce using rule 130 (compound_stmt -> loop_stmt .)
    INTEGER         reduce using rule 130 (compound_stmt -> loop_stmt .)
    HEXINT          reduce using rule 130 (compound_stmt -> loop_stmt .)
    OCTINT          reduce using rule 130 (compound_stmt -> loop_stmt .)
    BININT          reduce using rule 130 (compound_stmt -> loop_stmt .)
    REAL            reduce using rule 130 (compound_stmt -> loop_stmt .)
    IMAGINARY       reduce using rule 130 (compound_stmt -> loop_stmt .)
    STRPREFIX       reduce using rule 130 (compound_stmt -> loop_stmt .)
    SHORTSTRING     reduce using rule 130 (compound_stmt -> loop_stmt .)
    LONGSTRING      reduce using rule 130 (compound_stmt -> loop_stmt .)
    `               reduce using rule 130 (compound_stmt -> loop_stmt .)
    $end            reduce using rule 130 (compound_stmt -> loop_stmt .)
    }               reduce using rule 130 (compound_stmt -> loop_stmt .)
    ELSE            reduce using rule 130 (compound_stmt -> loop_stmt .)
    DEFAULT         reduce using rule 130 (compound_stmt -> loop_stmt .)
    CASE            reduce using rule 130 (compound_stmt -> loop_stmt .)


state 16

    (71) stringliteral -> LONGSTRING .

    POWER           reduce using rule 71 (stringliteral -> LONGSTRING .)
    [               reduce using rule 71 (stringliteral -> LONGSTRING .)
    (               reduce using rule 71 (stringliteral -> LONGSTRING .)
    .               reduce using rule 71 (stringliteral -> LONGSTRING .)
    REAL            reduce using rule 71 (stringliteral -> LONGSTRING .)
    *               reduce using rule 71 (stringliteral -> LONGSTRING .)
    /               reduce using rule 71 (stringliteral -> LONGSTRING .)
    ^               reduce using rule 71 (stringliteral -> LONGSTRING .)
    +               reduce using rule 71 (stringliteral -> LONGSTRING .)
    -               reduce using rule 71 (stringliteral -> LONGSTRING .)
    <               reduce using rule 71 (stringliteral -> LONGSTRING .)
    >               reduce using rule 71 (stringliteral -> LONGSTRING .)
    GTE             reduce using rule 71 (stringliteral -> LONGSTRING .)
    LTE             reduce using rule 71 (stringliteral -> LONGSTRING .)
    NEQ             reduce using rule 71 (stringliteral -> LONGSTRING .)
    ISEQUAL         reduce using rule 71 (stringliteral -> LONGSTRING .)
    IN              reduce using rule 71 (stringliteral -> LONGSTRING .)
    NOT             reduce using rule 71 (stringliteral -> LONGSTRING .)
    AND             reduce using rule 71 (stringliteral -> LONGSTRING .)
    OR              reduce using rule 71 (stringliteral -> LONGSTRING .)
    )               reduce using rule 71 (stringliteral -> LONGSTRING .)
    ,               reduce using rule 71 (stringliteral -> LONGSTRING .)
    BREAK           reduce using rule 71 (stringliteral -> LONGSTRING .)
    NEXT            reduce using rule 71 (stringliteral -> LONGSTRING .)
    {               reduce using rule 71 (stringliteral -> LONGSTRING .)
    PRINT           reduce using rule 71 (stringliteral -> LONGSTRING .)
    IF              reduce using rule 71 (stringliteral -> LONGSTRING .)
    FOR             reduce using rule 71 (stringliteral -> LONGSTRING .)
    WHERE           reduce using rule 71 (stringliteral -> LONGSTRING .)
    SWITCH          reduce using rule 71 (stringliteral -> LONGSTRING .)
    FUNCTION        reduce using rule 71 (stringliteral -> LONGSTRING .)
    DO              reduce using rule 71 (stringliteral -> LONGSTRING .)
    LOOP            reduce using rule 71 (stringliteral -> LONGSTRING .)
    WITH            reduce using rule 71 (stringliteral -> LONGSTRING .)
    ID              reduce using rule 71 (stringliteral -> LONGSTRING .)
    ITEM_TAG        reduce using rule 71 (stringliteral -> LONGSTRING .)
    INTEGER         reduce using rule 71 (stringliteral -> LONGSTRING .)
    HEXINT          reduce using rule 71 (stringliteral -> LONGSTRING .)
    OCTINT          reduce using rule 71 (stringliteral -> LONGSTRING .)
    BININT          reduce using rule 71 (stringliteral -> LONGSTRING .)
    IMAGINARY       reduce using rule 71 (stringliteral -> LONGSTRING .)
    STRPREFIX       reduce using rule 71 (stringliteral -> LONGSTRING .)
    SHORTSTRING     reduce using rule 71 (stringliteral -> LONGSTRING .)
    LONGSTRING      reduce using rule 71 (stringliteral -> LONGSTRING .)
    `               reduce using rule 71 (stringliteral -> LONGSTRING .)
    ;               reduce using rule 71 (stringliteral -> LONGSTRING .)
    $end            reduce using rule 71 (stringliteral -> LONGSTRING .)
    }               reduce using rule 71 (stringliteral -> LONGSTRING .)
    ELSE            reduce using rule 71 (stringliteral -> LONGSTRING .)
    DEFAULT         reduce using rule 71 (stringliteral -> LONGSTRING .)
    CASE            reduce using rule 71 (stringliteral -> LONGSTRING .)
    ]               reduce using rule 71 (stringliteral -> LONGSTRING .)
    :               reduce using rule 71 (stringliteral -> LONGSTRING .)
    AUGOP           reduce using rule 71 (stringliteral -> LONGSTRING .)
    =               reduce using rule 71 (stringliteral -> LONGSTRING .)


state 17

    (53) primary -> slicing .

    (               reduce using rule 53 (primary -> slicing .)
    [               reduce using rule 53 (primary -> slicing .)
    .               reduce using rule 53 (primary -> slicing .)
    REAL            reduce using rule 53 (primary -> slicing .)
    AUGOP           reduce using rule 53 (primary -> slicing .)
    =               reduce using rule 53 (primary -> slicing .)
    ,               reduce using rule 53 (primary -> slicing .)
    POWER           reduce using rule 53 (primary -> slicing .)
    *               reduce using rule 53 (primary -> slicing .)
    /               reduce using rule 53 (primary -> slicing .)
    ^               reduce using rule 53 (primary -> slicing .)
    +               reduce using rule 53 (primary -> slicing .)
    -               reduce using rule 53 (primary -> slicing .)
    <               reduce using rule 53 (primary -> slicing .)
    >               reduce using rule 53 (primary -> slicing .)
    GTE             reduce using rule 53 (primary -> slicing .)
    LTE             reduce using rule 53 (primary -> slicing .)
    NEQ             reduce using rule 53 (primary -> slicing .)
    ISEQUAL         reduce using rule 53 (primary -> slicing .)
    IN              reduce using rule 53 (primary -> slicing .)
    NOT             reduce using rule 53 (primary -> slicing .)
    AND             reduce using rule 53 (primary -> slicing .)
    OR              reduce using rule 53 (primary -> slicing .)
    ;               reduce using rule 53 (primary -> slicing .)
    BREAK           reduce using rule 53 (primary -> slicing .)
    NEXT            reduce using rule 53 (primary -> slicing .)
    IF              reduce using rule 53 (primary -> slicing .)
    FOR             reduce using rule 53 (primary -> slicing .)
    WHERE           reduce using rule 53 (primary -> slicing .)
    SWITCH          reduce using rule 53 (primary -> slicing .)
    FUNCTION        reduce using rule 53 (primary -> slicing .)
    PRINT           reduce using rule 53 (primary -> slicing .)
    DO              reduce using rule 53 (primary -> slicing .)
    LOOP            reduce using rule 53 (primary -> slicing .)
    WITH            reduce using rule 53 (primary -> slicing .)
    ID              reduce using rule 53 (primary -> slicing .)
    ITEM_TAG        reduce using rule 53 (primary -> slicing .)
    INTEGER         reduce using rule 53 (primary -> slicing .)
    HEXINT          reduce using rule 53 (primary -> slicing .)
    OCTINT          reduce using rule 53 (primary -> slicing .)
    BININT          reduce using rule 53 (primary -> slicing .)
    IMAGINARY       reduce using rule 53 (primary -> slicing .)
    STRPREFIX       reduce using rule 53 (primary -> slicing .)
    SHORTSTRING     reduce using rule 53 (primary -> slicing .)
    LONGSTRING      reduce using rule 53 (primary -> slicing .)
    `               reduce using rule 53 (primary -> slicing .)
    $end            reduce using rule 53 (primary -> slicing .)
    }               reduce using rule 53 (primary -> slicing .)
    ELSE            reduce using rule 53 (primary -> slicing .)
    DEFAULT         reduce using rule 53 (primary -> slicing .)
    CASE            reduce using rule 53 (primary -> slicing .)
    )               reduce using rule 53 (primary -> slicing .)
    :               reduce using rule 53 (primary -> slicing .)
    ]               reduce using rule 53 (primary -> slicing .)
    {               reduce using rule 53 (primary -> slicing .)


state 18

    (128) compound_stmt -> for_stmt .

    BREAK           reduce using rule 128 (compound_stmt -> for_stmt .)
    NEXT            reduce using rule 128 (compound_stmt -> for_stmt .)
    IF              reduce using rule 128 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 128 (compound_stmt -> for_stmt .)
    WHERE           reduce using rule 128 (compound_stmt -> for_stmt .)
    SWITCH          reduce using rule 128 (compound_stmt -> for_stmt .)
    FUNCTION        reduce using rule 128 (compound_stmt -> for_stmt .)
    PRINT           reduce using rule 128 (compound_stmt -> for_stmt .)
    DO              reduce using rule 128 (compound_stmt -> for_stmt .)
    LOOP            reduce using rule 128 (compound_stmt -> for_stmt .)
    WITH            reduce using rule 128 (compound_stmt -> for_stmt .)
    (               reduce using rule 128 (compound_stmt -> for_stmt .)
    [               reduce using rule 128 (compound_stmt -> for_stmt .)
    ID              reduce using rule 128 (compound_stmt -> for_stmt .)
    ITEM_TAG        reduce using rule 128 (compound_stmt -> for_stmt .)
    INTEGER         reduce using rule 128 (compound_stmt -> for_stmt .)
    HEXINT          reduce using rule 128 (compound_stmt -> for_stmt .)
    OCTINT          reduce using rule 128 (compound_stmt -> for_stmt .)
    BININT          reduce using rule 128 (compound_stmt -> for_stmt .)
    REAL            reduce using rule 128 (compound_stmt -> for_stmt .)
    IMAGINARY       reduce using rule 128 (compound_stmt -> for_stmt .)
    STRPREFIX       reduce using rule 128 (compound_stmt -> for_stmt .)
    SHORTSTRING     reduce using rule 128 (compound_stmt -> for_stmt .)
    LONGSTRING      reduce using rule 128 (compound_stmt -> for_stmt .)
    `               reduce using rule 128 (compound_stmt -> for_stmt .)
    $end            reduce using rule 128 (compound_stmt -> for_stmt .)
    }               reduce using rule 128 (compound_stmt -> for_stmt .)
    ELSE            reduce using rule 128 (compound_stmt -> for_stmt .)
    DEFAULT         reduce using rule 128 (compound_stmt -> for_stmt .)
    CASE            reduce using rule 128 (compound_stmt -> for_stmt .)


state 19

    (154) where_stmt -> WHERE . expression suite ELSE suite
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 95

state 20

    (77) string_conversion -> ` . expression_list `
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    expression_list                shift and go to state 96
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 87

state 21

    (127) compound_stmt -> if_stmt .
    (136) if_stmt -> if_stmt . ELSE suite

  ! shift/reduce conflict for ELSE resolved as shift
    BREAK           reduce using rule 127 (compound_stmt -> if_stmt .)
    NEXT            reduce using rule 127 (compound_stmt -> if_stmt .)
    IF              reduce using rule 127 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 127 (compound_stmt -> if_stmt .)
    WHERE           reduce using rule 127 (compound_stmt -> if_stmt .)
    SWITCH          reduce using rule 127 (compound_stmt -> if_stmt .)
    FUNCTION        reduce using rule 127 (compound_stmt -> if_stmt .)
    PRINT           reduce using rule 127 (compound_stmt -> if_stmt .)
    DO              reduce using rule 127 (compound_stmt -> if_stmt .)
    LOOP            reduce using rule 127 (compound_stmt -> if_stmt .)
    WITH            reduce using rule 127 (compound_stmt -> if_stmt .)
    (               reduce using rule 127 (compound_stmt -> if_stmt .)
    [               reduce using rule 127 (compound_stmt -> if_stmt .)
    ID              reduce using rule 127 (compound_stmt -> if_stmt .)
    ITEM_TAG        reduce using rule 127 (compound_stmt -> if_stmt .)
    INTEGER         reduce using rule 127 (compound_stmt -> if_stmt .)
    HEXINT          reduce using rule 127 (compound_stmt -> if_stmt .)
    OCTINT          reduce using rule 127 (compound_stmt -> if_stmt .)
    BININT          reduce using rule 127 (compound_stmt -> if_stmt .)
    REAL            reduce using rule 127 (compound_stmt -> if_stmt .)
    IMAGINARY       reduce using rule 127 (compound_stmt -> if_stmt .)
    STRPREFIX       reduce using rule 127 (compound_stmt -> if_stmt .)
    SHORTSTRING     reduce using rule 127 (compound_stmt -> if_stmt .)
    LONGSTRING      reduce using rule 127 (compound_stmt -> if_stmt .)
    `               reduce using rule 127 (compound_stmt -> if_stmt .)
    $end            reduce using rule 127 (compound_stmt -> if_stmt .)
    }               reduce using rule 127 (compound_stmt -> if_stmt .)
    DEFAULT         reduce using rule 127 (compound_stmt -> if_stmt .)
    CASE            reduce using rule 127 (compound_stmt -> if_stmt .)
    ELSE            shift and go to state 97

  ! ELSE            [ reduce using rule 127 (compound_stmt -> if_stmt .) ]


state 22

    (74) enclosure -> list_display .

    POWER           reduce using rule 74 (enclosure -> list_display .)
    [               reduce using rule 74 (enclosure -> list_display .)
    (               reduce using rule 74 (enclosure -> list_display .)
    .               reduce using rule 74 (enclosure -> list_display .)
    REAL            reduce using rule 74 (enclosure -> list_display .)
    *               reduce using rule 74 (enclosure -> list_display .)
    /               reduce using rule 74 (enclosure -> list_display .)
    ^               reduce using rule 74 (enclosure -> list_display .)
    +               reduce using rule 74 (enclosure -> list_display .)
    -               reduce using rule 74 (enclosure -> list_display .)
    <               reduce using rule 74 (enclosure -> list_display .)
    >               reduce using rule 74 (enclosure -> list_display .)
    GTE             reduce using rule 74 (enclosure -> list_display .)
    LTE             reduce using rule 74 (enclosure -> list_display .)
    NEQ             reduce using rule 74 (enclosure -> list_display .)
    ISEQUAL         reduce using rule 74 (enclosure -> list_display .)
    IN              reduce using rule 74 (enclosure -> list_display .)
    NOT             reduce using rule 74 (enclosure -> list_display .)
    AND             reduce using rule 74 (enclosure -> list_display .)
    OR              reduce using rule 74 (enclosure -> list_display .)
    )               reduce using rule 74 (enclosure -> list_display .)
    ,               reduce using rule 74 (enclosure -> list_display .)
    BREAK           reduce using rule 74 (enclosure -> list_display .)
    NEXT            reduce using rule 74 (enclosure -> list_display .)
    {               reduce using rule 74 (enclosure -> list_display .)
    PRINT           reduce using rule 74 (enclosure -> list_display .)
    IF              reduce using rule 74 (enclosure -> list_display .)
    FOR             reduce using rule 74 (enclosure -> list_display .)
    WHERE           reduce using rule 74 (enclosure -> list_display .)
    SWITCH          reduce using rule 74 (enclosure -> list_display .)
    FUNCTION        reduce using rule 74 (enclosure -> list_display .)
    DO              reduce using rule 74 (enclosure -> list_display .)
    LOOP            reduce using rule 74 (enclosure -> list_display .)
    WITH            reduce using rule 74 (enclosure -> list_display .)
    ID              reduce using rule 74 (enclosure -> list_display .)
    ITEM_TAG        reduce using rule 74 (enclosure -> list_display .)
    INTEGER         reduce using rule 74 (enclosure -> list_display .)
    HEXINT          reduce using rule 74 (enclosure -> list_display .)
    OCTINT          reduce using rule 74 (enclosure -> list_display .)
    BININT          reduce using rule 74 (enclosure -> list_display .)
    IMAGINARY       reduce using rule 74 (enclosure -> list_display .)
    STRPREFIX       reduce using rule 74 (enclosure -> list_display .)
    SHORTSTRING     reduce using rule 74 (enclosure -> list_display .)
    LONGSTRING      reduce using rule 74 (enclosure -> list_display .)
    `               reduce using rule 74 (enclosure -> list_display .)
    ;               reduce using rule 74 (enclosure -> list_display .)
    $end            reduce using rule 74 (enclosure -> list_display .)
    }               reduce using rule 74 (enclosure -> list_display .)
    ELSE            reduce using rule 74 (enclosure -> list_display .)
    DEFAULT         reduce using rule 74 (enclosure -> list_display .)
    CASE            reduce using rule 74 (enclosure -> list_display .)
    ]               reduce using rule 74 (enclosure -> list_display .)
    :               reduce using rule 74 (enclosure -> list_display .)
    AUGOP           reduce using rule 74 (enclosure -> list_display .)
    =               reduce using rule 74 (enclosure -> list_display .)


state 23

    (61) literal -> stringliteral .

    POWER           reduce using rule 61 (literal -> stringliteral .)
    [               reduce using rule 61 (literal -> stringliteral .)
    (               reduce using rule 61 (literal -> stringliteral .)
    .               reduce using rule 61 (literal -> stringliteral .)
    REAL            reduce using rule 61 (literal -> stringliteral .)
    *               reduce using rule 61 (literal -> stringliteral .)
    /               reduce using rule 61 (literal -> stringliteral .)
    ^               reduce using rule 61 (literal -> stringliteral .)
    +               reduce using rule 61 (literal -> stringliteral .)
    -               reduce using rule 61 (literal -> stringliteral .)
    <               reduce using rule 61 (literal -> stringliteral .)
    >               reduce using rule 61 (literal -> stringliteral .)
    GTE             reduce using rule 61 (literal -> stringliteral .)
    LTE             reduce using rule 61 (literal -> stringliteral .)
    NEQ             reduce using rule 61 (literal -> stringliteral .)
    ISEQUAL         reduce using rule 61 (literal -> stringliteral .)
    IN              reduce using rule 61 (literal -> stringliteral .)
    NOT             reduce using rule 61 (literal -> stringliteral .)
    AND             reduce using rule 61 (literal -> stringliteral .)
    OR              reduce using rule 61 (literal -> stringliteral .)
    ]               reduce using rule 61 (literal -> stringliteral .)
    :               reduce using rule 61 (literal -> stringliteral .)
    ,               reduce using rule 61 (literal -> stringliteral .)
    AUGOP           reduce using rule 61 (literal -> stringliteral .)
    =               reduce using rule 61 (literal -> stringliteral .)
    )               reduce using rule 61 (literal -> stringliteral .)
    BREAK           reduce using rule 61 (literal -> stringliteral .)
    NEXT            reduce using rule 61 (literal -> stringliteral .)
    {               reduce using rule 61 (literal -> stringliteral .)
    PRINT           reduce using rule 61 (literal -> stringliteral .)
    IF              reduce using rule 61 (literal -> stringliteral .)
    FOR             reduce using rule 61 (literal -> stringliteral .)
    WHERE           reduce using rule 61 (literal -> stringliteral .)
    SWITCH          reduce using rule 61 (literal -> stringliteral .)
    FUNCTION        reduce using rule 61 (literal -> stringliteral .)
    DO              reduce using rule 61 (literal -> stringliteral .)
    LOOP            reduce using rule 61 (literal -> stringliteral .)
    WITH            reduce using rule 61 (literal -> stringliteral .)
    ID              reduce using rule 61 (literal -> stringliteral .)
    ITEM_TAG        reduce using rule 61 (literal -> stringliteral .)
    INTEGER         reduce using rule 61 (literal -> stringliteral .)
    HEXINT          reduce using rule 61 (literal -> stringliteral .)
    OCTINT          reduce using rule 61 (literal -> stringliteral .)
    BININT          reduce using rule 61 (literal -> stringliteral .)
    IMAGINARY       reduce using rule 61 (literal -> stringliteral .)
    STRPREFIX       reduce using rule 61 (literal -> stringliteral .)
    SHORTSTRING     reduce using rule 61 (literal -> stringliteral .)
    LONGSTRING      reduce using rule 61 (literal -> stringliteral .)
    `               reduce using rule 61 (literal -> stringliteral .)
    ;               reduce using rule 61 (literal -> stringliteral .)
    $end            reduce using rule 61 (literal -> stringliteral .)
    }               reduce using rule 61 (literal -> stringliteral .)
    ELSE            reduce using rule 61 (literal -> stringliteral .)
    DEFAULT         reduce using rule 61 (literal -> stringliteral .)
    CASE            reduce using rule 61 (literal -> stringliteral .)


state 24

    (131) compound_stmt -> with_stmt .

    BREAK           reduce using rule 131 (compound_stmt -> with_stmt .)
    NEXT            reduce using rule 131 (compound_stmt -> with_stmt .)
    IF              reduce using rule 131 (compound_stmt -> with_stmt .)
    FOR             reduce using rule 131 (compound_stmt -> with_stmt .)
    WHERE           reduce using rule 131 (compound_stmt -> with_stmt .)
    SWITCH          reduce using rule 131 (compound_stmt -> with_stmt .)
    FUNCTION        reduce using rule 131 (compound_stmt -> with_stmt .)
    PRINT           reduce using rule 131 (compound_stmt -> with_stmt .)
    DO              reduce using rule 131 (compound_stmt -> with_stmt .)
    LOOP            reduce using rule 131 (compound_stmt -> with_stmt .)
    WITH            reduce using rule 131 (compound_stmt -> with_stmt .)
    (               reduce using rule 131 (compound_stmt -> with_stmt .)
    [               reduce using rule 131 (compound_stmt -> with_stmt .)
    ID              reduce using rule 131 (compound_stmt -> with_stmt .)
    ITEM_TAG        reduce using rule 131 (compound_stmt -> with_stmt .)
    INTEGER         reduce using rule 131 (compound_stmt -> with_stmt .)
    HEXINT          reduce using rule 131 (compound_stmt -> with_stmt .)
    OCTINT          reduce using rule 131 (compound_stmt -> with_stmt .)
    BININT          reduce using rule 131 (compound_stmt -> with_stmt .)
    REAL            reduce using rule 131 (compound_stmt -> with_stmt .)
    IMAGINARY       reduce using rule 131 (compound_stmt -> with_stmt .)
    STRPREFIX       reduce using rule 131 (compound_stmt -> with_stmt .)
    SHORTSTRING     reduce using rule 131 (compound_stmt -> with_stmt .)
    LONGSTRING      reduce using rule 131 (compound_stmt -> with_stmt .)
    `               reduce using rule 131 (compound_stmt -> with_stmt .)
    $end            reduce using rule 131 (compound_stmt -> with_stmt .)
    }               reduce using rule 131 (compound_stmt -> with_stmt .)
    ELSE            reduce using rule 131 (compound_stmt -> with_stmt .)
    DEFAULT         reduce using rule 131 (compound_stmt -> with_stmt .)
    CASE            reduce using rule 131 (compound_stmt -> with_stmt .)


state 25

    (146) loop_head -> LOOP . ID AS ID
    (147) loop_head -> LOOP . ID AS ID : ID
    (148) loop_head -> LOOP . ID AS ID : ID comp_operator ID

    ID              shift and go to state 98


state 26

    (11) simple_stmt -> fancy_drel_assignment_stmt .

    ;               reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    BREAK           reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    NEXT            reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    IF              reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    FOR             reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    WHERE           reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    SWITCH          reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    FUNCTION        reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    PRINT           reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    DO              reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    LOOP            reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    WITH            reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    (               reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    [               reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    ID              reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    ITEM_TAG        reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    INTEGER         reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    HEXINT          reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    OCTINT          reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    BININT          reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    REAL            reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    IMAGINARY       reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    STRPREFIX       reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    SHORTSTRING     reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    LONGSTRING      reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    `               reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    $end            reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    }               reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    ELSE            reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    DEFAULT         reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)
    CASE            reduce using rule 11 (simple_stmt -> fancy_drel_assignment_stmt .)


state 27

    (10) simple_stmt -> augmented_assignment_stmt .

    ;               reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    BREAK           reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    NEXT            reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    IF              reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    FOR             reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    WHERE           reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    SWITCH          reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    FUNCTION        reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    PRINT           reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    DO              reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    LOOP            reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    WITH            reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    (               reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    [               reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    ID              reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    ITEM_TAG        reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    INTEGER         reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    HEXINT          reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    OCTINT          reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    BININT          reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    REAL            reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    IMAGINARY       reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    STRPREFIX       reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    SHORTSTRING     reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    LONGSTRING      reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    `               reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    $end            reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    }               reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    ELSE            reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    DEFAULT         reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)
    CASE            reduce using rule 10 (simple_stmt -> augmented_assignment_stmt .)


state 28

    (15) print_stmt -> PRINT . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 99

state 29

    (59) atom -> enclosure .

    [               reduce using rule 59 (atom -> enclosure .)
    (               reduce using rule 59 (atom -> enclosure .)
    POWER           reduce using rule 59 (atom -> enclosure .)
    .               reduce using rule 59 (atom -> enclosure .)
    REAL            reduce using rule 59 (atom -> enclosure .)
    )               reduce using rule 59 (atom -> enclosure .)
    ,               reduce using rule 59 (atom -> enclosure .)
    *               reduce using rule 59 (atom -> enclosure .)
    /               reduce using rule 59 (atom -> enclosure .)
    ^               reduce using rule 59 (atom -> enclosure .)
    +               reduce using rule 59 (atom -> enclosure .)
    -               reduce using rule 59 (atom -> enclosure .)
    <               reduce using rule 59 (atom -> enclosure .)
    >               reduce using rule 59 (atom -> enclosure .)
    GTE             reduce using rule 59 (atom -> enclosure .)
    LTE             reduce using rule 59 (atom -> enclosure .)
    NEQ             reduce using rule 59 (atom -> enclosure .)
    ISEQUAL         reduce using rule 59 (atom -> enclosure .)
    IN              reduce using rule 59 (atom -> enclosure .)
    NOT             reduce using rule 59 (atom -> enclosure .)
    AND             reduce using rule 59 (atom -> enclosure .)
    OR              reduce using rule 59 (atom -> enclosure .)
    BREAK           reduce using rule 59 (atom -> enclosure .)
    NEXT            reduce using rule 59 (atom -> enclosure .)
    {               reduce using rule 59 (atom -> enclosure .)
    PRINT           reduce using rule 59 (atom -> enclosure .)
    IF              reduce using rule 59 (atom -> enclosure .)
    FOR             reduce using rule 59 (atom -> enclosure .)
    WHERE           reduce using rule 59 (atom -> enclosure .)
    SWITCH          reduce using rule 59 (atom -> enclosure .)
    FUNCTION        reduce using rule 59 (atom -> enclosure .)
    DO              reduce using rule 59 (atom -> enclosure .)
    LOOP            reduce using rule 59 (atom -> enclosure .)
    WITH            reduce using rule 59 (atom -> enclosure .)
    ID              reduce using rule 59 (atom -> enclosure .)
    ITEM_TAG        reduce using rule 59 (atom -> enclosure .)
    INTEGER         reduce using rule 59 (atom -> enclosure .)
    HEXINT          reduce using rule 59 (atom -> enclosure .)
    OCTINT          reduce using rule 59 (atom -> enclosure .)
    BININT          reduce using rule 59 (atom -> enclosure .)
    IMAGINARY       reduce using rule 59 (atom -> enclosure .)
    STRPREFIX       reduce using rule 59 (atom -> enclosure .)
    SHORTSTRING     reduce using rule 59 (atom -> enclosure .)
    LONGSTRING      reduce using rule 59 (atom -> enclosure .)
    `               reduce using rule 59 (atom -> enclosure .)
    ]               reduce using rule 59 (atom -> enclosure .)
    ;               reduce using rule 59 (atom -> enclosure .)
    $end            reduce using rule 59 (atom -> enclosure .)
    }               reduce using rule 59 (atom -> enclosure .)
    ELSE            reduce using rule 59 (atom -> enclosure .)
    DEFAULT         reduce using rule 59 (atom -> enclosure .)
    CASE            reduce using rule 59 (atom -> enclosure .)
    AUGOP           reduce using rule 59 (atom -> enclosure .)
    =               reduce using rule 59 (atom -> enclosure .)
    :               reduce using rule 59 (atom -> enclosure .)


state 30

    (144) for_stmt -> FOR . target_list IN expression_list suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    primary_att                    shift and go to state 41
    primary                        shift and go to state 100
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    target_list                    shift and go to state 101
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    target                         shift and go to state 84
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 31

    (70) stringliteral -> SHORTSTRING .

    POWER           reduce using rule 70 (stringliteral -> SHORTSTRING .)
    [               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    (               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    .               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    REAL            reduce using rule 70 (stringliteral -> SHORTSTRING .)
    *               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    /               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ^               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    +               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    -               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    <               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    >               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    GTE             reduce using rule 70 (stringliteral -> SHORTSTRING .)
    LTE             reduce using rule 70 (stringliteral -> SHORTSTRING .)
    NEQ             reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ISEQUAL         reduce using rule 70 (stringliteral -> SHORTSTRING .)
    IN              reduce using rule 70 (stringliteral -> SHORTSTRING .)
    NOT             reduce using rule 70 (stringliteral -> SHORTSTRING .)
    AND             reduce using rule 70 (stringliteral -> SHORTSTRING .)
    OR              reduce using rule 70 (stringliteral -> SHORTSTRING .)
    )               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ,               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    BREAK           reduce using rule 70 (stringliteral -> SHORTSTRING .)
    NEXT            reduce using rule 70 (stringliteral -> SHORTSTRING .)
    {               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    PRINT           reduce using rule 70 (stringliteral -> SHORTSTRING .)
    IF              reduce using rule 70 (stringliteral -> SHORTSTRING .)
    FOR             reduce using rule 70 (stringliteral -> SHORTSTRING .)
    WHERE           reduce using rule 70 (stringliteral -> SHORTSTRING .)
    SWITCH          reduce using rule 70 (stringliteral -> SHORTSTRING .)
    FUNCTION        reduce using rule 70 (stringliteral -> SHORTSTRING .)
    DO              reduce using rule 70 (stringliteral -> SHORTSTRING .)
    LOOP            reduce using rule 70 (stringliteral -> SHORTSTRING .)
    WITH            reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ID              reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ITEM_TAG        reduce using rule 70 (stringliteral -> SHORTSTRING .)
    INTEGER         reduce using rule 70 (stringliteral -> SHORTSTRING .)
    HEXINT          reduce using rule 70 (stringliteral -> SHORTSTRING .)
    OCTINT          reduce using rule 70 (stringliteral -> SHORTSTRING .)
    BININT          reduce using rule 70 (stringliteral -> SHORTSTRING .)
    IMAGINARY       reduce using rule 70 (stringliteral -> SHORTSTRING .)
    STRPREFIX       reduce using rule 70 (stringliteral -> SHORTSTRING .)
    SHORTSTRING     reduce using rule 70 (stringliteral -> SHORTSTRING .)
    LONGSTRING      reduce using rule 70 (stringliteral -> SHORTSTRING .)
    `               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ;               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    $end            reduce using rule 70 (stringliteral -> SHORTSTRING .)
    }               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ELSE            reduce using rule 70 (stringliteral -> SHORTSTRING .)
    DEFAULT         reduce using rule 70 (stringliteral -> SHORTSTRING .)
    CASE            reduce using rule 70 (stringliteral -> SHORTSTRING .)
    ]               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    :               reduce using rule 70 (stringliteral -> SHORTSTRING .)
    AUGOP           reduce using rule 70 (stringliteral -> SHORTSTRING .)
    =               reduce using rule 70 (stringliteral -> SHORTSTRING .)


state 32

    (9) simple_stmt -> assignment_stmt .

    ;               reduce using rule 9 (simple_stmt -> assignment_stmt .)
    BREAK           reduce using rule 9 (simple_stmt -> assignment_stmt .)
    NEXT            reduce using rule 9 (simple_stmt -> assignment_stmt .)
    IF              reduce using rule 9 (simple_stmt -> assignment_stmt .)
    FOR             reduce using rule 9 (simple_stmt -> assignment_stmt .)
    WHERE           reduce using rule 9 (simple_stmt -> assignment_stmt .)
    SWITCH          reduce using rule 9 (simple_stmt -> assignment_stmt .)
    FUNCTION        reduce using rule 9 (simple_stmt -> assignment_stmt .)
    PRINT           reduce using rule 9 (simple_stmt -> assignment_stmt .)
    DO              reduce using rule 9 (simple_stmt -> assignment_stmt .)
    LOOP            reduce using rule 9 (simple_stmt -> assignment_stmt .)
    WITH            reduce using rule 9 (simple_stmt -> assignment_stmt .)
    (               reduce using rule 9 (simple_stmt -> assignment_stmt .)
    [               reduce using rule 9 (simple_stmt -> assignment_stmt .)
    ID              reduce using rule 9 (simple_stmt -> assignment_stmt .)
    ITEM_TAG        reduce using rule 9 (simple_stmt -> assignment_stmt .)
    INTEGER         reduce using rule 9 (simple_stmt -> assignment_stmt .)
    HEXINT          reduce using rule 9 (simple_stmt -> assignment_stmt .)
    OCTINT          reduce using rule 9 (simple_stmt -> assignment_stmt .)
    BININT          reduce using rule 9 (simple_stmt -> assignment_stmt .)
    REAL            reduce using rule 9 (simple_stmt -> assignment_stmt .)
    IMAGINARY       reduce using rule 9 (simple_stmt -> assignment_stmt .)
    STRPREFIX       reduce using rule 9 (simple_stmt -> assignment_stmt .)
    SHORTSTRING     reduce using rule 9 (simple_stmt -> assignment_stmt .)
    LONGSTRING      reduce using rule 9 (simple_stmt -> assignment_stmt .)
    `               reduce using rule 9 (simple_stmt -> assignment_stmt .)
    $end            reduce using rule 9 (simple_stmt -> assignment_stmt .)
    }               reduce using rule 9 (simple_stmt -> assignment_stmt .)
    ELSE            reduce using rule 9 (simple_stmt -> assignment_stmt .)
    DEFAULT         reduce using rule 9 (simple_stmt -> assignment_stmt .)
    CASE            reduce using rule 9 (simple_stmt -> assignment_stmt .)


state 33

    (64) literal -> OCTINT .

    POWER           reduce using rule 64 (literal -> OCTINT .)
    [               reduce using rule 64 (literal -> OCTINT .)
    (               reduce using rule 64 (literal -> OCTINT .)
    .               reduce using rule 64 (literal -> OCTINT .)
    REAL            reduce using rule 64 (literal -> OCTINT .)
    *               reduce using rule 64 (literal -> OCTINT .)
    /               reduce using rule 64 (literal -> OCTINT .)
    ^               reduce using rule 64 (literal -> OCTINT .)
    +               reduce using rule 64 (literal -> OCTINT .)
    -               reduce using rule 64 (literal -> OCTINT .)
    <               reduce using rule 64 (literal -> OCTINT .)
    >               reduce using rule 64 (literal -> OCTINT .)
    GTE             reduce using rule 64 (literal -> OCTINT .)
    LTE             reduce using rule 64 (literal -> OCTINT .)
    NEQ             reduce using rule 64 (literal -> OCTINT .)
    ISEQUAL         reduce using rule 64 (literal -> OCTINT .)
    IN              reduce using rule 64 (literal -> OCTINT .)
    NOT             reduce using rule 64 (literal -> OCTINT .)
    AND             reduce using rule 64 (literal -> OCTINT .)
    OR              reduce using rule 64 (literal -> OCTINT .)
    ]               reduce using rule 64 (literal -> OCTINT .)
    :               reduce using rule 64 (literal -> OCTINT .)
    ,               reduce using rule 64 (literal -> OCTINT .)
    AUGOP           reduce using rule 64 (literal -> OCTINT .)
    =               reduce using rule 64 (literal -> OCTINT .)
    )               reduce using rule 64 (literal -> OCTINT .)
    BREAK           reduce using rule 64 (literal -> OCTINT .)
    NEXT            reduce using rule 64 (literal -> OCTINT .)
    {               reduce using rule 64 (literal -> OCTINT .)
    PRINT           reduce using rule 64 (literal -> OCTINT .)
    IF              reduce using rule 64 (literal -> OCTINT .)
    FOR             reduce using rule 64 (literal -> OCTINT .)
    WHERE           reduce using rule 64 (literal -> OCTINT .)
    SWITCH          reduce using rule 64 (literal -> OCTINT .)
    FUNCTION        reduce using rule 64 (literal -> OCTINT .)
    DO              reduce using rule 64 (literal -> OCTINT .)
    LOOP            reduce using rule 64 (literal -> OCTINT .)
    WITH            reduce using rule 64 (literal -> OCTINT .)
    ID              reduce using rule 64 (literal -> OCTINT .)
    ITEM_TAG        reduce using rule 64 (literal -> OCTINT .)
    INTEGER         reduce using rule 64 (literal -> OCTINT .)
    HEXINT          reduce using rule 64 (literal -> OCTINT .)
    OCTINT          reduce using rule 64 (literal -> OCTINT .)
    BININT          reduce using rule 64 (literal -> OCTINT .)
    IMAGINARY       reduce using rule 64 (literal -> OCTINT .)
    STRPREFIX       reduce using rule 64 (literal -> OCTINT .)
    SHORTSTRING     reduce using rule 64 (literal -> OCTINT .)
    LONGSTRING      reduce using rule 64 (literal -> OCTINT .)
    `               reduce using rule 64 (literal -> OCTINT .)
    ;               reduce using rule 64 (literal -> OCTINT .)
    $end            reduce using rule 64 (literal -> OCTINT .)
    }               reduce using rule 64 (literal -> OCTINT .)
    ELSE            reduce using rule 64 (literal -> OCTINT .)
    DEFAULT         reduce using rule 64 (literal -> OCTINT .)
    CASE            reduce using rule 64 (literal -> OCTINT .)


state 34

    (99) slicing -> extended_slicing .

    POWER           reduce using rule 99 (slicing -> extended_slicing .)
    [               reduce using rule 99 (slicing -> extended_slicing .)
    (               reduce using rule 99 (slicing -> extended_slicing .)
    .               reduce using rule 99 (slicing -> extended_slicing .)
    REAL            reduce using rule 99 (slicing -> extended_slicing .)
    *               reduce using rule 99 (slicing -> extended_slicing .)
    /               reduce using rule 99 (slicing -> extended_slicing .)
    ^               reduce using rule 99 (slicing -> extended_slicing .)
    +               reduce using rule 99 (slicing -> extended_slicing .)
    -               reduce using rule 99 (slicing -> extended_slicing .)
    <               reduce using rule 99 (slicing -> extended_slicing .)
    >               reduce using rule 99 (slicing -> extended_slicing .)
    GTE             reduce using rule 99 (slicing -> extended_slicing .)
    LTE             reduce using rule 99 (slicing -> extended_slicing .)
    NEQ             reduce using rule 99 (slicing -> extended_slicing .)
    ISEQUAL         reduce using rule 99 (slicing -> extended_slicing .)
    IN              reduce using rule 99 (slicing -> extended_slicing .)
    NOT             reduce using rule 99 (slicing -> extended_slicing .)
    AND             reduce using rule 99 (slicing -> extended_slicing .)
    OR              reduce using rule 99 (slicing -> extended_slicing .)
    ,               reduce using rule 99 (slicing -> extended_slicing .)
    FOR             reduce using rule 99 (slicing -> extended_slicing .)
    IF              reduce using rule 99 (slicing -> extended_slicing .)
    ]               reduce using rule 99 (slicing -> extended_slicing .)
    AUGOP           reduce using rule 99 (slicing -> extended_slicing .)
    =               reduce using rule 99 (slicing -> extended_slicing .)
    BREAK           reduce using rule 99 (slicing -> extended_slicing .)
    NEXT            reduce using rule 99 (slicing -> extended_slicing .)
    {               reduce using rule 99 (slicing -> extended_slicing .)
    PRINT           reduce using rule 99 (slicing -> extended_slicing .)
    WHERE           reduce using rule 99 (slicing -> extended_slicing .)
    SWITCH          reduce using rule 99 (slicing -> extended_slicing .)
    FUNCTION        reduce using rule 99 (slicing -> extended_slicing .)
    DO              reduce using rule 99 (slicing -> extended_slicing .)
    LOOP            reduce using rule 99 (slicing -> extended_slicing .)
    WITH            reduce using rule 99 (slicing -> extended_slicing .)
    ID              reduce using rule 99 (slicing -> extended_slicing .)
    ITEM_TAG        reduce using rule 99 (slicing -> extended_slicing .)
    INTEGER         reduce using rule 99 (slicing -> extended_slicing .)
    HEXINT          reduce using rule 99 (slicing -> extended_slicing .)
    OCTINT          reduce using rule 99 (slicing -> extended_slicing .)
    BININT          reduce using rule 99 (slicing -> extended_slicing .)
    IMAGINARY       reduce using rule 99 (slicing -> extended_slicing .)
    STRPREFIX       reduce using rule 99 (slicing -> extended_slicing .)
    SHORTSTRING     reduce using rule 99 (slicing -> extended_slicing .)
    LONGSTRING      reduce using rule 99 (slicing -> extended_slicing .)
    `               reduce using rule 99 (slicing -> extended_slicing .)
    )               reduce using rule 99 (slicing -> extended_slicing .)
    ;               reduce using rule 99 (slicing -> extended_slicing .)
    $end            reduce using rule 99 (slicing -> extended_slicing .)
    }               reduce using rule 99 (slicing -> extended_slicing .)
    ELSE            reduce using rule 99 (slicing -> extended_slicing .)
    DEFAULT         reduce using rule 99 (slicing -> extended_slicing .)
    CASE            reduce using rule 99 (slicing -> extended_slicing .)
    :               reduce using rule 99 (slicing -> extended_slicing .)


state 35

    (5) statement -> compound_stmt .

    }               reduce using rule 5 (statement -> compound_stmt .)
    BREAK           reduce using rule 5 (statement -> compound_stmt .)
    NEXT            reduce using rule 5 (statement -> compound_stmt .)
    IF              reduce using rule 5 (statement -> compound_stmt .)
    FOR             reduce using rule 5 (statement -> compound_stmt .)
    WHERE           reduce using rule 5 (statement -> compound_stmt .)
    SWITCH          reduce using rule 5 (statement -> compound_stmt .)
    FUNCTION        reduce using rule 5 (statement -> compound_stmt .)
    PRINT           reduce using rule 5 (statement -> compound_stmt .)
    DO              reduce using rule 5 (statement -> compound_stmt .)
    LOOP            reduce using rule 5 (statement -> compound_stmt .)
    WITH            reduce using rule 5 (statement -> compound_stmt .)
    (               reduce using rule 5 (statement -> compound_stmt .)
    [               reduce using rule 5 (statement -> compound_stmt .)
    ID              reduce using rule 5 (statement -> compound_stmt .)
    ITEM_TAG        reduce using rule 5 (statement -> compound_stmt .)
    INTEGER         reduce using rule 5 (statement -> compound_stmt .)
    HEXINT          reduce using rule 5 (statement -> compound_stmt .)
    OCTINT          reduce using rule 5 (statement -> compound_stmt .)
    BININT          reduce using rule 5 (statement -> compound_stmt .)
    REAL            reduce using rule 5 (statement -> compound_stmt .)
    IMAGINARY       reduce using rule 5 (statement -> compound_stmt .)
    STRPREFIX       reduce using rule 5 (statement -> compound_stmt .)
    SHORTSTRING     reduce using rule 5 (statement -> compound_stmt .)
    LONGSTRING      reduce using rule 5 (statement -> compound_stmt .)
    `               reduce using rule 5 (statement -> compound_stmt .)
    $end            reduce using rule 5 (statement -> compound_stmt .)


state 36

    (158) funcdef -> FUNCTION . ID ( arglist ) suite

    ID              shift and go to state 102


state 37

    (98) slicing -> simple_slicing .

    POWER           reduce using rule 98 (slicing -> simple_slicing .)
    [               reduce using rule 98 (slicing -> simple_slicing .)
    (               reduce using rule 98 (slicing -> simple_slicing .)
    .               reduce using rule 98 (slicing -> simple_slicing .)
    REAL            reduce using rule 98 (slicing -> simple_slicing .)
    *               reduce using rule 98 (slicing -> simple_slicing .)
    /               reduce using rule 98 (slicing -> simple_slicing .)
    ^               reduce using rule 98 (slicing -> simple_slicing .)
    +               reduce using rule 98 (slicing -> simple_slicing .)
    -               reduce using rule 98 (slicing -> simple_slicing .)
    <               reduce using rule 98 (slicing -> simple_slicing .)
    >               reduce using rule 98 (slicing -> simple_slicing .)
    GTE             reduce using rule 98 (slicing -> simple_slicing .)
    LTE             reduce using rule 98 (slicing -> simple_slicing .)
    NEQ             reduce using rule 98 (slicing -> simple_slicing .)
    ISEQUAL         reduce using rule 98 (slicing -> simple_slicing .)
    IN              reduce using rule 98 (slicing -> simple_slicing .)
    NOT             reduce using rule 98 (slicing -> simple_slicing .)
    AND             reduce using rule 98 (slicing -> simple_slicing .)
    OR              reduce using rule 98 (slicing -> simple_slicing .)
    ,               reduce using rule 98 (slicing -> simple_slicing .)
    FOR             reduce using rule 98 (slicing -> simple_slicing .)
    IF              reduce using rule 98 (slicing -> simple_slicing .)
    ]               reduce using rule 98 (slicing -> simple_slicing .)
    AUGOP           reduce using rule 98 (slicing -> simple_slicing .)
    =               reduce using rule 98 (slicing -> simple_slicing .)
    BREAK           reduce using rule 98 (slicing -> simple_slicing .)
    NEXT            reduce using rule 98 (slicing -> simple_slicing .)
    {               reduce using rule 98 (slicing -> simple_slicing .)
    PRINT           reduce using rule 98 (slicing -> simple_slicing .)
    WHERE           reduce using rule 98 (slicing -> simple_slicing .)
    SWITCH          reduce using rule 98 (slicing -> simple_slicing .)
    FUNCTION        reduce using rule 98 (slicing -> simple_slicing .)
    DO              reduce using rule 98 (slicing -> simple_slicing .)
    LOOP            reduce using rule 98 (slicing -> simple_slicing .)
    WITH            reduce using rule 98 (slicing -> simple_slicing .)
    ID              reduce using rule 98 (slicing -> simple_slicing .)
    ITEM_TAG        reduce using rule 98 (slicing -> simple_slicing .)
    INTEGER         reduce using rule 98 (slicing -> simple_slicing .)
    HEXINT          reduce using rule 98 (slicing -> simple_slicing .)
    OCTINT          reduce using rule 98 (slicing -> simple_slicing .)
    BININT          reduce using rule 98 (slicing -> simple_slicing .)
    IMAGINARY       reduce using rule 98 (slicing -> simple_slicing .)
    STRPREFIX       reduce using rule 98 (slicing -> simple_slicing .)
    SHORTSTRING     reduce using rule 98 (slicing -> simple_slicing .)
    LONGSTRING      reduce using rule 98 (slicing -> simple_slicing .)
    `               reduce using rule 98 (slicing -> simple_slicing .)
    )               reduce using rule 98 (slicing -> simple_slicing .)
    ;               reduce using rule 98 (slicing -> simple_slicing .)
    $end            reduce using rule 98 (slicing -> simple_slicing .)
    }               reduce using rule 98 (slicing -> simple_slicing .)
    ELSE            reduce using rule 98 (slicing -> simple_slicing .)
    DEFAULT         reduce using rule 98 (slicing -> simple_slicing .)
    CASE            reduce using rule 98 (slicing -> simple_slicing .)
    :               reduce using rule 98 (slicing -> simple_slicing .)


state 38

    (21) target -> [ . target_list ]
    (78) list_display -> [ . listmaker ]
    (79) list_display -> [ . ]
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (80) listmaker -> . expression listmaker2
    (81) listmaker -> . expression list_for
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (18) expression -> . or_test
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr

    ]               shift and go to state 105
    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    NOT             shift and go to state 72
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20
    -               shift and go to state 79
    +               shift and go to state 77

    primary_att                    shift and go to state 41
    primary                        shift and go to state 73
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    listmaker                      shift and go to state 103
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    target_list                    shift and go to state 104
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    target                         shift and go to state 84
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 106

state 39

    (132) compound_stmt -> where_stmt .

    BREAK           reduce using rule 132 (compound_stmt -> where_stmt .)
    NEXT            reduce using rule 132 (compound_stmt -> where_stmt .)
    IF              reduce using rule 132 (compound_stmt -> where_stmt .)
    FOR             reduce using rule 132 (compound_stmt -> where_stmt .)
    WHERE           reduce using rule 132 (compound_stmt -> where_stmt .)
    SWITCH          reduce using rule 132 (compound_stmt -> where_stmt .)
    FUNCTION        reduce using rule 132 (compound_stmt -> where_stmt .)
    PRINT           reduce using rule 132 (compound_stmt -> where_stmt .)
    DO              reduce using rule 132 (compound_stmt -> where_stmt .)
    LOOP            reduce using rule 132 (compound_stmt -> where_stmt .)
    WITH            reduce using rule 132 (compound_stmt -> where_stmt .)
    (               reduce using rule 132 (compound_stmt -> where_stmt .)
    [               reduce using rule 132 (compound_stmt -> where_stmt .)
    ID              reduce using rule 132 (compound_stmt -> where_stmt .)
    ITEM_TAG        reduce using rule 132 (compound_stmt -> where_stmt .)
    INTEGER         reduce using rule 132 (compound_stmt -> where_stmt .)
    HEXINT          reduce using rule 132 (compound_stmt -> where_stmt .)
    OCTINT          reduce using rule 132 (compound_stmt -> where_stmt .)
    BININT          reduce using rule 132 (compound_stmt -> where_stmt .)
    REAL            reduce using rule 132 (compound_stmt -> where_stmt .)
    IMAGINARY       reduce using rule 132 (compound_stmt -> where_stmt .)
    STRPREFIX       reduce using rule 132 (compound_stmt -> where_stmt .)
    SHORTSTRING     reduce using rule 132 (compound_stmt -> where_stmt .)
    LONGSTRING      reduce using rule 132 (compound_stmt -> where_stmt .)
    `               reduce using rule 132 (compound_stmt -> where_stmt .)
    $end            reduce using rule 132 (compound_stmt -> where_stmt .)
    }               reduce using rule 132 (compound_stmt -> where_stmt .)
    ELSE            reduce using rule 132 (compound_stmt -> where_stmt .)
    DEFAULT         reduce using rule 132 (compound_stmt -> where_stmt .)
    CASE            reduce using rule 132 (compound_stmt -> where_stmt .)


state 40

    (66) literal -> REAL .

    POWER           reduce using rule 66 (literal -> REAL .)
    [               reduce using rule 66 (literal -> REAL .)
    (               reduce using rule 66 (literal -> REAL .)
    .               reduce using rule 66 (literal -> REAL .)
    REAL            reduce using rule 66 (literal -> REAL .)
    *               reduce using rule 66 (literal -> REAL .)
    /               reduce using rule 66 (literal -> REAL .)
    ^               reduce using rule 66 (literal -> REAL .)
    +               reduce using rule 66 (literal -> REAL .)
    -               reduce using rule 66 (literal -> REAL .)
    <               reduce using rule 66 (literal -> REAL .)
    >               reduce using rule 66 (literal -> REAL .)
    GTE             reduce using rule 66 (literal -> REAL .)
    LTE             reduce using rule 66 (literal -> REAL .)
    NEQ             reduce using rule 66 (literal -> REAL .)
    ISEQUAL         reduce using rule 66 (literal -> REAL .)
    IN              reduce using rule 66 (literal -> REAL .)
    NOT             reduce using rule 66 (literal -> REAL .)
    AND             reduce using rule 66 (literal -> REAL .)
    OR              reduce using rule 66 (literal -> REAL .)
    ]               reduce using rule 66 (literal -> REAL .)
    :               reduce using rule 66 (literal -> REAL .)
    ,               reduce using rule 66 (literal -> REAL .)
    AUGOP           reduce using rule 66 (literal -> REAL .)
    =               reduce using rule 66 (literal -> REAL .)
    )               reduce using rule 66 (literal -> REAL .)
    BREAK           reduce using rule 66 (literal -> REAL .)
    NEXT            reduce using rule 66 (literal -> REAL .)
    {               reduce using rule 66 (literal -> REAL .)
    PRINT           reduce using rule 66 (literal -> REAL .)
    IF              reduce using rule 66 (literal -> REAL .)
    FOR             reduce using rule 66 (literal -> REAL .)
    WHERE           reduce using rule 66 (literal -> REAL .)
    SWITCH          reduce using rule 66 (literal -> REAL .)
    FUNCTION        reduce using rule 66 (literal -> REAL .)
    DO              reduce using rule 66 (literal -> REAL .)
    LOOP            reduce using rule 66 (literal -> REAL .)
    WITH            reduce using rule 66 (literal -> REAL .)
    ID              reduce using rule 66 (literal -> REAL .)
    ITEM_TAG        reduce using rule 66 (literal -> REAL .)
    INTEGER         reduce using rule 66 (literal -> REAL .)
    HEXINT          reduce using rule 66 (literal -> REAL .)
    OCTINT          reduce using rule 66 (literal -> REAL .)
    BININT          reduce using rule 66 (literal -> REAL .)
    IMAGINARY       reduce using rule 66 (literal -> REAL .)
    STRPREFIX       reduce using rule 66 (literal -> REAL .)
    SHORTSTRING     reduce using rule 66 (literal -> REAL .)
    LONGSTRING      reduce using rule 66 (literal -> REAL .)
    `               reduce using rule 66 (literal -> REAL .)
    ;               reduce using rule 66 (literal -> REAL .)
    $end            reduce using rule 66 (literal -> REAL .)
    }               reduce using rule 66 (literal -> REAL .)
    ELSE            reduce using rule 66 (literal -> REAL .)
    DEFAULT         reduce using rule 66 (literal -> REAL .)
    CASE            reduce using rule 66 (literal -> REAL .)


state 41

    (51) primary -> primary_att .

    (               reduce using rule 51 (primary -> primary_att .)
    [               reduce using rule 51 (primary -> primary_att .)
    .               reduce using rule 51 (primary -> primary_att .)
    REAL            reduce using rule 51 (primary -> primary_att .)
    AUGOP           reduce using rule 51 (primary -> primary_att .)
    =               reduce using rule 51 (primary -> primary_att .)
    ,               reduce using rule 51 (primary -> primary_att .)
    POWER           reduce using rule 51 (primary -> primary_att .)
    *               reduce using rule 51 (primary -> primary_att .)
    /               reduce using rule 51 (primary -> primary_att .)
    ^               reduce using rule 51 (primary -> primary_att .)
    +               reduce using rule 51 (primary -> primary_att .)
    -               reduce using rule 51 (primary -> primary_att .)
    <               reduce using rule 51 (primary -> primary_att .)
    >               reduce using rule 51 (primary -> primary_att .)
    GTE             reduce using rule 51 (primary -> primary_att .)
    LTE             reduce using rule 51 (primary -> primary_att .)
    NEQ             reduce using rule 51 (primary -> primary_att .)
    ISEQUAL         reduce using rule 51 (primary -> primary_att .)
    IN              reduce using rule 51 (primary -> primary_att .)
    NOT             reduce using rule 51 (primary -> primary_att .)
    AND             reduce using rule 51 (primary -> primary_att .)
    OR              reduce using rule 51 (primary -> primary_att .)
    ;               reduce using rule 51 (primary -> primary_att .)
    BREAK           reduce using rule 51 (primary -> primary_att .)
    NEXT            reduce using rule 51 (primary -> primary_att .)
    IF              reduce using rule 51 (primary -> primary_att .)
    FOR             reduce using rule 51 (primary -> primary_att .)
    WHERE           reduce using rule 51 (primary -> primary_att .)
    SWITCH          reduce using rule 51 (primary -> primary_att .)
    FUNCTION        reduce using rule 51 (primary -> primary_att .)
    PRINT           reduce using rule 51 (primary -> primary_att .)
    DO              reduce using rule 51 (primary -> primary_att .)
    LOOP            reduce using rule 51 (primary -> primary_att .)
    WITH            reduce using rule 51 (primary -> primary_att .)
    ID              reduce using rule 51 (primary -> primary_att .)
    ITEM_TAG        reduce using rule 51 (primary -> primary_att .)
    INTEGER         reduce using rule 51 (primary -> primary_att .)
    HEXINT          reduce using rule 51 (primary -> primary_att .)
    OCTINT          reduce using rule 51 (primary -> primary_att .)
    BININT          reduce using rule 51 (primary -> primary_att .)
    IMAGINARY       reduce using rule 51 (primary -> primary_att .)
    STRPREFIX       reduce using rule 51 (primary -> primary_att .)
    SHORTSTRING     reduce using rule 51 (primary -> primary_att .)
    LONGSTRING      reduce using rule 51 (primary -> primary_att .)
    `               reduce using rule 51 (primary -> primary_att .)
    $end            reduce using rule 51 (primary -> primary_att .)
    }               reduce using rule 51 (primary -> primary_att .)
    ELSE            reduce using rule 51 (primary -> primary_att .)
    DEFAULT         reduce using rule 51 (primary -> primary_att .)
    CASE            reduce using rule 51 (primary -> primary_att .)
    )               reduce using rule 51 (primary -> primary_att .)
    :               reduce using rule 51 (primary -> primary_att .)
    ]               reduce using rule 51 (primary -> primary_att .)
    {               reduce using rule 51 (primary -> primary_att .)


state 42

    (121) fancy_drel_assignment_stmt -> primary . ( dotlist )
    (19) target -> primary .
    (97) subscription -> primary . [ expression_list ]
    (115) call -> primary . ( )
    (116) call -> primary . ( argument_list )
    (94) attributeref -> primary . attribute_tag
    (100) simple_slicing -> primary . [ short_slice ]
    (105) extended_slicing -> primary . [ slice_list ]
    (95) attribute_tag -> . . ID
    (96) attribute_tag -> . REAL

    (               shift and go to state 109
    AUGOP           reduce using rule 19 (target -> primary .)
    =               reduce using rule 19 (target -> primary .)
    ,               reduce using rule 19 (target -> primary .)
    [               shift and go to state 111
    .               shift and go to state 110
    REAL            shift and go to state 107

    attribute_tag                  shift and go to state 108

state 43

    (133) compound_stmt -> switch_stmt .

    BREAK           reduce using rule 133 (compound_stmt -> switch_stmt .)
    NEXT            reduce using rule 133 (compound_stmt -> switch_stmt .)
    IF              reduce using rule 133 (compound_stmt -> switch_stmt .)
    FOR             reduce using rule 133 (compound_stmt -> switch_stmt .)
    WHERE           reduce using rule 133 (compound_stmt -> switch_stmt .)
    SWITCH          reduce using rule 133 (compound_stmt -> switch_stmt .)
    FUNCTION        reduce using rule 133 (compound_stmt -> switch_stmt .)
    PRINT           reduce using rule 133 (compound_stmt -> switch_stmt .)
    DO              reduce using rule 133 (compound_stmt -> switch_stmt .)
    LOOP            reduce using rule 133 (compound_stmt -> switch_stmt .)
    WITH            reduce using rule 133 (compound_stmt -> switch_stmt .)
    (               reduce using rule 133 (compound_stmt -> switch_stmt .)
    [               reduce using rule 133 (compound_stmt -> switch_stmt .)
    ID              reduce using rule 133 (compound_stmt -> switch_stmt .)
    ITEM_TAG        reduce using rule 133 (compound_stmt -> switch_stmt .)
    INTEGER         reduce using rule 133 (compound_stmt -> switch_stmt .)
    HEXINT          reduce using rule 133 (compound_stmt -> switch_stmt .)
    OCTINT          reduce using rule 133 (compound_stmt -> switch_stmt .)
    BININT          reduce using rule 133 (compound_stmt -> switch_stmt .)
    REAL            reduce using rule 133 (compound_stmt -> switch_stmt .)
    IMAGINARY       reduce using rule 133 (compound_stmt -> switch_stmt .)
    STRPREFIX       reduce using rule 133 (compound_stmt -> switch_stmt .)
    SHORTSTRING     reduce using rule 133 (compound_stmt -> switch_stmt .)
    LONGSTRING      reduce using rule 133 (compound_stmt -> switch_stmt .)
    `               reduce using rule 133 (compound_stmt -> switch_stmt .)
    $end            reduce using rule 133 (compound_stmt -> switch_stmt .)
    }               reduce using rule 133 (compound_stmt -> switch_stmt .)
    ELSE            reduce using rule 133 (compound_stmt -> switch_stmt .)
    DEFAULT         reduce using rule 133 (compound_stmt -> switch_stmt .)
    CASE            reduce using rule 133 (compound_stmt -> switch_stmt .)


state 44

    (65) literal -> BININT .

    POWER           reduce using rule 65 (literal -> BININT .)
    [               reduce using rule 65 (literal -> BININT .)
    (               reduce using rule 65 (literal -> BININT .)
    .               reduce using rule 65 (literal -> BININT .)
    REAL            reduce using rule 65 (literal -> BININT .)
    *               reduce using rule 65 (literal -> BININT .)
    /               reduce using rule 65 (literal -> BININT .)
    ^               reduce using rule 65 (literal -> BININT .)
    +               reduce using rule 65 (literal -> BININT .)
    -               reduce using rule 65 (literal -> BININT .)
    <               reduce using rule 65 (literal -> BININT .)
    >               reduce using rule 65 (literal -> BININT .)
    GTE             reduce using rule 65 (literal -> BININT .)
    LTE             reduce using rule 65 (literal -> BININT .)
    NEQ             reduce using rule 65 (literal -> BININT .)
    ISEQUAL         reduce using rule 65 (literal -> BININT .)
    IN              reduce using rule 65 (literal -> BININT .)
    NOT             reduce using rule 65 (literal -> BININT .)
    AND             reduce using rule 65 (literal -> BININT .)
    OR              reduce using rule 65 (literal -> BININT .)
    ]               reduce using rule 65 (literal -> BININT .)
    :               reduce using rule 65 (literal -> BININT .)
    ,               reduce using rule 65 (literal -> BININT .)
    AUGOP           reduce using rule 65 (literal -> BININT .)
    =               reduce using rule 65 (literal -> BININT .)
    )               reduce using rule 65 (literal -> BININT .)
    BREAK           reduce using rule 65 (literal -> BININT .)
    NEXT            reduce using rule 65 (literal -> BININT .)
    {               reduce using rule 65 (literal -> BININT .)
    PRINT           reduce using rule 65 (literal -> BININT .)
    IF              reduce using rule 65 (literal -> BININT .)
    FOR             reduce using rule 65 (literal -> BININT .)
    WHERE           reduce using rule 65 (literal -> BININT .)
    SWITCH          reduce using rule 65 (literal -> BININT .)
    FUNCTION        reduce using rule 65 (literal -> BININT .)
    DO              reduce using rule 65 (literal -> BININT .)
    LOOP            reduce using rule 65 (literal -> BININT .)
    WITH            reduce using rule 65 (literal -> BININT .)
    ID              reduce using rule 65 (literal -> BININT .)
    ITEM_TAG        reduce using rule 65 (literal -> BININT .)
    INTEGER         reduce using rule 65 (literal -> BININT .)
    HEXINT          reduce using rule 65 (literal -> BININT .)
    OCTINT          reduce using rule 65 (literal -> BININT .)
    BININT          reduce using rule 65 (literal -> BININT .)
    IMAGINARY       reduce using rule 65 (literal -> BININT .)
    STRPREFIX       reduce using rule 65 (literal -> BININT .)
    SHORTSTRING     reduce using rule 65 (literal -> BININT .)
    LONGSTRING      reduce using rule 65 (literal -> BININT .)
    `               reduce using rule 65 (literal -> BININT .)
    ;               reduce using rule 65 (literal -> BININT .)
    $end            reduce using rule 65 (literal -> BININT .)
    }               reduce using rule 65 (literal -> BININT .)
    ELSE            reduce using rule 65 (literal -> BININT .)
    DEFAULT         reduce using rule 65 (literal -> BININT .)
    CASE            reduce using rule 65 (literal -> BININT .)


state 45

    (58) atom -> literal .

    [               reduce using rule 58 (atom -> literal .)
    (               reduce using rule 58 (atom -> literal .)
    POWER           reduce using rule 58 (atom -> literal .)
    .               reduce using rule 58 (atom -> literal .)
    REAL            reduce using rule 58 (atom -> literal .)
    )               reduce using rule 58 (atom -> literal .)
    ,               reduce using rule 58 (atom -> literal .)
    *               reduce using rule 58 (atom -> literal .)
    /               reduce using rule 58 (atom -> literal .)
    ^               reduce using rule 58 (atom -> literal .)
    +               reduce using rule 58 (atom -> literal .)
    -               reduce using rule 58 (atom -> literal .)
    <               reduce using rule 58 (atom -> literal .)
    >               reduce using rule 58 (atom -> literal .)
    GTE             reduce using rule 58 (atom -> literal .)
    LTE             reduce using rule 58 (atom -> literal .)
    NEQ             reduce using rule 58 (atom -> literal .)
    ISEQUAL         reduce using rule 58 (atom -> literal .)
    IN              reduce using rule 58 (atom -> literal .)
    NOT             reduce using rule 58 (atom -> literal .)
    AND             reduce using rule 58 (atom -> literal .)
    OR              reduce using rule 58 (atom -> literal .)
    BREAK           reduce using rule 58 (atom -> literal .)
    NEXT            reduce using rule 58 (atom -> literal .)
    {               reduce using rule 58 (atom -> literal .)
    PRINT           reduce using rule 58 (atom -> literal .)
    IF              reduce using rule 58 (atom -> literal .)
    FOR             reduce using rule 58 (atom -> literal .)
    WHERE           reduce using rule 58 (atom -> literal .)
    SWITCH          reduce using rule 58 (atom -> literal .)
    FUNCTION        reduce using rule 58 (atom -> literal .)
    DO              reduce using rule 58 (atom -> literal .)
    LOOP            reduce using rule 58 (atom -> literal .)
    WITH            reduce using rule 58 (atom -> literal .)
    ID              reduce using rule 58 (atom -> literal .)
    ITEM_TAG        reduce using rule 58 (atom -> literal .)
    INTEGER         reduce using rule 58 (atom -> literal .)
    HEXINT          reduce using rule 58 (atom -> literal .)
    OCTINT          reduce using rule 58 (atom -> literal .)
    BININT          reduce using rule 58 (atom -> literal .)
    IMAGINARY       reduce using rule 58 (atom -> literal .)
    STRPREFIX       reduce using rule 58 (atom -> literal .)
    SHORTSTRING     reduce using rule 58 (atom -> literal .)
    LONGSTRING      reduce using rule 58 (atom -> literal .)
    `               reduce using rule 58 (atom -> literal .)
    ]               reduce using rule 58 (atom -> literal .)
    ;               reduce using rule 58 (atom -> literal .)
    $end            reduce using rule 58 (atom -> literal .)
    }               reduce using rule 58 (atom -> literal .)
    ELSE            reduce using rule 58 (atom -> literal .)
    DEFAULT         reduce using rule 58 (atom -> literal .)
    CASE            reduce using rule 58 (atom -> literal .)
    AUGOP           reduce using rule 58 (atom -> literal .)
    =               reduce using rule 58 (atom -> literal .)
    :               reduce using rule 58 (atom -> literal .)


state 46

    (155) switch_stmt -> SWITCH . ID open_brace caselist DEFAULT suite close_brace

    ID              shift and go to state 112


state 47

    (54) primary -> call .

    (               reduce using rule 54 (primary -> call .)
    [               reduce using rule 54 (primary -> call .)
    .               reduce using rule 54 (primary -> call .)
    REAL            reduce using rule 54 (primary -> call .)
    AUGOP           reduce using rule 54 (primary -> call .)
    =               reduce using rule 54 (primary -> call .)
    ,               reduce using rule 54 (primary -> call .)
    POWER           reduce using rule 54 (primary -> call .)
    *               reduce using rule 54 (primary -> call .)
    /               reduce using rule 54 (primary -> call .)
    ^               reduce using rule 54 (primary -> call .)
    +               reduce using rule 54 (primary -> call .)
    -               reduce using rule 54 (primary -> call .)
    <               reduce using rule 54 (primary -> call .)
    >               reduce using rule 54 (primary -> call .)
    GTE             reduce using rule 54 (primary -> call .)
    LTE             reduce using rule 54 (primary -> call .)
    NEQ             reduce using rule 54 (primary -> call .)
    ISEQUAL         reduce using rule 54 (primary -> call .)
    IN              reduce using rule 54 (primary -> call .)
    NOT             reduce using rule 54 (primary -> call .)
    AND             reduce using rule 54 (primary -> call .)
    OR              reduce using rule 54 (primary -> call .)
    ;               reduce using rule 54 (primary -> call .)
    BREAK           reduce using rule 54 (primary -> call .)
    NEXT            reduce using rule 54 (primary -> call .)
    IF              reduce using rule 54 (primary -> call .)
    FOR             reduce using rule 54 (primary -> call .)
    WHERE           reduce using rule 54 (primary -> call .)
    SWITCH          reduce using rule 54 (primary -> call .)
    FUNCTION        reduce using rule 54 (primary -> call .)
    PRINT           reduce using rule 54 (primary -> call .)
    DO              reduce using rule 54 (primary -> call .)
    LOOP            reduce using rule 54 (primary -> call .)
    WITH            reduce using rule 54 (primary -> call .)
    ID              reduce using rule 54 (primary -> call .)
    ITEM_TAG        reduce using rule 54 (primary -> call .)
    INTEGER         reduce using rule 54 (primary -> call .)
    HEXINT          reduce using rule 54 (primary -> call .)
    OCTINT          reduce using rule 54 (primary -> call .)
    BININT          reduce using rule 54 (primary -> call .)
    IMAGINARY       reduce using rule 54 (primary -> call .)
    STRPREFIX       reduce using rule 54 (primary -> call .)
    SHORTSTRING     reduce using rule 54 (primary -> call .)
    LONGSTRING      reduce using rule 54 (primary -> call .)
    `               reduce using rule 54 (primary -> call .)
    $end            reduce using rule 54 (primary -> call .)
    }               reduce using rule 54 (primary -> call .)
    ELSE            reduce using rule 54 (primary -> call .)
    DEFAULT         reduce using rule 54 (primary -> call .)
    CASE            reduce using rule 54 (primary -> call .)
    )               reduce using rule 54 (primary -> call .)
    :               reduce using rule 54 (primary -> call .)
    ]               reduce using rule 54 (primary -> call .)
    {               reduce using rule 54 (primary -> call .)


state 48

    (2) input -> statement .

    BREAK           reduce using rule 2 (input -> statement .)
    NEXT            reduce using rule 2 (input -> statement .)
    IF              reduce using rule 2 (input -> statement .)
    FOR             reduce using rule 2 (input -> statement .)
    WHERE           reduce using rule 2 (input -> statement .)
    SWITCH          reduce using rule 2 (input -> statement .)
    FUNCTION        reduce using rule 2 (input -> statement .)
    PRINT           reduce using rule 2 (input -> statement .)
    DO              reduce using rule 2 (input -> statement .)
    LOOP            reduce using rule 2 (input -> statement .)
    WITH            reduce using rule 2 (input -> statement .)
    (               reduce using rule 2 (input -> statement .)
    [               reduce using rule 2 (input -> statement .)
    ID              reduce using rule 2 (input -> statement .)
    ITEM_TAG        reduce using rule 2 (input -> statement .)
    INTEGER         reduce using rule 2 (input -> statement .)
    HEXINT          reduce using rule 2 (input -> statement .)
    OCTINT          reduce using rule 2 (input -> statement .)
    BININT          reduce using rule 2 (input -> statement .)
    REAL            reduce using rule 2 (input -> statement .)
    IMAGINARY       reduce using rule 2 (input -> statement .)
    STRPREFIX       reduce using rule 2 (input -> statement .)
    SHORTSTRING     reduce using rule 2 (input -> statement .)
    LONGSTRING      reduce using rule 2 (input -> statement .)
    `               reduce using rule 2 (input -> statement .)
    $end            reduce using rule 2 (input -> statement .)


state 49

    (73) enclosure -> string_conversion .

    POWER           reduce using rule 73 (enclosure -> string_conversion .)
    [               reduce using rule 73 (enclosure -> string_conversion .)
    (               reduce using rule 73 (enclosure -> string_conversion .)
    .               reduce using rule 73 (enclosure -> string_conversion .)
    REAL            reduce using rule 73 (enclosure -> string_conversion .)
    *               reduce using rule 73 (enclosure -> string_conversion .)
    /               reduce using rule 73 (enclosure -> string_conversion .)
    ^               reduce using rule 73 (enclosure -> string_conversion .)
    +               reduce using rule 73 (enclosure -> string_conversion .)
    -               reduce using rule 73 (enclosure -> string_conversion .)
    <               reduce using rule 73 (enclosure -> string_conversion .)
    >               reduce using rule 73 (enclosure -> string_conversion .)
    GTE             reduce using rule 73 (enclosure -> string_conversion .)
    LTE             reduce using rule 73 (enclosure -> string_conversion .)
    NEQ             reduce using rule 73 (enclosure -> string_conversion .)
    ISEQUAL         reduce using rule 73 (enclosure -> string_conversion .)
    IN              reduce using rule 73 (enclosure -> string_conversion .)
    NOT             reduce using rule 73 (enclosure -> string_conversion .)
    AND             reduce using rule 73 (enclosure -> string_conversion .)
    OR              reduce using rule 73 (enclosure -> string_conversion .)
    )               reduce using rule 73 (enclosure -> string_conversion .)
    ,               reduce using rule 73 (enclosure -> string_conversion .)
    BREAK           reduce using rule 73 (enclosure -> string_conversion .)
    NEXT            reduce using rule 73 (enclosure -> string_conversion .)
    {               reduce using rule 73 (enclosure -> string_conversion .)
    PRINT           reduce using rule 73 (enclosure -> string_conversion .)
    IF              reduce using rule 73 (enclosure -> string_conversion .)
    FOR             reduce using rule 73 (enclosure -> string_conversion .)
    WHERE           reduce using rule 73 (enclosure -> string_conversion .)
    SWITCH          reduce using rule 73 (enclosure -> string_conversion .)
    FUNCTION        reduce using rule 73 (enclosure -> string_conversion .)
    DO              reduce using rule 73 (enclosure -> string_conversion .)
    LOOP            reduce using rule 73 (enclosure -> string_conversion .)
    WITH            reduce using rule 73 (enclosure -> string_conversion .)
    ID              reduce using rule 73 (enclosure -> string_conversion .)
    ITEM_TAG        reduce using rule 73 (enclosure -> string_conversion .)
    INTEGER         reduce using rule 73 (enclosure -> string_conversion .)
    HEXINT          reduce using rule 73 (enclosure -> string_conversion .)
    OCTINT          reduce using rule 73 (enclosure -> string_conversion .)
    BININT          reduce using rule 73 (enclosure -> string_conversion .)
    IMAGINARY       reduce using rule 73 (enclosure -> string_conversion .)
    STRPREFIX       reduce using rule 73 (enclosure -> string_conversion .)
    SHORTSTRING     reduce using rule 73 (enclosure -> string_conversion .)
    LONGSTRING      reduce using rule 73 (enclosure -> string_conversion .)
    `               reduce using rule 73 (enclosure -> string_conversion .)
    ;               reduce using rule 73 (enclosure -> string_conversion .)
    $end            reduce using rule 73 (enclosure -> string_conversion .)
    }               reduce using rule 73 (enclosure -> string_conversion .)
    ELSE            reduce using rule 73 (enclosure -> string_conversion .)
    DEFAULT         reduce using rule 73 (enclosure -> string_conversion .)
    CASE            reduce using rule 73 (enclosure -> string_conversion .)
    ]               reduce using rule 73 (enclosure -> string_conversion .)
    :               reduce using rule 73 (enclosure -> string_conversion .)
    AUGOP           reduce using rule 73 (enclosure -> string_conversion .)
    =               reduce using rule 73 (enclosure -> string_conversion .)


state 50

    (12) simple_stmt -> print_stmt .

    ;               reduce using rule 12 (simple_stmt -> print_stmt .)
    BREAK           reduce using rule 12 (simple_stmt -> print_stmt .)
    NEXT            reduce using rule 12 (simple_stmt -> print_stmt .)
    IF              reduce using rule 12 (simple_stmt -> print_stmt .)
    FOR             reduce using rule 12 (simple_stmt -> print_stmt .)
    WHERE           reduce using rule 12 (simple_stmt -> print_stmt .)
    SWITCH          reduce using rule 12 (simple_stmt -> print_stmt .)
    FUNCTION        reduce using rule 12 (simple_stmt -> print_stmt .)
    PRINT           reduce using rule 12 (simple_stmt -> print_stmt .)
    DO              reduce using rule 12 (simple_stmt -> print_stmt .)
    LOOP            reduce using rule 12 (simple_stmt -> print_stmt .)
    WITH            reduce using rule 12 (simple_stmt -> print_stmt .)
    (               reduce using rule 12 (simple_stmt -> print_stmt .)
    [               reduce using rule 12 (simple_stmt -> print_stmt .)
    ID              reduce using rule 12 (simple_stmt -> print_stmt .)
    ITEM_TAG        reduce using rule 12 (simple_stmt -> print_stmt .)
    INTEGER         reduce using rule 12 (simple_stmt -> print_stmt .)
    HEXINT          reduce using rule 12 (simple_stmt -> print_stmt .)
    OCTINT          reduce using rule 12 (simple_stmt -> print_stmt .)
    BININT          reduce using rule 12 (simple_stmt -> print_stmt .)
    REAL            reduce using rule 12 (simple_stmt -> print_stmt .)
    IMAGINARY       reduce using rule 12 (simple_stmt -> print_stmt .)
    STRPREFIX       reduce using rule 12 (simple_stmt -> print_stmt .)
    SHORTSTRING     reduce using rule 12 (simple_stmt -> print_stmt .)
    LONGSTRING      reduce using rule 12 (simple_stmt -> print_stmt .)
    `               reduce using rule 12 (simple_stmt -> print_stmt .)
    $end            reduce using rule 12 (simple_stmt -> print_stmt .)
    }               reduce using rule 12 (simple_stmt -> print_stmt .)
    ELSE            reduce using rule 12 (simple_stmt -> print_stmt .)
    DEFAULT         reduce using rule 12 (simple_stmt -> print_stmt .)
    CASE            reduce using rule 12 (simple_stmt -> print_stmt .)


state 51

    (152) with_stmt -> with_head . suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 113
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 52

    (57) atom -> item_tag .

    [               reduce using rule 57 (atom -> item_tag .)
    (               reduce using rule 57 (atom -> item_tag .)
    POWER           reduce using rule 57 (atom -> item_tag .)
    .               reduce using rule 57 (atom -> item_tag .)
    REAL            reduce using rule 57 (atom -> item_tag .)
    )               reduce using rule 57 (atom -> item_tag .)
    ,               reduce using rule 57 (atom -> item_tag .)
    *               reduce using rule 57 (atom -> item_tag .)
    /               reduce using rule 57 (atom -> item_tag .)
    ^               reduce using rule 57 (atom -> item_tag .)
    +               reduce using rule 57 (atom -> item_tag .)
    -               reduce using rule 57 (atom -> item_tag .)
    <               reduce using rule 57 (atom -> item_tag .)
    >               reduce using rule 57 (atom -> item_tag .)
    GTE             reduce using rule 57 (atom -> item_tag .)
    LTE             reduce using rule 57 (atom -> item_tag .)
    NEQ             reduce using rule 57 (atom -> item_tag .)
    ISEQUAL         reduce using rule 57 (atom -> item_tag .)
    IN              reduce using rule 57 (atom -> item_tag .)
    NOT             reduce using rule 57 (atom -> item_tag .)
    AND             reduce using rule 57 (atom -> item_tag .)
    OR              reduce using rule 57 (atom -> item_tag .)
    BREAK           reduce using rule 57 (atom -> item_tag .)
    NEXT            reduce using rule 57 (atom -> item_tag .)
    {               reduce using rule 57 (atom -> item_tag .)
    PRINT           reduce using rule 57 (atom -> item_tag .)
    IF              reduce using rule 57 (atom -> item_tag .)
    FOR             reduce using rule 57 (atom -> item_tag .)
    WHERE           reduce using rule 57 (atom -> item_tag .)
    SWITCH          reduce using rule 57 (atom -> item_tag .)
    FUNCTION        reduce using rule 57 (atom -> item_tag .)
    DO              reduce using rule 57 (atom -> item_tag .)
    LOOP            reduce using rule 57 (atom -> item_tag .)
    WITH            reduce using rule 57 (atom -> item_tag .)
    ID              reduce using rule 57 (atom -> item_tag .)
    ITEM_TAG        reduce using rule 57 (atom -> item_tag .)
    INTEGER         reduce using rule 57 (atom -> item_tag .)
    HEXINT          reduce using rule 57 (atom -> item_tag .)
    OCTINT          reduce using rule 57 (atom -> item_tag .)
    BININT          reduce using rule 57 (atom -> item_tag .)
    IMAGINARY       reduce using rule 57 (atom -> item_tag .)
    STRPREFIX       reduce using rule 57 (atom -> item_tag .)
    SHORTSTRING     reduce using rule 57 (atom -> item_tag .)
    LONGSTRING      reduce using rule 57 (atom -> item_tag .)
    `               reduce using rule 57 (atom -> item_tag .)
    ]               reduce using rule 57 (atom -> item_tag .)
    ;               reduce using rule 57 (atom -> item_tag .)
    $end            reduce using rule 57 (atom -> item_tag .)
    }               reduce using rule 57 (atom -> item_tag .)
    ELSE            reduce using rule 57 (atom -> item_tag .)
    DEFAULT         reduce using rule 57 (atom -> item_tag .)
    CASE            reduce using rule 57 (atom -> item_tag .)
    AUGOP           reduce using rule 57 (atom -> item_tag .)
    =               reduce using rule 57 (atom -> item_tag .)
    :               reduce using rule 57 (atom -> item_tag .)


state 53

    (52) primary -> subscription .

    (               reduce using rule 52 (primary -> subscription .)
    [               reduce using rule 52 (primary -> subscription .)
    .               reduce using rule 52 (primary -> subscription .)
    REAL            reduce using rule 52 (primary -> subscription .)
    AUGOP           reduce using rule 52 (primary -> subscription .)
    =               reduce using rule 52 (primary -> subscription .)
    ,               reduce using rule 52 (primary -> subscription .)
    POWER           reduce using rule 52 (primary -> subscription .)
    *               reduce using rule 52 (primary -> subscription .)
    /               reduce using rule 52 (primary -> subscription .)
    ^               reduce using rule 52 (primary -> subscription .)
    +               reduce using rule 52 (primary -> subscription .)
    -               reduce using rule 52 (primary -> subscription .)
    <               reduce using rule 52 (primary -> subscription .)
    >               reduce using rule 52 (primary -> subscription .)
    GTE             reduce using rule 52 (primary -> subscription .)
    LTE             reduce using rule 52 (primary -> subscription .)
    NEQ             reduce using rule 52 (primary -> subscription .)
    ISEQUAL         reduce using rule 52 (primary -> subscription .)
    IN              reduce using rule 52 (primary -> subscription .)
    NOT             reduce using rule 52 (primary -> subscription .)
    AND             reduce using rule 52 (primary -> subscription .)
    OR              reduce using rule 52 (primary -> subscription .)
    ;               reduce using rule 52 (primary -> subscription .)
    BREAK           reduce using rule 52 (primary -> subscription .)
    NEXT            reduce using rule 52 (primary -> subscription .)
    IF              reduce using rule 52 (primary -> subscription .)
    FOR             reduce using rule 52 (primary -> subscription .)
    WHERE           reduce using rule 52 (primary -> subscription .)
    SWITCH          reduce using rule 52 (primary -> subscription .)
    FUNCTION        reduce using rule 52 (primary -> subscription .)
    PRINT           reduce using rule 52 (primary -> subscription .)
    DO              reduce using rule 52 (primary -> subscription .)
    LOOP            reduce using rule 52 (primary -> subscription .)
    WITH            reduce using rule 52 (primary -> subscription .)
    ID              reduce using rule 52 (primary -> subscription .)
    ITEM_TAG        reduce using rule 52 (primary -> subscription .)
    INTEGER         reduce using rule 52 (primary -> subscription .)
    HEXINT          reduce using rule 52 (primary -> subscription .)
    OCTINT          reduce using rule 52 (primary -> subscription .)
    BININT          reduce using rule 52 (primary -> subscription .)
    IMAGINARY       reduce using rule 52 (primary -> subscription .)
    STRPREFIX       reduce using rule 52 (primary -> subscription .)
    SHORTSTRING     reduce using rule 52 (primary -> subscription .)
    LONGSTRING      reduce using rule 52 (primary -> subscription .)
    `               reduce using rule 52 (primary -> subscription .)
    $end            reduce using rule 52 (primary -> subscription .)
    }               reduce using rule 52 (primary -> subscription .)
    ELSE            reduce using rule 52 (primary -> subscription .)
    DEFAULT         reduce using rule 52 (primary -> subscription .)
    CASE            reduce using rule 52 (primary -> subscription .)
    )               reduce using rule 52 (primary -> subscription .)
    :               reduce using rule 52 (primary -> subscription .)
    ]               reduce using rule 52 (primary -> subscription .)
    {               reduce using rule 52 (primary -> subscription .)


state 54

    (120) augmented_assignment_stmt -> target . AUGOP expression_list
    (125) target_list -> target .

    AUGOP           shift and go to state 114
    =               reduce using rule 125 (target_list -> target .)
    ,               reduce using rule 125 (target_list -> target .)


state 55

    (62) literal -> INTEGER .

    POWER           reduce using rule 62 (literal -> INTEGER .)
    [               reduce using rule 62 (literal -> INTEGER .)
    (               reduce using rule 62 (literal -> INTEGER .)
    .               reduce using rule 62 (literal -> INTEGER .)
    REAL            reduce using rule 62 (literal -> INTEGER .)
    *               reduce using rule 62 (literal -> INTEGER .)
    /               reduce using rule 62 (literal -> INTEGER .)
    ^               reduce using rule 62 (literal -> INTEGER .)
    +               reduce using rule 62 (literal -> INTEGER .)
    -               reduce using rule 62 (literal -> INTEGER .)
    <               reduce using rule 62 (literal -> INTEGER .)
    >               reduce using rule 62 (literal -> INTEGER .)
    GTE             reduce using rule 62 (literal -> INTEGER .)
    LTE             reduce using rule 62 (literal -> INTEGER .)
    NEQ             reduce using rule 62 (literal -> INTEGER .)
    ISEQUAL         reduce using rule 62 (literal -> INTEGER .)
    IN              reduce using rule 62 (literal -> INTEGER .)
    NOT             reduce using rule 62 (literal -> INTEGER .)
    AND             reduce using rule 62 (literal -> INTEGER .)
    OR              reduce using rule 62 (literal -> INTEGER .)
    ]               reduce using rule 62 (literal -> INTEGER .)
    :               reduce using rule 62 (literal -> INTEGER .)
    ,               reduce using rule 62 (literal -> INTEGER .)
    AUGOP           reduce using rule 62 (literal -> INTEGER .)
    =               reduce using rule 62 (literal -> INTEGER .)
    )               reduce using rule 62 (literal -> INTEGER .)
    BREAK           reduce using rule 62 (literal -> INTEGER .)
    NEXT            reduce using rule 62 (literal -> INTEGER .)
    {               reduce using rule 62 (literal -> INTEGER .)
    PRINT           reduce using rule 62 (literal -> INTEGER .)
    IF              reduce using rule 62 (literal -> INTEGER .)
    FOR             reduce using rule 62 (literal -> INTEGER .)
    WHERE           reduce using rule 62 (literal -> INTEGER .)
    SWITCH          reduce using rule 62 (literal -> INTEGER .)
    FUNCTION        reduce using rule 62 (literal -> INTEGER .)
    DO              reduce using rule 62 (literal -> INTEGER .)
    LOOP            reduce using rule 62 (literal -> INTEGER .)
    WITH            reduce using rule 62 (literal -> INTEGER .)
    ID              reduce using rule 62 (literal -> INTEGER .)
    ITEM_TAG        reduce using rule 62 (literal -> INTEGER .)
    INTEGER         reduce using rule 62 (literal -> INTEGER .)
    HEXINT          reduce using rule 62 (literal -> INTEGER .)
    OCTINT          reduce using rule 62 (literal -> INTEGER .)
    BININT          reduce using rule 62 (literal -> INTEGER .)
    IMAGINARY       reduce using rule 62 (literal -> INTEGER .)
    STRPREFIX       reduce using rule 62 (literal -> INTEGER .)
    SHORTSTRING     reduce using rule 62 (literal -> INTEGER .)
    LONGSTRING      reduce using rule 62 (literal -> INTEGER .)
    `               reduce using rule 62 (literal -> INTEGER .)
    ;               reduce using rule 62 (literal -> INTEGER .)
    $end            reduce using rule 62 (literal -> INTEGER .)
    }               reduce using rule 62 (literal -> INTEGER .)
    ELSE            reduce using rule 62 (literal -> INTEGER .)
    DEFAULT         reduce using rule 62 (literal -> INTEGER .)
    CASE            reduce using rule 62 (literal -> INTEGER .)


state 56

    (13) simple_stmt -> BREAK .

    ;               reduce using rule 13 (simple_stmt -> BREAK .)
    BREAK           reduce using rule 13 (simple_stmt -> BREAK .)
    NEXT            reduce using rule 13 (simple_stmt -> BREAK .)
    IF              reduce using rule 13 (simple_stmt -> BREAK .)
    FOR             reduce using rule 13 (simple_stmt -> BREAK .)
    WHERE           reduce using rule 13 (simple_stmt -> BREAK .)
    SWITCH          reduce using rule 13 (simple_stmt -> BREAK .)
    FUNCTION        reduce using rule 13 (simple_stmt -> BREAK .)
    PRINT           reduce using rule 13 (simple_stmt -> BREAK .)
    DO              reduce using rule 13 (simple_stmt -> BREAK .)
    LOOP            reduce using rule 13 (simple_stmt -> BREAK .)
    WITH            reduce using rule 13 (simple_stmt -> BREAK .)
    (               reduce using rule 13 (simple_stmt -> BREAK .)
    [               reduce using rule 13 (simple_stmt -> BREAK .)
    ID              reduce using rule 13 (simple_stmt -> BREAK .)
    ITEM_TAG        reduce using rule 13 (simple_stmt -> BREAK .)
    INTEGER         reduce using rule 13 (simple_stmt -> BREAK .)
    HEXINT          reduce using rule 13 (simple_stmt -> BREAK .)
    OCTINT          reduce using rule 13 (simple_stmt -> BREAK .)
    BININT          reduce using rule 13 (simple_stmt -> BREAK .)
    REAL            reduce using rule 13 (simple_stmt -> BREAK .)
    IMAGINARY       reduce using rule 13 (simple_stmt -> BREAK .)
    STRPREFIX       reduce using rule 13 (simple_stmt -> BREAK .)
    SHORTSTRING     reduce using rule 13 (simple_stmt -> BREAK .)
    LONGSTRING      reduce using rule 13 (simple_stmt -> BREAK .)
    `               reduce using rule 13 (simple_stmt -> BREAK .)
    $end            reduce using rule 13 (simple_stmt -> BREAK .)
    }               reduce using rule 13 (simple_stmt -> BREAK .)
    ELSE            reduce using rule 13 (simple_stmt -> BREAK .)
    DEFAULT         reduce using rule 13 (simple_stmt -> BREAK .)
    CASE            reduce using rule 13 (simple_stmt -> BREAK .)


state 57

    (63) literal -> HEXINT .

    POWER           reduce using rule 63 (literal -> HEXINT .)
    [               reduce using rule 63 (literal -> HEXINT .)
    (               reduce using rule 63 (literal -> HEXINT .)
    .               reduce using rule 63 (literal -> HEXINT .)
    REAL            reduce using rule 63 (literal -> HEXINT .)
    *               reduce using rule 63 (literal -> HEXINT .)
    /               reduce using rule 63 (literal -> HEXINT .)
    ^               reduce using rule 63 (literal -> HEXINT .)
    +               reduce using rule 63 (literal -> HEXINT .)
    -               reduce using rule 63 (literal -> HEXINT .)
    <               reduce using rule 63 (literal -> HEXINT .)
    >               reduce using rule 63 (literal -> HEXINT .)
    GTE             reduce using rule 63 (literal -> HEXINT .)
    LTE             reduce using rule 63 (literal -> HEXINT .)
    NEQ             reduce using rule 63 (literal -> HEXINT .)
    ISEQUAL         reduce using rule 63 (literal -> HEXINT .)
    IN              reduce using rule 63 (literal -> HEXINT .)
    NOT             reduce using rule 63 (literal -> HEXINT .)
    AND             reduce using rule 63 (literal -> HEXINT .)
    OR              reduce using rule 63 (literal -> HEXINT .)
    ]               reduce using rule 63 (literal -> HEXINT .)
    :               reduce using rule 63 (literal -> HEXINT .)
    ,               reduce using rule 63 (literal -> HEXINT .)
    AUGOP           reduce using rule 63 (literal -> HEXINT .)
    =               reduce using rule 63 (literal -> HEXINT .)
    )               reduce using rule 63 (literal -> HEXINT .)
    BREAK           reduce using rule 63 (literal -> HEXINT .)
    NEXT            reduce using rule 63 (literal -> HEXINT .)
    {               reduce using rule 63 (literal -> HEXINT .)
    PRINT           reduce using rule 63 (literal -> HEXINT .)
    IF              reduce using rule 63 (literal -> HEXINT .)
    FOR             reduce using rule 63 (literal -> HEXINT .)
    WHERE           reduce using rule 63 (literal -> HEXINT .)
    SWITCH          reduce using rule 63 (literal -> HEXINT .)
    FUNCTION        reduce using rule 63 (literal -> HEXINT .)
    DO              reduce using rule 63 (literal -> HEXINT .)
    LOOP            reduce using rule 63 (literal -> HEXINT .)
    WITH            reduce using rule 63 (literal -> HEXINT .)
    ID              reduce using rule 63 (literal -> HEXINT .)
    ITEM_TAG        reduce using rule 63 (literal -> HEXINT .)
    INTEGER         reduce using rule 63 (literal -> HEXINT .)
    HEXINT          reduce using rule 63 (literal -> HEXINT .)
    OCTINT          reduce using rule 63 (literal -> HEXINT .)
    BININT          reduce using rule 63 (literal -> HEXINT .)
    IMAGINARY       reduce using rule 63 (literal -> HEXINT .)
    STRPREFIX       reduce using rule 63 (literal -> HEXINT .)
    SHORTSTRING     reduce using rule 63 (literal -> HEXINT .)
    LONGSTRING      reduce using rule 63 (literal -> HEXINT .)
    `               reduce using rule 63 (literal -> HEXINT .)
    ;               reduce using rule 63 (literal -> HEXINT .)
    $end            reduce using rule 63 (literal -> HEXINT .)
    }               reduce using rule 63 (literal -> HEXINT .)
    ELSE            reduce using rule 63 (literal -> HEXINT .)
    DEFAULT         reduce using rule 63 (literal -> HEXINT .)
    CASE            reduce using rule 63 (literal -> HEXINT .)


state 58

    (150) do_stmt_head -> DO . ID = expression , expression
    (151) do_stmt_head -> DO . ID = expression , expression , expression

    ID              shift and go to state 115


state 59

    (67) literal -> IMAGINARY .

    POWER           reduce using rule 67 (literal -> IMAGINARY .)
    [               reduce using rule 67 (literal -> IMAGINARY .)
    (               reduce using rule 67 (literal -> IMAGINARY .)
    .               reduce using rule 67 (literal -> IMAGINARY .)
    REAL            reduce using rule 67 (literal -> IMAGINARY .)
    *               reduce using rule 67 (literal -> IMAGINARY .)
    /               reduce using rule 67 (literal -> IMAGINARY .)
    ^               reduce using rule 67 (literal -> IMAGINARY .)
    +               reduce using rule 67 (literal -> IMAGINARY .)
    -               reduce using rule 67 (literal -> IMAGINARY .)
    <               reduce using rule 67 (literal -> IMAGINARY .)
    >               reduce using rule 67 (literal -> IMAGINARY .)
    GTE             reduce using rule 67 (literal -> IMAGINARY .)
    LTE             reduce using rule 67 (literal -> IMAGINARY .)
    NEQ             reduce using rule 67 (literal -> IMAGINARY .)
    ISEQUAL         reduce using rule 67 (literal -> IMAGINARY .)
    IN              reduce using rule 67 (literal -> IMAGINARY .)
    NOT             reduce using rule 67 (literal -> IMAGINARY .)
    AND             reduce using rule 67 (literal -> IMAGINARY .)
    OR              reduce using rule 67 (literal -> IMAGINARY .)
    ]               reduce using rule 67 (literal -> IMAGINARY .)
    :               reduce using rule 67 (literal -> IMAGINARY .)
    ,               reduce using rule 67 (literal -> IMAGINARY .)
    AUGOP           reduce using rule 67 (literal -> IMAGINARY .)
    =               reduce using rule 67 (literal -> IMAGINARY .)
    )               reduce using rule 67 (literal -> IMAGINARY .)
    BREAK           reduce using rule 67 (literal -> IMAGINARY .)
    NEXT            reduce using rule 67 (literal -> IMAGINARY .)
    {               reduce using rule 67 (literal -> IMAGINARY .)
    PRINT           reduce using rule 67 (literal -> IMAGINARY .)
    IF              reduce using rule 67 (literal -> IMAGINARY .)
    FOR             reduce using rule 67 (literal -> IMAGINARY .)
    WHERE           reduce using rule 67 (literal -> IMAGINARY .)
    SWITCH          reduce using rule 67 (literal -> IMAGINARY .)
    FUNCTION        reduce using rule 67 (literal -> IMAGINARY .)
    DO              reduce using rule 67 (literal -> IMAGINARY .)
    LOOP            reduce using rule 67 (literal -> IMAGINARY .)
    WITH            reduce using rule 67 (literal -> IMAGINARY .)
    ID              reduce using rule 67 (literal -> IMAGINARY .)
    ITEM_TAG        reduce using rule 67 (literal -> IMAGINARY .)
    INTEGER         reduce using rule 67 (literal -> IMAGINARY .)
    HEXINT          reduce using rule 67 (literal -> IMAGINARY .)
    OCTINT          reduce using rule 67 (literal -> IMAGINARY .)
    BININT          reduce using rule 67 (literal -> IMAGINARY .)
    IMAGINARY       reduce using rule 67 (literal -> IMAGINARY .)
    STRPREFIX       reduce using rule 67 (literal -> IMAGINARY .)
    SHORTSTRING     reduce using rule 67 (literal -> IMAGINARY .)
    LONGSTRING      reduce using rule 67 (literal -> IMAGINARY .)
    `               reduce using rule 67 (literal -> IMAGINARY .)
    ;               reduce using rule 67 (literal -> IMAGINARY .)
    $end            reduce using rule 67 (literal -> IMAGINARY .)
    }               reduce using rule 67 (literal -> IMAGINARY .)
    ELSE            reduce using rule 67 (literal -> IMAGINARY .)
    DEFAULT         reduce using rule 67 (literal -> IMAGINARY .)
    CASE            reduce using rule 67 (literal -> IMAGINARY .)


state 60

    (56) atom -> ID .

    [               reduce using rule 56 (atom -> ID .)
    (               reduce using rule 56 (atom -> ID .)
    POWER           reduce using rule 56 (atom -> ID .)
    .               reduce using rule 56 (atom -> ID .)
    REAL            reduce using rule 56 (atom -> ID .)
    )               reduce using rule 56 (atom -> ID .)
    ,               reduce using rule 56 (atom -> ID .)
    *               reduce using rule 56 (atom -> ID .)
    /               reduce using rule 56 (atom -> ID .)
    ^               reduce using rule 56 (atom -> ID .)
    +               reduce using rule 56 (atom -> ID .)
    -               reduce using rule 56 (atom -> ID .)
    <               reduce using rule 56 (atom -> ID .)
    >               reduce using rule 56 (atom -> ID .)
    GTE             reduce using rule 56 (atom -> ID .)
    LTE             reduce using rule 56 (atom -> ID .)
    NEQ             reduce using rule 56 (atom -> ID .)
    ISEQUAL         reduce using rule 56 (atom -> ID .)
    IN              reduce using rule 56 (atom -> ID .)
    NOT             reduce using rule 56 (atom -> ID .)
    AND             reduce using rule 56 (atom -> ID .)
    OR              reduce using rule 56 (atom -> ID .)
    BREAK           reduce using rule 56 (atom -> ID .)
    NEXT            reduce using rule 56 (atom -> ID .)
    {               reduce using rule 56 (atom -> ID .)
    PRINT           reduce using rule 56 (atom -> ID .)
    IF              reduce using rule 56 (atom -> ID .)
    FOR             reduce using rule 56 (atom -> ID .)
    WHERE           reduce using rule 56 (atom -> ID .)
    SWITCH          reduce using rule 56 (atom -> ID .)
    FUNCTION        reduce using rule 56 (atom -> ID .)
    DO              reduce using rule 56 (atom -> ID .)
    LOOP            reduce using rule 56 (atom -> ID .)
    WITH            reduce using rule 56 (atom -> ID .)
    ID              reduce using rule 56 (atom -> ID .)
    ITEM_TAG        reduce using rule 56 (atom -> ID .)
    INTEGER         reduce using rule 56 (atom -> ID .)
    HEXINT          reduce using rule 56 (atom -> ID .)
    OCTINT          reduce using rule 56 (atom -> ID .)
    BININT          reduce using rule 56 (atom -> ID .)
    IMAGINARY       reduce using rule 56 (atom -> ID .)
    STRPREFIX       reduce using rule 56 (atom -> ID .)
    SHORTSTRING     reduce using rule 56 (atom -> ID .)
    LONGSTRING      reduce using rule 56 (atom -> ID .)
    `               reduce using rule 56 (atom -> ID .)
    ]               reduce using rule 56 (atom -> ID .)
    ;               reduce using rule 56 (atom -> ID .)
    $end            reduce using rule 56 (atom -> ID .)
    }               reduce using rule 56 (atom -> ID .)
    ELSE            reduce using rule 56 (atom -> ID .)
    DEFAULT         reduce using rule 56 (atom -> ID .)
    CASE            reduce using rule 56 (atom -> ID .)
    AUGOP           reduce using rule 56 (atom -> ID .)
    =               reduce using rule 56 (atom -> ID .)
    :               reduce using rule 56 (atom -> ID .)


state 61

    (135) if_stmt -> IF . expression suite
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 116

state 62

    (4) statement -> stmt_list .
    (7) stmt_list -> stmt_list . ; simple_stmt
    (8) stmt_list -> stmt_list . ; simple_stmt ;

    }               reduce using rule 4 (statement -> stmt_list .)
    BREAK           reduce using rule 4 (statement -> stmt_list .)
    NEXT            reduce using rule 4 (statement -> stmt_list .)
    IF              reduce using rule 4 (statement -> stmt_list .)
    FOR             reduce using rule 4 (statement -> stmt_list .)
    WHERE           reduce using rule 4 (statement -> stmt_list .)
    SWITCH          reduce using rule 4 (statement -> stmt_list .)
    FUNCTION        reduce using rule 4 (statement -> stmt_list .)
    PRINT           reduce using rule 4 (statement -> stmt_list .)
    DO              reduce using rule 4 (statement -> stmt_list .)
    LOOP            reduce using rule 4 (statement -> stmt_list .)
    WITH            reduce using rule 4 (statement -> stmt_list .)
    (               reduce using rule 4 (statement -> stmt_list .)
    [               reduce using rule 4 (statement -> stmt_list .)
    ID              reduce using rule 4 (statement -> stmt_list .)
    ITEM_TAG        reduce using rule 4 (statement -> stmt_list .)
    INTEGER         reduce using rule 4 (statement -> stmt_list .)
    HEXINT          reduce using rule 4 (statement -> stmt_list .)
    OCTINT          reduce using rule 4 (statement -> stmt_list .)
    BININT          reduce using rule 4 (statement -> stmt_list .)
    REAL            reduce using rule 4 (statement -> stmt_list .)
    IMAGINARY       reduce using rule 4 (statement -> stmt_list .)
    STRPREFIX       reduce using rule 4 (statement -> stmt_list .)
    SHORTSTRING     reduce using rule 4 (statement -> stmt_list .)
    LONGSTRING      reduce using rule 4 (statement -> stmt_list .)
    `               reduce using rule 4 (statement -> stmt_list .)
    $end            reduce using rule 4 (statement -> stmt_list .)
    ;               shift and go to state 117


state 63

    (124) assignment_stmt -> target_list . = expression_list
    (126) target_list -> target_list . , target

    =               shift and go to state 118
    ,               shift and go to state 119


state 64

    (60) item_tag -> ITEM_TAG .

    POWER           reduce using rule 60 (item_tag -> ITEM_TAG .)
    [               reduce using rule 60 (item_tag -> ITEM_TAG .)
    (               reduce using rule 60 (item_tag -> ITEM_TAG .)
    .               reduce using rule 60 (item_tag -> ITEM_TAG .)
    REAL            reduce using rule 60 (item_tag -> ITEM_TAG .)
    *               reduce using rule 60 (item_tag -> ITEM_TAG .)
    /               reduce using rule 60 (item_tag -> ITEM_TAG .)
    ^               reduce using rule 60 (item_tag -> ITEM_TAG .)
    +               reduce using rule 60 (item_tag -> ITEM_TAG .)
    -               reduce using rule 60 (item_tag -> ITEM_TAG .)
    <               reduce using rule 60 (item_tag -> ITEM_TAG .)
    >               reduce using rule 60 (item_tag -> ITEM_TAG .)
    GTE             reduce using rule 60 (item_tag -> ITEM_TAG .)
    LTE             reduce using rule 60 (item_tag -> ITEM_TAG .)
    NEQ             reduce using rule 60 (item_tag -> ITEM_TAG .)
    ISEQUAL         reduce using rule 60 (item_tag -> ITEM_TAG .)
    IN              reduce using rule 60 (item_tag -> ITEM_TAG .)
    NOT             reduce using rule 60 (item_tag -> ITEM_TAG .)
    AND             reduce using rule 60 (item_tag -> ITEM_TAG .)
    OR              reduce using rule 60 (item_tag -> ITEM_TAG .)
    BREAK           reduce using rule 60 (item_tag -> ITEM_TAG .)
    NEXT            reduce using rule 60 (item_tag -> ITEM_TAG .)
    {               reduce using rule 60 (item_tag -> ITEM_TAG .)
    PRINT           reduce using rule 60 (item_tag -> ITEM_TAG .)
    IF              reduce using rule 60 (item_tag -> ITEM_TAG .)
    FOR             reduce using rule 60 (item_tag -> ITEM_TAG .)
    WHERE           reduce using rule 60 (item_tag -> ITEM_TAG .)
    SWITCH          reduce using rule 60 (item_tag -> ITEM_TAG .)
    FUNCTION        reduce using rule 60 (item_tag -> ITEM_TAG .)
    DO              reduce using rule 60 (item_tag -> ITEM_TAG .)
    LOOP            reduce using rule 60 (item_tag -> ITEM_TAG .)
    WITH            reduce using rule 60 (item_tag -> ITEM_TAG .)
    ID              reduce using rule 60 (item_tag -> ITEM_TAG .)
    ITEM_TAG        reduce using rule 60 (item_tag -> ITEM_TAG .)
    INTEGER         reduce using rule 60 (item_tag -> ITEM_TAG .)
    HEXINT          reduce using rule 60 (item_tag -> ITEM_TAG .)
    OCTINT          reduce using rule 60 (item_tag -> ITEM_TAG .)
    BININT          reduce using rule 60 (item_tag -> ITEM_TAG .)
    IMAGINARY       reduce using rule 60 (item_tag -> ITEM_TAG .)
    STRPREFIX       reduce using rule 60 (item_tag -> ITEM_TAG .)
    SHORTSTRING     reduce using rule 60 (item_tag -> ITEM_TAG .)
    LONGSTRING      reduce using rule 60 (item_tag -> ITEM_TAG .)
    `               reduce using rule 60 (item_tag -> ITEM_TAG .)
    ,               reduce using rule 60 (item_tag -> ITEM_TAG .)
    AUGOP           reduce using rule 60 (item_tag -> ITEM_TAG .)
    =               reduce using rule 60 (item_tag -> ITEM_TAG .)
    ]               reduce using rule 60 (item_tag -> ITEM_TAG .)
    :               reduce using rule 60 (item_tag -> ITEM_TAG .)
    )               reduce using rule 60 (item_tag -> ITEM_TAG .)
    ;               reduce using rule 60 (item_tag -> ITEM_TAG .)
    $end            reduce using rule 60 (item_tag -> ITEM_TAG .)
    }               reduce using rule 60 (item_tag -> ITEM_TAG .)
    ELSE            reduce using rule 60 (item_tag -> ITEM_TAG .)
    DEFAULT         reduce using rule 60 (item_tag -> ITEM_TAG .)
    CASE            reduce using rule 60 (item_tag -> ITEM_TAG .)


state 65

    (149) do_stmt -> do_stmt_head suite .

    BREAK           reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    NEXT            reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    IF              reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    FOR             reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    WHERE           reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    SWITCH          reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    FUNCTION        reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    PRINT           reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    DO              reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    LOOP            reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    WITH            reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    (               reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    [               reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    ID              reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    ITEM_TAG        reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    INTEGER         reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    HEXINT          reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    OCTINT          reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    BININT          reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    REAL            reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    IMAGINARY       reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    STRPREFIX       reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    SHORTSTRING     reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    LONGSTRING      reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    `               reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    $end            reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    }               reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    ELSE            reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    DEFAULT         reduce using rule 149 (do_stmt -> do_stmt_head suite .)
    CASE            reduce using rule 149 (do_stmt -> do_stmt_head suite .)


state 66

    (137) suite -> simple_stmt .

    BREAK           reduce using rule 137 (suite -> simple_stmt .)
    NEXT            reduce using rule 137 (suite -> simple_stmt .)
    IF              reduce using rule 137 (suite -> simple_stmt .)
    FOR             reduce using rule 137 (suite -> simple_stmt .)
    WHERE           reduce using rule 137 (suite -> simple_stmt .)
    SWITCH          reduce using rule 137 (suite -> simple_stmt .)
    FUNCTION        reduce using rule 137 (suite -> simple_stmt .)
    PRINT           reduce using rule 137 (suite -> simple_stmt .)
    DO              reduce using rule 137 (suite -> simple_stmt .)
    LOOP            reduce using rule 137 (suite -> simple_stmt .)
    WITH            reduce using rule 137 (suite -> simple_stmt .)
    (               reduce using rule 137 (suite -> simple_stmt .)
    [               reduce using rule 137 (suite -> simple_stmt .)
    ID              reduce using rule 137 (suite -> simple_stmt .)
    ITEM_TAG        reduce using rule 137 (suite -> simple_stmt .)
    INTEGER         reduce using rule 137 (suite -> simple_stmt .)
    HEXINT          reduce using rule 137 (suite -> simple_stmt .)
    OCTINT          reduce using rule 137 (suite -> simple_stmt .)
    BININT          reduce using rule 137 (suite -> simple_stmt .)
    REAL            reduce using rule 137 (suite -> simple_stmt .)
    IMAGINARY       reduce using rule 137 (suite -> simple_stmt .)
    STRPREFIX       reduce using rule 137 (suite -> simple_stmt .)
    SHORTSTRING     reduce using rule 137 (suite -> simple_stmt .)
    LONGSTRING      reduce using rule 137 (suite -> simple_stmt .)
    `               reduce using rule 137 (suite -> simple_stmt .)
    $end            reduce using rule 137 (suite -> simple_stmt .)
    }               reduce using rule 137 (suite -> simple_stmt .)
    ELSE            reduce using rule 137 (suite -> simple_stmt .)
    DEFAULT         reduce using rule 137 (suite -> simple_stmt .)
    CASE            reduce using rule 137 (suite -> simple_stmt .)


state 67

    (138) suite -> compound_stmt .

    BREAK           reduce using rule 138 (suite -> compound_stmt .)
    NEXT            reduce using rule 138 (suite -> compound_stmt .)
    IF              reduce using rule 138 (suite -> compound_stmt .)
    FOR             reduce using rule 138 (suite -> compound_stmt .)
    WHERE           reduce using rule 138 (suite -> compound_stmt .)
    SWITCH          reduce using rule 138 (suite -> compound_stmt .)
    FUNCTION        reduce using rule 138 (suite -> compound_stmt .)
    PRINT           reduce using rule 138 (suite -> compound_stmt .)
    DO              reduce using rule 138 (suite -> compound_stmt .)
    LOOP            reduce using rule 138 (suite -> compound_stmt .)
    WITH            reduce using rule 138 (suite -> compound_stmt .)
    (               reduce using rule 138 (suite -> compound_stmt .)
    [               reduce using rule 138 (suite -> compound_stmt .)
    ID              reduce using rule 138 (suite -> compound_stmt .)
    ITEM_TAG        reduce using rule 138 (suite -> compound_stmt .)
    INTEGER         reduce using rule 138 (suite -> compound_stmt .)
    HEXINT          reduce using rule 138 (suite -> compound_stmt .)
    OCTINT          reduce using rule 138 (suite -> compound_stmt .)
    BININT          reduce using rule 138 (suite -> compound_stmt .)
    REAL            reduce using rule 138 (suite -> compound_stmt .)
    IMAGINARY       reduce using rule 138 (suite -> compound_stmt .)
    STRPREFIX       reduce using rule 138 (suite -> compound_stmt .)
    SHORTSTRING     reduce using rule 138 (suite -> compound_stmt .)
    LONGSTRING      reduce using rule 138 (suite -> compound_stmt .)
    `               reduce using rule 138 (suite -> compound_stmt .)
    $end            reduce using rule 138 (suite -> compound_stmt .)
    }               reduce using rule 138 (suite -> compound_stmt .)
    ELSE            reduce using rule 138 (suite -> compound_stmt .)
    DEFAULT         reduce using rule 138 (suite -> compound_stmt .)
    CASE            reduce using rule 138 (suite -> compound_stmt .)


state 68

    (139) suite -> open_brace . statement_block close_brace
    (142) statement_block -> . statement
    (143) statement_block -> . statement_block statement
    (4) statement -> . stmt_list
    (5) statement -> . compound_stmt
    (6) stmt_list -> . simple_stmt
    (7) stmt_list -> . stmt_list ; simple_stmt
    (8) stmt_list -> . stmt_list ; simple_stmt ;
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    PRINT           shift and go to state 28
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    statement_block                shift and go to state 120
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 14
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    statement                      shift and go to state 121
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 35
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    stmt_list                      shift and go to state 62
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 69

    (140) open_brace -> { .

    BREAK           reduce using rule 140 (open_brace -> { .)
    NEXT            reduce using rule 140 (open_brace -> { .)
    IF              reduce using rule 140 (open_brace -> { .)
    FOR             reduce using rule 140 (open_brace -> { .)
    WHERE           reduce using rule 140 (open_brace -> { .)
    SWITCH          reduce using rule 140 (open_brace -> { .)
    FUNCTION        reduce using rule 140 (open_brace -> { .)
    PRINT           reduce using rule 140 (open_brace -> { .)
    DO              reduce using rule 140 (open_brace -> { .)
    LOOP            reduce using rule 140 (open_brace -> { .)
    WITH            reduce using rule 140 (open_brace -> { .)
    (               reduce using rule 140 (open_brace -> { .)
    [               reduce using rule 140 (open_brace -> { .)
    ID              reduce using rule 140 (open_brace -> { .)
    ITEM_TAG        reduce using rule 140 (open_brace -> { .)
    INTEGER         reduce using rule 140 (open_brace -> { .)
    HEXINT          reduce using rule 140 (open_brace -> { .)
    OCTINT          reduce using rule 140 (open_brace -> { .)
    BININT          reduce using rule 140 (open_brace -> { .)
    REAL            reduce using rule 140 (open_brace -> { .)
    IMAGINARY       reduce using rule 140 (open_brace -> { .)
    STRPREFIX       reduce using rule 140 (open_brace -> { .)
    SHORTSTRING     reduce using rule 140 (open_brace -> { .)
    LONGSTRING      reduce using rule 140 (open_brace -> { .)
    `               reduce using rule 140 (open_brace -> { .)
    CASE            reduce using rule 140 (open_brace -> { .)


state 70

    (153) with_head -> WITH ID . AS ID

    AS              shift and go to state 122


state 71

    (41) m_expr -> u_expr .

    *               reduce using rule 41 (m_expr -> u_expr .)
    /               reduce using rule 41 (m_expr -> u_expr .)
    ^               reduce using rule 41 (m_expr -> u_expr .)
    +               reduce using rule 41 (m_expr -> u_expr .)
    -               reduce using rule 41 (m_expr -> u_expr .)
    <               reduce using rule 41 (m_expr -> u_expr .)
    >               reduce using rule 41 (m_expr -> u_expr .)
    GTE             reduce using rule 41 (m_expr -> u_expr .)
    LTE             reduce using rule 41 (m_expr -> u_expr .)
    NEQ             reduce using rule 41 (m_expr -> u_expr .)
    ISEQUAL         reduce using rule 41 (m_expr -> u_expr .)
    IN              reduce using rule 41 (m_expr -> u_expr .)
    NOT             reduce using rule 41 (m_expr -> u_expr .)
    AND             reduce using rule 41 (m_expr -> u_expr .)
    OR              reduce using rule 41 (m_expr -> u_expr .)
    ;               reduce using rule 41 (m_expr -> u_expr .)
    BREAK           reduce using rule 41 (m_expr -> u_expr .)
    NEXT            reduce using rule 41 (m_expr -> u_expr .)
    IF              reduce using rule 41 (m_expr -> u_expr .)
    FOR             reduce using rule 41 (m_expr -> u_expr .)
    WHERE           reduce using rule 41 (m_expr -> u_expr .)
    SWITCH          reduce using rule 41 (m_expr -> u_expr .)
    FUNCTION        reduce using rule 41 (m_expr -> u_expr .)
    PRINT           reduce using rule 41 (m_expr -> u_expr .)
    DO              reduce using rule 41 (m_expr -> u_expr .)
    LOOP            reduce using rule 41 (m_expr -> u_expr .)
    WITH            reduce using rule 41 (m_expr -> u_expr .)
    (               reduce using rule 41 (m_expr -> u_expr .)
    [               reduce using rule 41 (m_expr -> u_expr .)
    ID              reduce using rule 41 (m_expr -> u_expr .)
    ITEM_TAG        reduce using rule 41 (m_expr -> u_expr .)
    INTEGER         reduce using rule 41 (m_expr -> u_expr .)
    HEXINT          reduce using rule 41 (m_expr -> u_expr .)
    OCTINT          reduce using rule 41 (m_expr -> u_expr .)
    BININT          reduce using rule 41 (m_expr -> u_expr .)
    REAL            reduce using rule 41 (m_expr -> u_expr .)
    IMAGINARY       reduce using rule 41 (m_expr -> u_expr .)
    STRPREFIX       reduce using rule 41 (m_expr -> u_expr .)
    SHORTSTRING     reduce using rule 41 (m_expr -> u_expr .)
    LONGSTRING      reduce using rule 41 (m_expr -> u_expr .)
    `               reduce using rule 41 (m_expr -> u_expr .)
    $end            reduce using rule 41 (m_expr -> u_expr .)
    }               reduce using rule 41 (m_expr -> u_expr .)
    ELSE            reduce using rule 41 (m_expr -> u_expr .)
    DEFAULT         reduce using rule 41 (m_expr -> u_expr .)
    CASE            reduce using rule 41 (m_expr -> u_expr .)
    )               reduce using rule 41 (m_expr -> u_expr .)
    ,               reduce using rule 41 (m_expr -> u_expr .)
    {               reduce using rule 41 (m_expr -> u_expr .)
    ]               reduce using rule 41 (m_expr -> u_expr .)
    :               reduce using rule 41 (m_expr -> u_expr .)


state 72

    (27) not_test -> NOT . not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    not_test                       shift and go to state 123
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 73

    (19) target -> primary .
    (97) subscription -> primary . [ expression_list ]
    (115) call -> primary . ( )
    (116) call -> primary . ( argument_list )
    (94) attributeref -> primary . attribute_tag
    (100) simple_slicing -> primary . [ short_slice ]
    (105) extended_slicing -> primary . [ slice_list ]
    (48) power -> primary .
    (49) power -> primary . POWER u_expr
    (95) attribute_tag -> . . ID
    (96) attribute_tag -> . REAL

  ! reduce/reduce conflict for ) resolved using rule 19 (target -> primary .)
  ! reduce/reduce conflict for , resolved using rule 19 (target -> primary .)
  ! reduce/reduce conflict for ] resolved using rule 19 (target -> primary .)
    )               reduce using rule 19 (target -> primary .)
    ,               reduce using rule 19 (target -> primary .)
    ]               reduce using rule 19 (target -> primary .)
    [               shift and go to state 111
    (               shift and go to state 125
    *               reduce using rule 48 (power -> primary .)
    /               reduce using rule 48 (power -> primary .)
    ^               reduce using rule 48 (power -> primary .)
    +               reduce using rule 48 (power -> primary .)
    -               reduce using rule 48 (power -> primary .)
    <               reduce using rule 48 (power -> primary .)
    >               reduce using rule 48 (power -> primary .)
    GTE             reduce using rule 48 (power -> primary .)
    LTE             reduce using rule 48 (power -> primary .)
    NEQ             reduce using rule 48 (power -> primary .)
    ISEQUAL         reduce using rule 48 (power -> primary .)
    IN              reduce using rule 48 (power -> primary .)
    NOT             reduce using rule 48 (power -> primary .)
    AND             reduce using rule 48 (power -> primary .)
    OR              reduce using rule 48 (power -> primary .)
    FOR             reduce using rule 48 (power -> primary .)
    POWER           shift and go to state 124
    .               shift and go to state 110
    REAL            shift and go to state 107

  ! )               [ reduce using rule 48 (power -> primary .) ]
  ! ,               [ reduce using rule 48 (power -> primary .) ]
  ! ]               [ reduce using rule 48 (power -> primary .) ]

    attribute_tag                  shift and go to state 108

state 74

    (24) and_test -> not_test .

    AND             reduce using rule 24 (and_test -> not_test .)
    OR              reduce using rule 24 (and_test -> not_test .)
    )               reduce using rule 24 (and_test -> not_test .)
    ,               reduce using rule 24 (and_test -> not_test .)
    BREAK           reduce using rule 24 (and_test -> not_test .)
    NEXT            reduce using rule 24 (and_test -> not_test .)
    {               reduce using rule 24 (and_test -> not_test .)
    PRINT           reduce using rule 24 (and_test -> not_test .)
    IF              reduce using rule 24 (and_test -> not_test .)
    FOR             reduce using rule 24 (and_test -> not_test .)
    WHERE           reduce using rule 24 (and_test -> not_test .)
    SWITCH          reduce using rule 24 (and_test -> not_test .)
    FUNCTION        reduce using rule 24 (and_test -> not_test .)
    (               reduce using rule 24 (and_test -> not_test .)
    [               reduce using rule 24 (and_test -> not_test .)
    DO              reduce using rule 24 (and_test -> not_test .)
    LOOP            reduce using rule 24 (and_test -> not_test .)
    WITH            reduce using rule 24 (and_test -> not_test .)
    ID              reduce using rule 24 (and_test -> not_test .)
    ITEM_TAG        reduce using rule 24 (and_test -> not_test .)
    INTEGER         reduce using rule 24 (and_test -> not_test .)
    HEXINT          reduce using rule 24 (and_test -> not_test .)
    OCTINT          reduce using rule 24 (and_test -> not_test .)
    BININT          reduce using rule 24 (and_test -> not_test .)
    REAL            reduce using rule 24 (and_test -> not_test .)
    IMAGINARY       reduce using rule 24 (and_test -> not_test .)
    STRPREFIX       reduce using rule 24 (and_test -> not_test .)
    SHORTSTRING     reduce using rule 24 (and_test -> not_test .)
    LONGSTRING      reduce using rule 24 (and_test -> not_test .)
    `               reduce using rule 24 (and_test -> not_test .)
    ;               reduce using rule 24 (and_test -> not_test .)
    $end            reduce using rule 24 (and_test -> not_test .)
    }               reduce using rule 24 (and_test -> not_test .)
    ELSE            reduce using rule 24 (and_test -> not_test .)
    DEFAULT         reduce using rule 24 (and_test -> not_test .)
    CASE            reduce using rule 24 (and_test -> not_test .)
    ]               reduce using rule 24 (and_test -> not_test .)
    :               reduce using rule 24 (and_test -> not_test .)
    IN              reduce using rule 24 (and_test -> not_test .)


state 75

    (45) u_expr -> power .

    *               reduce using rule 45 (u_expr -> power .)
    /               reduce using rule 45 (u_expr -> power .)
    ^               reduce using rule 45 (u_expr -> power .)
    +               reduce using rule 45 (u_expr -> power .)
    -               reduce using rule 45 (u_expr -> power .)
    <               reduce using rule 45 (u_expr -> power .)
    >               reduce using rule 45 (u_expr -> power .)
    GTE             reduce using rule 45 (u_expr -> power .)
    LTE             reduce using rule 45 (u_expr -> power .)
    NEQ             reduce using rule 45 (u_expr -> power .)
    ISEQUAL         reduce using rule 45 (u_expr -> power .)
    IN              reduce using rule 45 (u_expr -> power .)
    NOT             reduce using rule 45 (u_expr -> power .)
    AND             reduce using rule 45 (u_expr -> power .)
    OR              reduce using rule 45 (u_expr -> power .)
    ,               reduce using rule 45 (u_expr -> power .)
    FOR             reduce using rule 45 (u_expr -> power .)
    ]               reduce using rule 45 (u_expr -> power .)
    )               reduce using rule 45 (u_expr -> power .)
    `               reduce using rule 45 (u_expr -> power .)
    ;               reduce using rule 45 (u_expr -> power .)
    BREAK           reduce using rule 45 (u_expr -> power .)
    NEXT            reduce using rule 45 (u_expr -> power .)
    IF              reduce using rule 45 (u_expr -> power .)
    WHERE           reduce using rule 45 (u_expr -> power .)
    SWITCH          reduce using rule 45 (u_expr -> power .)
    FUNCTION        reduce using rule 45 (u_expr -> power .)
    PRINT           reduce using rule 45 (u_expr -> power .)
    DO              reduce using rule 45 (u_expr -> power .)
    LOOP            reduce using rule 45 (u_expr -> power .)
    WITH            reduce using rule 45 (u_expr -> power .)
    (               reduce using rule 45 (u_expr -> power .)
    [               reduce using rule 45 (u_expr -> power .)
    ID              reduce using rule 45 (u_expr -> power .)
    ITEM_TAG        reduce using rule 45 (u_expr -> power .)
    INTEGER         reduce using rule 45 (u_expr -> power .)
    HEXINT          reduce using rule 45 (u_expr -> power .)
    OCTINT          reduce using rule 45 (u_expr -> power .)
    BININT          reduce using rule 45 (u_expr -> power .)
    REAL            reduce using rule 45 (u_expr -> power .)
    IMAGINARY       reduce using rule 45 (u_expr -> power .)
    STRPREFIX       reduce using rule 45 (u_expr -> power .)
    SHORTSTRING     reduce using rule 45 (u_expr -> power .)
    LONGSTRING      reduce using rule 45 (u_expr -> power .)
    $end            reduce using rule 45 (u_expr -> power .)
    }               reduce using rule 45 (u_expr -> power .)
    ELSE            reduce using rule 45 (u_expr -> power .)
    DEFAULT         reduce using rule 45 (u_expr -> power .)
    CASE            reduce using rule 45 (u_expr -> power .)
    {               reduce using rule 45 (u_expr -> power .)
    :               reduce using rule 45 (u_expr -> power .)


state 76

    (76) parenth_form -> ( ) .

    POWER           reduce using rule 76 (parenth_form -> ( ) .)
    [               reduce using rule 76 (parenth_form -> ( ) .)
    (               reduce using rule 76 (parenth_form -> ( ) .)
    .               reduce using rule 76 (parenth_form -> ( ) .)
    REAL            reduce using rule 76 (parenth_form -> ( ) .)
    *               reduce using rule 76 (parenth_form -> ( ) .)
    /               reduce using rule 76 (parenth_form -> ( ) .)
    ^               reduce using rule 76 (parenth_form -> ( ) .)
    +               reduce using rule 76 (parenth_form -> ( ) .)
    -               reduce using rule 76 (parenth_form -> ( ) .)
    <               reduce using rule 76 (parenth_form -> ( ) .)
    >               reduce using rule 76 (parenth_form -> ( ) .)
    GTE             reduce using rule 76 (parenth_form -> ( ) .)
    LTE             reduce using rule 76 (parenth_form -> ( ) .)
    NEQ             reduce using rule 76 (parenth_form -> ( ) .)
    ISEQUAL         reduce using rule 76 (parenth_form -> ( ) .)
    IN              reduce using rule 76 (parenth_form -> ( ) .)
    NOT             reduce using rule 76 (parenth_form -> ( ) .)
    AND             reduce using rule 76 (parenth_form -> ( ) .)
    OR              reduce using rule 76 (parenth_form -> ( ) .)
    ]               reduce using rule 76 (parenth_form -> ( ) .)
    :               reduce using rule 76 (parenth_form -> ( ) .)
    ,               reduce using rule 76 (parenth_form -> ( ) .)
    )               reduce using rule 76 (parenth_form -> ( ) .)
    BREAK           reduce using rule 76 (parenth_form -> ( ) .)
    NEXT            reduce using rule 76 (parenth_form -> ( ) .)
    {               reduce using rule 76 (parenth_form -> ( ) .)
    PRINT           reduce using rule 76 (parenth_form -> ( ) .)
    IF              reduce using rule 76 (parenth_form -> ( ) .)
    FOR             reduce using rule 76 (parenth_form -> ( ) .)
    WHERE           reduce using rule 76 (parenth_form -> ( ) .)
    SWITCH          reduce using rule 76 (parenth_form -> ( ) .)
    FUNCTION        reduce using rule 76 (parenth_form -> ( ) .)
    DO              reduce using rule 76 (parenth_form -> ( ) .)
    LOOP            reduce using rule 76 (parenth_form -> ( ) .)
    WITH            reduce using rule 76 (parenth_form -> ( ) .)
    ID              reduce using rule 76 (parenth_form -> ( ) .)
    ITEM_TAG        reduce using rule 76 (parenth_form -> ( ) .)
    INTEGER         reduce using rule 76 (parenth_form -> ( ) .)
    HEXINT          reduce using rule 76 (parenth_form -> ( ) .)
    OCTINT          reduce using rule 76 (parenth_form -> ( ) .)
    BININT          reduce using rule 76 (parenth_form -> ( ) .)
    IMAGINARY       reduce using rule 76 (parenth_form -> ( ) .)
    STRPREFIX       reduce using rule 76 (parenth_form -> ( ) .)
    SHORTSTRING     reduce using rule 76 (parenth_form -> ( ) .)
    LONGSTRING      reduce using rule 76 (parenth_form -> ( ) .)
    `               reduce using rule 76 (parenth_form -> ( ) .)
    ;               reduce using rule 76 (parenth_form -> ( ) .)
    $end            reduce using rule 76 (parenth_form -> ( ) .)
    }               reduce using rule 76 (parenth_form -> ( ) .)
    ELSE            reduce using rule 76 (parenth_form -> ( ) .)
    DEFAULT         reduce using rule 76 (parenth_form -> ( ) .)
    CASE            reduce using rule 76 (parenth_form -> ( ) .)
    AUGOP           reduce using rule 76 (parenth_form -> ( ) .)
    =               reduce using rule 76 (parenth_form -> ( ) .)


state 77

    (47) u_expr -> + . u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 126
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 78

    (28) comparison -> a_expr .
    (29) comparison -> a_expr . comp_operator a_expr
    (39) a_expr -> a_expr . + m_expr
    (40) a_expr -> a_expr . - m_expr
    (30) comp_operator -> . <
    (31) comp_operator -> . >
    (32) comp_operator -> . GTE
    (33) comp_operator -> . LTE
    (34) comp_operator -> . NEQ
    (35) comp_operator -> . ISEQUAL
    (36) comp_operator -> . IN
    (37) comp_operator -> . NOT IN

  ! shift/reduce conflict for IN resolved as shift
    AND             reduce using rule 28 (comparison -> a_expr .)
    OR              reduce using rule 28 (comparison -> a_expr .)
    )               reduce using rule 28 (comparison -> a_expr .)
    ,               reduce using rule 28 (comparison -> a_expr .)
    ]               reduce using rule 28 (comparison -> a_expr .)
    FOR             reduce using rule 28 (comparison -> a_expr .)
    IF              reduce using rule 28 (comparison -> a_expr .)
    ;               reduce using rule 28 (comparison -> a_expr .)
    BREAK           reduce using rule 28 (comparison -> a_expr .)
    NEXT            reduce using rule 28 (comparison -> a_expr .)
    WHERE           reduce using rule 28 (comparison -> a_expr .)
    SWITCH          reduce using rule 28 (comparison -> a_expr .)
    FUNCTION        reduce using rule 28 (comparison -> a_expr .)
    PRINT           reduce using rule 28 (comparison -> a_expr .)
    DO              reduce using rule 28 (comparison -> a_expr .)
    LOOP            reduce using rule 28 (comparison -> a_expr .)
    WITH            reduce using rule 28 (comparison -> a_expr .)
    (               reduce using rule 28 (comparison -> a_expr .)
    [               reduce using rule 28 (comparison -> a_expr .)
    ID              reduce using rule 28 (comparison -> a_expr .)
    ITEM_TAG        reduce using rule 28 (comparison -> a_expr .)
    INTEGER         reduce using rule 28 (comparison -> a_expr .)
    HEXINT          reduce using rule 28 (comparison -> a_expr .)
    OCTINT          reduce using rule 28 (comparison -> a_expr .)
    BININT          reduce using rule 28 (comparison -> a_expr .)
    REAL            reduce using rule 28 (comparison -> a_expr .)
    IMAGINARY       reduce using rule 28 (comparison -> a_expr .)
    STRPREFIX       reduce using rule 28 (comparison -> a_expr .)
    SHORTSTRING     reduce using rule 28 (comparison -> a_expr .)
    LONGSTRING      reduce using rule 28 (comparison -> a_expr .)
    `               reduce using rule 28 (comparison -> a_expr .)
    $end            reduce using rule 28 (comparison -> a_expr .)
    }               reduce using rule 28 (comparison -> a_expr .)
    ELSE            reduce using rule 28 (comparison -> a_expr .)
    DEFAULT         reduce using rule 28 (comparison -> a_expr .)
    CASE            reduce using rule 28 (comparison -> a_expr .)
    {               reduce using rule 28 (comparison -> a_expr .)
    :               reduce using rule 28 (comparison -> a_expr .)
    +               shift and go to state 129
    -               shift and go to state 131
    <               shift and go to state 136
    >               shift and go to state 137
    GTE             shift and go to state 132
    LTE             shift and go to state 127
    NEQ             shift and go to state 135
    ISEQUAL         shift and go to state 133
    IN              shift and go to state 130
    NOT             shift and go to state 134

  ! IN              [ reduce using rule 28 (comparison -> a_expr .) ]

    comp_operator                  shift and go to state 128

state 79

    (46) u_expr -> - . u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 138
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 80

    (22) or_test -> and_test .
    (25) and_test -> and_test . AND not_test

    ,               reduce using rule 22 (or_test -> and_test .)
    OR              reduce using rule 22 (or_test -> and_test .)
    FOR             reduce using rule 22 (or_test -> and_test .)
    IF              reduce using rule 22 (or_test -> and_test .)
    ]               reduce using rule 22 (or_test -> and_test .)
    :               reduce using rule 22 (or_test -> and_test .)
    IN              reduce using rule 22 (or_test -> and_test .)
    ;               reduce using rule 22 (or_test -> and_test .)
    BREAK           reduce using rule 22 (or_test -> and_test .)
    NEXT            reduce using rule 22 (or_test -> and_test .)
    WHERE           reduce using rule 22 (or_test -> and_test .)
    SWITCH          reduce using rule 22 (or_test -> and_test .)
    FUNCTION        reduce using rule 22 (or_test -> and_test .)
    PRINT           reduce using rule 22 (or_test -> and_test .)
    DO              reduce using rule 22 (or_test -> and_test .)
    LOOP            reduce using rule 22 (or_test -> and_test .)
    WITH            reduce using rule 22 (or_test -> and_test .)
    (               reduce using rule 22 (or_test -> and_test .)
    [               reduce using rule 22 (or_test -> and_test .)
    ID              reduce using rule 22 (or_test -> and_test .)
    ITEM_TAG        reduce using rule 22 (or_test -> and_test .)
    INTEGER         reduce using rule 22 (or_test -> and_test .)
    HEXINT          reduce using rule 22 (or_test -> and_test .)
    OCTINT          reduce using rule 22 (or_test -> and_test .)
    BININT          reduce using rule 22 (or_test -> and_test .)
    REAL            reduce using rule 22 (or_test -> and_test .)
    IMAGINARY       reduce using rule 22 (or_test -> and_test .)
    STRPREFIX       reduce using rule 22 (or_test -> and_test .)
    SHORTSTRING     reduce using rule 22 (or_test -> and_test .)
    LONGSTRING      reduce using rule 22 (or_test -> and_test .)
    `               reduce using rule 22 (or_test -> and_test .)
    $end            reduce using rule 22 (or_test -> and_test .)
    }               reduce using rule 22 (or_test -> and_test .)
    ELSE            reduce using rule 22 (or_test -> and_test .)
    DEFAULT         reduce using rule 22 (or_test -> and_test .)
    CASE            reduce using rule 22 (or_test -> and_test .)
    )               reduce using rule 22 (or_test -> and_test .)
    {               reduce using rule 22 (or_test -> and_test .)
    AND             shift and go to state 139


state 81

    (20) target -> ( target_list . )
    (126) target_list -> target_list . , target

    )               shift and go to state 140
    ,               shift and go to state 119


state 82

    (38) a_expr -> m_expr .
    (42) m_expr -> m_expr . * u_expr
    (43) m_expr -> m_expr . / u_expr
    (44) m_expr -> m_expr . ^ u_expr

    +               reduce using rule 38 (a_expr -> m_expr .)
    -               reduce using rule 38 (a_expr -> m_expr .)
    <               reduce using rule 38 (a_expr -> m_expr .)
    >               reduce using rule 38 (a_expr -> m_expr .)
    GTE             reduce using rule 38 (a_expr -> m_expr .)
    LTE             reduce using rule 38 (a_expr -> m_expr .)
    NEQ             reduce using rule 38 (a_expr -> m_expr .)
    ISEQUAL         reduce using rule 38 (a_expr -> m_expr .)
    IN              reduce using rule 38 (a_expr -> m_expr .)
    NOT             reduce using rule 38 (a_expr -> m_expr .)
    AND             reduce using rule 38 (a_expr -> m_expr .)
    OR              reduce using rule 38 (a_expr -> m_expr .)
    )               reduce using rule 38 (a_expr -> m_expr .)
    ,               reduce using rule 38 (a_expr -> m_expr .)
    BREAK           reduce using rule 38 (a_expr -> m_expr .)
    NEXT            reduce using rule 38 (a_expr -> m_expr .)
    {               reduce using rule 38 (a_expr -> m_expr .)
    PRINT           reduce using rule 38 (a_expr -> m_expr .)
    IF              reduce using rule 38 (a_expr -> m_expr .)
    FOR             reduce using rule 38 (a_expr -> m_expr .)
    WHERE           reduce using rule 38 (a_expr -> m_expr .)
    SWITCH          reduce using rule 38 (a_expr -> m_expr .)
    FUNCTION        reduce using rule 38 (a_expr -> m_expr .)
    (               reduce using rule 38 (a_expr -> m_expr .)
    [               reduce using rule 38 (a_expr -> m_expr .)
    DO              reduce using rule 38 (a_expr -> m_expr .)
    LOOP            reduce using rule 38 (a_expr -> m_expr .)
    WITH            reduce using rule 38 (a_expr -> m_expr .)
    ID              reduce using rule 38 (a_expr -> m_expr .)
    ITEM_TAG        reduce using rule 38 (a_expr -> m_expr .)
    INTEGER         reduce using rule 38 (a_expr -> m_expr .)
    HEXINT          reduce using rule 38 (a_expr -> m_expr .)
    OCTINT          reduce using rule 38 (a_expr -> m_expr .)
    BININT          reduce using rule 38 (a_expr -> m_expr .)
    REAL            reduce using rule 38 (a_expr -> m_expr .)
    IMAGINARY       reduce using rule 38 (a_expr -> m_expr .)
    STRPREFIX       reduce using rule 38 (a_expr -> m_expr .)
    SHORTSTRING     reduce using rule 38 (a_expr -> m_expr .)
    LONGSTRING      reduce using rule 38 (a_expr -> m_expr .)
    `               reduce using rule 38 (a_expr -> m_expr .)
    ;               reduce using rule 38 (a_expr -> m_expr .)
    $end            reduce using rule 38 (a_expr -> m_expr .)
    }               reduce using rule 38 (a_expr -> m_expr .)
    ELSE            reduce using rule 38 (a_expr -> m_expr .)
    DEFAULT         reduce using rule 38 (a_expr -> m_expr .)
    CASE            reduce using rule 38 (a_expr -> m_expr .)
    ]               reduce using rule 38 (a_expr -> m_expr .)
    :               reduce using rule 38 (a_expr -> m_expr .)
    *               shift and go to state 141
    /               shift and go to state 142
    ^               shift and go to state 143


state 83

    (26) not_test -> comparison .

    AND             reduce using rule 26 (not_test -> comparison .)
    OR              reduce using rule 26 (not_test -> comparison .)
    )               reduce using rule 26 (not_test -> comparison .)
    ,               reduce using rule 26 (not_test -> comparison .)
    :               reduce using rule 26 (not_test -> comparison .)
    ]               reduce using rule 26 (not_test -> comparison .)
    FOR             reduce using rule 26 (not_test -> comparison .)
    IF              reduce using rule 26 (not_test -> comparison .)
    BREAK           reduce using rule 26 (not_test -> comparison .)
    NEXT            reduce using rule 26 (not_test -> comparison .)
    {               reduce using rule 26 (not_test -> comparison .)
    PRINT           reduce using rule 26 (not_test -> comparison .)
    WHERE           reduce using rule 26 (not_test -> comparison .)
    SWITCH          reduce using rule 26 (not_test -> comparison .)
    FUNCTION        reduce using rule 26 (not_test -> comparison .)
    (               reduce using rule 26 (not_test -> comparison .)
    [               reduce using rule 26 (not_test -> comparison .)
    DO              reduce using rule 26 (not_test -> comparison .)
    LOOP            reduce using rule 26 (not_test -> comparison .)
    WITH            reduce using rule 26 (not_test -> comparison .)
    ID              reduce using rule 26 (not_test -> comparison .)
    ITEM_TAG        reduce using rule 26 (not_test -> comparison .)
    INTEGER         reduce using rule 26 (not_test -> comparison .)
    HEXINT          reduce using rule 26 (not_test -> comparison .)
    OCTINT          reduce using rule 26 (not_test -> comparison .)
    BININT          reduce using rule 26 (not_test -> comparison .)
    REAL            reduce using rule 26 (not_test -> comparison .)
    IMAGINARY       reduce using rule 26 (not_test -> comparison .)
    STRPREFIX       reduce using rule 26 (not_test -> comparison .)
    SHORTSTRING     reduce using rule 26 (not_test -> comparison .)
    LONGSTRING      reduce using rule 26 (not_test -> comparison .)
    `               reduce using rule 26 (not_test -> comparison .)
    ;               reduce using rule 26 (not_test -> comparison .)
    $end            reduce using rule 26 (not_test -> comparison .)
    }               reduce using rule 26 (not_test -> comparison .)
    ELSE            reduce using rule 26 (not_test -> comparison .)
    DEFAULT         reduce using rule 26 (not_test -> comparison .)
    CASE            reduce using rule 26 (not_test -> comparison .)
    IN              reduce using rule 26 (not_test -> comparison .)


state 84

    (125) target_list -> target .

    )               reduce using rule 125 (target_list -> target .)
    ,               reduce using rule 125 (target_list -> target .)
    BREAK           reduce using rule 125 (target_list -> target .)
    NEXT            reduce using rule 125 (target_list -> target .)
    {               reduce using rule 125 (target_list -> target .)
    PRINT           reduce using rule 125 (target_list -> target .)
    IF              reduce using rule 125 (target_list -> target .)
    FOR             reduce using rule 125 (target_list -> target .)
    WHERE           reduce using rule 125 (target_list -> target .)
    SWITCH          reduce using rule 125 (target_list -> target .)
    FUNCTION        reduce using rule 125 (target_list -> target .)
    (               reduce using rule 125 (target_list -> target .)
    [               reduce using rule 125 (target_list -> target .)
    DO              reduce using rule 125 (target_list -> target .)
    LOOP            reduce using rule 125 (target_list -> target .)
    WITH            reduce using rule 125 (target_list -> target .)
    ID              reduce using rule 125 (target_list -> target .)
    ITEM_TAG        reduce using rule 125 (target_list -> target .)
    INTEGER         reduce using rule 125 (target_list -> target .)
    HEXINT          reduce using rule 125 (target_list -> target .)
    OCTINT          reduce using rule 125 (target_list -> target .)
    BININT          reduce using rule 125 (target_list -> target .)
    REAL            reduce using rule 125 (target_list -> target .)
    IMAGINARY       reduce using rule 125 (target_list -> target .)
    STRPREFIX       reduce using rule 125 (target_list -> target .)
    SHORTSTRING     reduce using rule 125 (target_list -> target .)
    LONGSTRING      reduce using rule 125 (target_list -> target .)
    `               reduce using rule 125 (target_list -> target .)
    ]               reduce using rule 125 (target_list -> target .)
    IN              reduce using rule 125 (target_list -> target .)


state 85

    (75) parenth_form -> ( expression_list . )
    (17) expression_list -> expression_list . , expression

    )               shift and go to state 144
    ,               shift and go to state 145


state 86

    (18) expression -> or_test .
    (23) or_test -> or_test . OR and_test

    )               reduce using rule 18 (expression -> or_test .)
    ,               reduce using rule 18 (expression -> or_test .)
    ;               reduce using rule 18 (expression -> or_test .)
    BREAK           reduce using rule 18 (expression -> or_test .)
    NEXT            reduce using rule 18 (expression -> or_test .)
    IF              reduce using rule 18 (expression -> or_test .)
    FOR             reduce using rule 18 (expression -> or_test .)
    WHERE           reduce using rule 18 (expression -> or_test .)
    SWITCH          reduce using rule 18 (expression -> or_test .)
    FUNCTION        reduce using rule 18 (expression -> or_test .)
    PRINT           reduce using rule 18 (expression -> or_test .)
    DO              reduce using rule 18 (expression -> or_test .)
    LOOP            reduce using rule 18 (expression -> or_test .)
    WITH            reduce using rule 18 (expression -> or_test .)
    (               reduce using rule 18 (expression -> or_test .)
    [               reduce using rule 18 (expression -> or_test .)
    ID              reduce using rule 18 (expression -> or_test .)
    ITEM_TAG        reduce using rule 18 (expression -> or_test .)
    INTEGER         reduce using rule 18 (expression -> or_test .)
    HEXINT          reduce using rule 18 (expression -> or_test .)
    OCTINT          reduce using rule 18 (expression -> or_test .)
    BININT          reduce using rule 18 (expression -> or_test .)
    REAL            reduce using rule 18 (expression -> or_test .)
    IMAGINARY       reduce using rule 18 (expression -> or_test .)
    STRPREFIX       reduce using rule 18 (expression -> or_test .)
    SHORTSTRING     reduce using rule 18 (expression -> or_test .)
    LONGSTRING      reduce using rule 18 (expression -> or_test .)
    `               reduce using rule 18 (expression -> or_test .)
    $end            reduce using rule 18 (expression -> or_test .)
    }               reduce using rule 18 (expression -> or_test .)
    ELSE            reduce using rule 18 (expression -> or_test .)
    DEFAULT         reduce using rule 18 (expression -> or_test .)
    CASE            reduce using rule 18 (expression -> or_test .)
    {               reduce using rule 18 (expression -> or_test .)
    ]               reduce using rule 18 (expression -> or_test .)
    :               reduce using rule 18 (expression -> or_test .)
    IN              reduce using rule 18 (expression -> or_test .)
    OR              shift and go to state 146


state 87

    (16) expression_list -> expression .

    )               reduce using rule 16 (expression_list -> expression .)
    ,               reduce using rule 16 (expression_list -> expression .)
    `               reduce using rule 16 (expression_list -> expression .)
    IN              reduce using rule 16 (expression_list -> expression .)
    ;               reduce using rule 16 (expression_list -> expression .)
    BREAK           reduce using rule 16 (expression_list -> expression .)
    NEXT            reduce using rule 16 (expression_list -> expression .)
    IF              reduce using rule 16 (expression_list -> expression .)
    FOR             reduce using rule 16 (expression_list -> expression .)
    WHERE           reduce using rule 16 (expression_list -> expression .)
    SWITCH          reduce using rule 16 (expression_list -> expression .)
    FUNCTION        reduce using rule 16 (expression_list -> expression .)
    PRINT           reduce using rule 16 (expression_list -> expression .)
    DO              reduce using rule 16 (expression_list -> expression .)
    LOOP            reduce using rule 16 (expression_list -> expression .)
    WITH            reduce using rule 16 (expression_list -> expression .)
    (               reduce using rule 16 (expression_list -> expression .)
    [               reduce using rule 16 (expression_list -> expression .)
    ID              reduce using rule 16 (expression_list -> expression .)
    ITEM_TAG        reduce using rule 16 (expression_list -> expression .)
    INTEGER         reduce using rule 16 (expression_list -> expression .)
    HEXINT          reduce using rule 16 (expression_list -> expression .)
    OCTINT          reduce using rule 16 (expression_list -> expression .)
    BININT          reduce using rule 16 (expression_list -> expression .)
    REAL            reduce using rule 16 (expression_list -> expression .)
    IMAGINARY       reduce using rule 16 (expression_list -> expression .)
    STRPREFIX       reduce using rule 16 (expression_list -> expression .)
    SHORTSTRING     reduce using rule 16 (expression_list -> expression .)
    LONGSTRING      reduce using rule 16 (expression_list -> expression .)
    $end            reduce using rule 16 (expression_list -> expression .)
    }               reduce using rule 16 (expression_list -> expression .)
    ELSE            reduce using rule 16 (expression_list -> expression .)
    DEFAULT         reduce using rule 16 (expression_list -> expression .)
    CASE            reduce using rule 16 (expression_list -> expression .)
    {               reduce using rule 16 (expression_list -> expression .)


state 88

    (68) stringliteral -> STRPREFIX SHORTSTRING .

    POWER           reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    [               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    (               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    .               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    REAL            reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    *               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    /               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ^               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    +               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    -               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    <               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    >               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    GTE             reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    LTE             reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    NEQ             reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ISEQUAL         reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    IN              reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    NOT             reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    AND             reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    OR              reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    )               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ,               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    BREAK           reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    NEXT            reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    {               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    PRINT           reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    IF              reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    FOR             reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    WHERE           reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    SWITCH          reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    FUNCTION        reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    DO              reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    LOOP            reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    WITH            reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ID              reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ITEM_TAG        reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    INTEGER         reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    HEXINT          reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    OCTINT          reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    BININT          reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    IMAGINARY       reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    STRPREFIX       reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    SHORTSTRING     reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    LONGSTRING      reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    `               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ;               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    $end            reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    }               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ELSE            reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    DEFAULT         reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    CASE            reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    ]               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    :               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    AUGOP           reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)
    =               reduce using rule 68 (stringliteral -> STRPREFIX SHORTSTRING .)


state 89

    (69) stringliteral -> STRPREFIX LONGSTRING .

    POWER           reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    [               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    (               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    .               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    REAL            reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    *               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    /               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ^               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    +               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    -               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    <               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    >               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    GTE             reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    LTE             reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    NEQ             reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ISEQUAL         reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    IN              reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    NOT             reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    AND             reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    OR              reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    )               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ,               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    BREAK           reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    NEXT            reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    {               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    PRINT           reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    IF              reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    FOR             reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    WHERE           reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    SWITCH          reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    FUNCTION        reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    DO              reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    LOOP            reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    WITH            reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ID              reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ITEM_TAG        reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    INTEGER         reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    HEXINT          reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    OCTINT          reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    BININT          reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    IMAGINARY       reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    STRPREFIX       reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    SHORTSTRING     reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    LONGSTRING      reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    `               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ;               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    $end            reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    }               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ELSE            reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    DEFAULT         reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    CASE            reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    ]               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    :               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    AUGOP           reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)
    =               reduce using rule 69 (stringliteral -> STRPREFIX LONGSTRING .)


state 90

    (3) input -> input statement .

    BREAK           reduce using rule 3 (input -> input statement .)
    NEXT            reduce using rule 3 (input -> input statement .)
    IF              reduce using rule 3 (input -> input statement .)
    FOR             reduce using rule 3 (input -> input statement .)
    WHERE           reduce using rule 3 (input -> input statement .)
    SWITCH          reduce using rule 3 (input -> input statement .)
    FUNCTION        reduce using rule 3 (input -> input statement .)
    PRINT           reduce using rule 3 (input -> input statement .)
    DO              reduce using rule 3 (input -> input statement .)
    LOOP            reduce using rule 3 (input -> input statement .)
    WITH            reduce using rule 3 (input -> input statement .)
    (               reduce using rule 3 (input -> input statement .)
    [               reduce using rule 3 (input -> input statement .)
    ID              reduce using rule 3 (input -> input statement .)
    ITEM_TAG        reduce using rule 3 (input -> input statement .)
    INTEGER         reduce using rule 3 (input -> input statement .)
    HEXINT          reduce using rule 3 (input -> input statement .)
    OCTINT          reduce using rule 3 (input -> input statement .)
    BININT          reduce using rule 3 (input -> input statement .)
    REAL            reduce using rule 3 (input -> input statement .)
    IMAGINARY       reduce using rule 3 (input -> input statement .)
    STRPREFIX       reduce using rule 3 (input -> input statement .)
    SHORTSTRING     reduce using rule 3 (input -> input statement .)
    LONGSTRING      reduce using rule 3 (input -> input statement .)
    `               reduce using rule 3 (input -> input statement .)
    $end            reduce using rule 3 (input -> input statement .)


state 91

    (145) loop_stmt -> loop_head suite .

    BREAK           reduce using rule 145 (loop_stmt -> loop_head suite .)
    NEXT            reduce using rule 145 (loop_stmt -> loop_head suite .)
    IF              reduce using rule 145 (loop_stmt -> loop_head suite .)
    FOR             reduce using rule 145 (loop_stmt -> loop_head suite .)
    WHERE           reduce using rule 145 (loop_stmt -> loop_head suite .)
    SWITCH          reduce using rule 145 (loop_stmt -> loop_head suite .)
    FUNCTION        reduce using rule 145 (loop_stmt -> loop_head suite .)
    PRINT           reduce using rule 145 (loop_stmt -> loop_head suite .)
    DO              reduce using rule 145 (loop_stmt -> loop_head suite .)
    LOOP            reduce using rule 145 (loop_stmt -> loop_head suite .)
    WITH            reduce using rule 145 (loop_stmt -> loop_head suite .)
    (               reduce using rule 145 (loop_stmt -> loop_head suite .)
    [               reduce using rule 145 (loop_stmt -> loop_head suite .)
    ID              reduce using rule 145 (loop_stmt -> loop_head suite .)
    ITEM_TAG        reduce using rule 145 (loop_stmt -> loop_head suite .)
    INTEGER         reduce using rule 145 (loop_stmt -> loop_head suite .)
    HEXINT          reduce using rule 145 (loop_stmt -> loop_head suite .)
    OCTINT          reduce using rule 145 (loop_stmt -> loop_head suite .)
    BININT          reduce using rule 145 (loop_stmt -> loop_head suite .)
    REAL            reduce using rule 145 (loop_stmt -> loop_head suite .)
    IMAGINARY       reduce using rule 145 (loop_stmt -> loop_head suite .)
    STRPREFIX       reduce using rule 145 (loop_stmt -> loop_head suite .)
    SHORTSTRING     reduce using rule 145 (loop_stmt -> loop_head suite .)
    LONGSTRING      reduce using rule 145 (loop_stmt -> loop_head suite .)
    `               reduce using rule 145 (loop_stmt -> loop_head suite .)
    $end            reduce using rule 145 (loop_stmt -> loop_head suite .)
    }               reduce using rule 145 (loop_stmt -> loop_head suite .)
    ELSE            reduce using rule 145 (loop_stmt -> loop_head suite .)
    DEFAULT         reduce using rule 145 (loop_stmt -> loop_head suite .)
    CASE            reduce using rule 145 (loop_stmt -> loop_head suite .)


state 92

    (48) power -> primary .
    (49) power -> primary . POWER u_expr
    (97) subscription -> primary . [ expression_list ]
    (115) call -> primary . ( )
    (116) call -> primary . ( argument_list )
    (94) attributeref -> primary . attribute_tag
    (100) simple_slicing -> primary . [ short_slice ]
    (105) extended_slicing -> primary . [ slice_list ]
    (95) attribute_tag -> . . ID
    (96) attribute_tag -> . REAL

  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
    *               reduce using rule 48 (power -> primary .)
    /               reduce using rule 48 (power -> primary .)
    ^               reduce using rule 48 (power -> primary .)
    +               reduce using rule 48 (power -> primary .)
    -               reduce using rule 48 (power -> primary .)
    <               reduce using rule 48 (power -> primary .)
    >               reduce using rule 48 (power -> primary .)
    GTE             reduce using rule 48 (power -> primary .)
    LTE             reduce using rule 48 (power -> primary .)
    NEQ             reduce using rule 48 (power -> primary .)
    ISEQUAL         reduce using rule 48 (power -> primary .)
    IN              reduce using rule 48 (power -> primary .)
    NOT             reduce using rule 48 (power -> primary .)
    AND             reduce using rule 48 (power -> primary .)
    OR              reduce using rule 48 (power -> primary .)
    )               reduce using rule 48 (power -> primary .)
    ,               reduce using rule 48 (power -> primary .)
    BREAK           reduce using rule 48 (power -> primary .)
    NEXT            reduce using rule 48 (power -> primary .)
    {               reduce using rule 48 (power -> primary .)
    PRINT           reduce using rule 48 (power -> primary .)
    IF              reduce using rule 48 (power -> primary .)
    FOR             reduce using rule 48 (power -> primary .)
    WHERE           reduce using rule 48 (power -> primary .)
    SWITCH          reduce using rule 48 (power -> primary .)
    FUNCTION        reduce using rule 48 (power -> primary .)
    DO              reduce using rule 48 (power -> primary .)
    LOOP            reduce using rule 48 (power -> primary .)
    WITH            reduce using rule 48 (power -> primary .)
    ID              reduce using rule 48 (power -> primary .)
    ITEM_TAG        reduce using rule 48 (power -> primary .)
    INTEGER         reduce using rule 48 (power -> primary .)
    HEXINT          reduce using rule 48 (power -> primary .)
    OCTINT          reduce using rule 48 (power -> primary .)
    BININT          reduce using rule 48 (power -> primary .)
    IMAGINARY       reduce using rule 48 (power -> primary .)
    STRPREFIX       reduce using rule 48 (power -> primary .)
    SHORTSTRING     reduce using rule 48 (power -> primary .)
    LONGSTRING      reduce using rule 48 (power -> primary .)
    `               reduce using rule 48 (power -> primary .)
    ;               reduce using rule 48 (power -> primary .)
    $end            reduce using rule 48 (power -> primary .)
    }               reduce using rule 48 (power -> primary .)
    ELSE            reduce using rule 48 (power -> primary .)
    DEFAULT         reduce using rule 48 (power -> primary .)
    CASE            reduce using rule 48 (power -> primary .)
    ]               reduce using rule 48 (power -> primary .)
    :               reduce using rule 48 (power -> primary .)
    POWER           shift and go to state 124
    [               shift and go to state 111
    (               shift and go to state 125
    .               shift and go to state 110
    REAL            shift and go to state 107

  ! (               [ reduce using rule 48 (power -> primary .) ]
  ! [               [ reduce using rule 48 (power -> primary .) ]
  ! REAL            [ reduce using rule 48 (power -> primary .) ]

    attribute_tag                  shift and go to state 108

state 93

    (78) list_display -> [ . listmaker ]
    (79) list_display -> [ . ]
    (80) listmaker -> . expression listmaker2
    (81) listmaker -> . expression list_for
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    ]               shift and go to state 105
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    listmaker                      shift and go to state 103
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 106

state 94

    (75) parenth_form -> ( . expression_list )
    (76) parenth_form -> ( . )
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    )               shift and go to state 76
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    expression_list                shift and go to state 85
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 87

state 95

    (154) where_stmt -> WHERE expression . suite ELSE suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 147
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 96

    (77) string_conversion -> ` expression_list . `
    (17) expression_list -> expression_list . , expression

    `               shift and go to state 148
    ,               shift and go to state 145


state 97

    (136) if_stmt -> if_stmt ELSE . suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 149
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 98

    (146) loop_head -> LOOP ID . AS ID
    (147) loop_head -> LOOP ID . AS ID : ID
    (148) loop_head -> LOOP ID . AS ID : ID comp_operator ID

    AS              shift and go to state 150


state 99

    (15) print_stmt -> PRINT expression .

    ;               reduce using rule 15 (print_stmt -> PRINT expression .)
    }               reduce using rule 15 (print_stmt -> PRINT expression .)
    BREAK           reduce using rule 15 (print_stmt -> PRINT expression .)
    NEXT            reduce using rule 15 (print_stmt -> PRINT expression .)
    IF              reduce using rule 15 (print_stmt -> PRINT expression .)
    FOR             reduce using rule 15 (print_stmt -> PRINT expression .)
    WHERE           reduce using rule 15 (print_stmt -> PRINT expression .)
    SWITCH          reduce using rule 15 (print_stmt -> PRINT expression .)
    FUNCTION        reduce using rule 15 (print_stmt -> PRINT expression .)
    PRINT           reduce using rule 15 (print_stmt -> PRINT expression .)
    DO              reduce using rule 15 (print_stmt -> PRINT expression .)
    LOOP            reduce using rule 15 (print_stmt -> PRINT expression .)
    WITH            reduce using rule 15 (print_stmt -> PRINT expression .)
    (               reduce using rule 15 (print_stmt -> PRINT expression .)
    [               reduce using rule 15 (print_stmt -> PRINT expression .)
    ID              reduce using rule 15 (print_stmt -> PRINT expression .)
    ITEM_TAG        reduce using rule 15 (print_stmt -> PRINT expression .)
    INTEGER         reduce using rule 15 (print_stmt -> PRINT expression .)
    HEXINT          reduce using rule 15 (print_stmt -> PRINT expression .)
    OCTINT          reduce using rule 15 (print_stmt -> PRINT expression .)
    BININT          reduce using rule 15 (print_stmt -> PRINT expression .)
    REAL            reduce using rule 15 (print_stmt -> PRINT expression .)
    IMAGINARY       reduce using rule 15 (print_stmt -> PRINT expression .)
    STRPREFIX       reduce using rule 15 (print_stmt -> PRINT expression .)
    SHORTSTRING     reduce using rule 15 (print_stmt -> PRINT expression .)
    LONGSTRING      reduce using rule 15 (print_stmt -> PRINT expression .)
    `               reduce using rule 15 (print_stmt -> PRINT expression .)
    $end            reduce using rule 15 (print_stmt -> PRINT expression .)
    ELSE            reduce using rule 15 (print_stmt -> PRINT expression .)
    DEFAULT         reduce using rule 15 (print_stmt -> PRINT expression .)
    CASE            reduce using rule 15 (print_stmt -> PRINT expression .)


state 100

    (19) target -> primary .
    (97) subscription -> primary . [ expression_list ]
    (115) call -> primary . ( )
    (116) call -> primary . ( argument_list )
    (94) attributeref -> primary . attribute_tag
    (100) simple_slicing -> primary . [ short_slice ]
    (105) extended_slicing -> primary . [ slice_list ]
    (95) attribute_tag -> . . ID
    (96) attribute_tag -> . REAL

  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
    ,               reduce using rule 19 (target -> primary .)
    BREAK           reduce using rule 19 (target -> primary .)
    NEXT            reduce using rule 19 (target -> primary .)
    {               reduce using rule 19 (target -> primary .)
    PRINT           reduce using rule 19 (target -> primary .)
    IF              reduce using rule 19 (target -> primary .)
    FOR             reduce using rule 19 (target -> primary .)
    WHERE           reduce using rule 19 (target -> primary .)
    SWITCH          reduce using rule 19 (target -> primary .)
    FUNCTION        reduce using rule 19 (target -> primary .)
    DO              reduce using rule 19 (target -> primary .)
    LOOP            reduce using rule 19 (target -> primary .)
    WITH            reduce using rule 19 (target -> primary .)
    ID              reduce using rule 19 (target -> primary .)
    ITEM_TAG        reduce using rule 19 (target -> primary .)
    INTEGER         reduce using rule 19 (target -> primary .)
    HEXINT          reduce using rule 19 (target -> primary .)
    OCTINT          reduce using rule 19 (target -> primary .)
    BININT          reduce using rule 19 (target -> primary .)
    IMAGINARY       reduce using rule 19 (target -> primary .)
    STRPREFIX       reduce using rule 19 (target -> primary .)
    SHORTSTRING     reduce using rule 19 (target -> primary .)
    LONGSTRING      reduce using rule 19 (target -> primary .)
    `               reduce using rule 19 (target -> primary .)
    =               reduce using rule 19 (target -> primary .)
    )               reduce using rule 19 (target -> primary .)
    IN              reduce using rule 19 (target -> primary .)
    ]               reduce using rule 19 (target -> primary .)
    [               shift and go to state 111
    (               shift and go to state 125
    .               shift and go to state 110
    REAL            shift and go to state 107

  ! (               [ reduce using rule 19 (target -> primary .) ]
  ! [               [ reduce using rule 19 (target -> primary .) ]
  ! REAL            [ reduce using rule 19 (target -> primary .) ]

    attribute_tag                  shift and go to state 108

state 101

    (144) for_stmt -> FOR target_list . IN expression_list suite
    (126) target_list -> target_list . , target

    IN              shift and go to state 151
    ,               shift and go to state 119


state 102

    (158) funcdef -> FUNCTION ID . ( arglist ) suite

    (               shift and go to state 152


state 103

    (78) list_display -> [ listmaker . ]

    ]               shift and go to state 153


state 104

    (21) target -> [ target_list . ]
    (126) target_list -> target_list . , target

    ]               shift and go to state 154
    ,               shift and go to state 119


state 105

    (79) list_display -> [ ] .

    (               reduce using rule 79 (list_display -> [ ] .)
    [               reduce using rule 79 (list_display -> [ ] .)
    .               reduce using rule 79 (list_display -> [ ] .)
    REAL            reduce using rule 79 (list_display -> [ ] .)
    AUGOP           reduce using rule 79 (list_display -> [ ] .)
    =               reduce using rule 79 (list_display -> [ ] .)
    ,               reduce using rule 79 (list_display -> [ ] .)
    BREAK           reduce using rule 79 (list_display -> [ ] .)
    NEXT            reduce using rule 79 (list_display -> [ ] .)
    {               reduce using rule 79 (list_display -> [ ] .)
    PRINT           reduce using rule 79 (list_display -> [ ] .)
    IF              reduce using rule 79 (list_display -> [ ] .)
    FOR             reduce using rule 79 (list_display -> [ ] .)
    WHERE           reduce using rule 79 (list_display -> [ ] .)
    SWITCH          reduce using rule 79 (list_display -> [ ] .)
    FUNCTION        reduce using rule 79 (list_display -> [ ] .)
    DO              reduce using rule 79 (list_display -> [ ] .)
    LOOP            reduce using rule 79 (list_display -> [ ] .)
    WITH            reduce using rule 79 (list_display -> [ ] .)
    ID              reduce using rule 79 (list_display -> [ ] .)
    ITEM_TAG        reduce using rule 79 (list_display -> [ ] .)
    INTEGER         reduce using rule 79 (list_display -> [ ] .)
    HEXINT          reduce using rule 79 (list_display -> [ ] .)
    OCTINT          reduce using rule 79 (list_display -> [ ] .)
    BININT          reduce using rule 79 (list_display -> [ ] .)
    IMAGINARY       reduce using rule 79 (list_display -> [ ] .)
    STRPREFIX       reduce using rule 79 (list_display -> [ ] .)
    SHORTSTRING     reduce using rule 79 (list_display -> [ ] .)
    LONGSTRING      reduce using rule 79 (list_display -> [ ] .)
    `               reduce using rule 79 (list_display -> [ ] .)
    POWER           reduce using rule 79 (list_display -> [ ] .)
    *               reduce using rule 79 (list_display -> [ ] .)
    /               reduce using rule 79 (list_display -> [ ] .)
    ^               reduce using rule 79 (list_display -> [ ] .)
    +               reduce using rule 79 (list_display -> [ ] .)
    -               reduce using rule 79 (list_display -> [ ] .)
    <               reduce using rule 79 (list_display -> [ ] .)
    >               reduce using rule 79 (list_display -> [ ] .)
    GTE             reduce using rule 79 (list_display -> [ ] .)
    LTE             reduce using rule 79 (list_display -> [ ] .)
    NEQ             reduce using rule 79 (list_display -> [ ] .)
    ISEQUAL         reduce using rule 79 (list_display -> [ ] .)
    IN              reduce using rule 79 (list_display -> [ ] .)
    NOT             reduce using rule 79 (list_display -> [ ] .)
    AND             reduce using rule 79 (list_display -> [ ] .)
    OR              reduce using rule 79 (list_display -> [ ] .)
    )               reduce using rule 79 (list_display -> [ ] .)
    ;               reduce using rule 79 (list_display -> [ ] .)
    $end            reduce using rule 79 (list_display -> [ ] .)
    }               reduce using rule 79 (list_display -> [ ] .)
    ELSE            reduce using rule 79 (list_display -> [ ] .)
    DEFAULT         reduce using rule 79 (list_display -> [ ] .)
    CASE            reduce using rule 79 (list_display -> [ ] .)
    ]               reduce using rule 79 (list_display -> [ ] .)
    :               reduce using rule 79 (list_display -> [ ] .)


state 106

    (80) listmaker -> expression . listmaker2
    (81) listmaker -> expression . list_for
    (82) listmaker2 -> . , expression
    (83) listmaker2 -> . listmaker2 , expression
    (84) listmaker2 -> .
    (85) list_for -> . FOR expression_list IN testlist
    (86) list_for -> . FOR expression_list IN testlist list_iter

  ! shift/reduce conflict for , resolved as shift
    ,               shift and go to state 157
    ]               reduce using rule 84 (listmaker2 -> .)
    FOR             shift and go to state 155

  ! ,               [ reduce using rule 84 (listmaker2 -> .) ]

    listmaker2                     shift and go to state 156
    list_for                       shift and go to state 158

state 107

    (96) attribute_tag -> REAL .

    POWER           reduce using rule 96 (attribute_tag -> REAL .)
    [               reduce using rule 96 (attribute_tag -> REAL .)
    (               reduce using rule 96 (attribute_tag -> REAL .)
    .               reduce using rule 96 (attribute_tag -> REAL .)
    REAL            reduce using rule 96 (attribute_tag -> REAL .)
    *               reduce using rule 96 (attribute_tag -> REAL .)
    /               reduce using rule 96 (attribute_tag -> REAL .)
    ^               reduce using rule 96 (attribute_tag -> REAL .)
    +               reduce using rule 96 (attribute_tag -> REAL .)
    -               reduce using rule 96 (attribute_tag -> REAL .)
    <               reduce using rule 96 (attribute_tag -> REAL .)
    >               reduce using rule 96 (attribute_tag -> REAL .)
    GTE             reduce using rule 96 (attribute_tag -> REAL .)
    LTE             reduce using rule 96 (attribute_tag -> REAL .)
    NEQ             reduce using rule 96 (attribute_tag -> REAL .)
    ISEQUAL         reduce using rule 96 (attribute_tag -> REAL .)
    IN              reduce using rule 96 (attribute_tag -> REAL .)
    NOT             reduce using rule 96 (attribute_tag -> REAL .)
    AND             reduce using rule 96 (attribute_tag -> REAL .)
    OR              reduce using rule 96 (attribute_tag -> REAL .)
    BREAK           reduce using rule 96 (attribute_tag -> REAL .)
    NEXT            reduce using rule 96 (attribute_tag -> REAL .)
    {               reduce using rule 96 (attribute_tag -> REAL .)
    PRINT           reduce using rule 96 (attribute_tag -> REAL .)
    IF              reduce using rule 96 (attribute_tag -> REAL .)
    FOR             reduce using rule 96 (attribute_tag -> REAL .)
    WHERE           reduce using rule 96 (attribute_tag -> REAL .)
    SWITCH          reduce using rule 96 (attribute_tag -> REAL .)
    FUNCTION        reduce using rule 96 (attribute_tag -> REAL .)
    DO              reduce using rule 96 (attribute_tag -> REAL .)
    LOOP            reduce using rule 96 (attribute_tag -> REAL .)
    WITH            reduce using rule 96 (attribute_tag -> REAL .)
    ID              reduce using rule 96 (attribute_tag -> REAL .)
    ITEM_TAG        reduce using rule 96 (attribute_tag -> REAL .)
    INTEGER         reduce using rule 96 (attribute_tag -> REAL .)
    HEXINT          reduce using rule 96 (attribute_tag -> REAL .)
    OCTINT          reduce using rule 96 (attribute_tag -> REAL .)
    BININT          reduce using rule 96 (attribute_tag -> REAL .)
    IMAGINARY       reduce using rule 96 (attribute_tag -> REAL .)
    STRPREFIX       reduce using rule 96 (attribute_tag -> REAL .)
    SHORTSTRING     reduce using rule 96 (attribute_tag -> REAL .)
    LONGSTRING      reduce using rule 96 (attribute_tag -> REAL .)
    `               reduce using rule 96 (attribute_tag -> REAL .)
    ,               reduce using rule 96 (attribute_tag -> REAL .)
    ;               reduce using rule 96 (attribute_tag -> REAL .)
    $end            reduce using rule 96 (attribute_tag -> REAL .)
    }               reduce using rule 96 (attribute_tag -> REAL .)
    ELSE            reduce using rule 96 (attribute_tag -> REAL .)
    DEFAULT         reduce using rule 96 (attribute_tag -> REAL .)
    CASE            reduce using rule 96 (attribute_tag -> REAL .)
    )               reduce using rule 96 (attribute_tag -> REAL .)
    ]               reduce using rule 96 (attribute_tag -> REAL .)
    :               reduce using rule 96 (attribute_tag -> REAL .)
    AUGOP           reduce using rule 96 (attribute_tag -> REAL .)
    =               reduce using rule 96 (attribute_tag -> REAL .)


state 108

    (94) attributeref -> primary attribute_tag .

    [               reduce using rule 94 (attributeref -> primary attribute_tag .)
    (               reduce using rule 94 (attributeref -> primary attribute_tag .)
    .               reduce using rule 94 (attributeref -> primary attribute_tag .)
    REAL            reduce using rule 94 (attributeref -> primary attribute_tag .)
    IN              reduce using rule 94 (attributeref -> primary attribute_tag .)
    ,               reduce using rule 94 (attributeref -> primary attribute_tag .)
    POWER           reduce using rule 94 (attributeref -> primary attribute_tag .)
    *               reduce using rule 94 (attributeref -> primary attribute_tag .)
    /               reduce using rule 94 (attributeref -> primary attribute_tag .)
    ^               reduce using rule 94 (attributeref -> primary attribute_tag .)
    +               reduce using rule 94 (attributeref -> primary attribute_tag .)
    -               reduce using rule 94 (attributeref -> primary attribute_tag .)
    <               reduce using rule 94 (attributeref -> primary attribute_tag .)
    >               reduce using rule 94 (attributeref -> primary attribute_tag .)
    GTE             reduce using rule 94 (attributeref -> primary attribute_tag .)
    LTE             reduce using rule 94 (attributeref -> primary attribute_tag .)
    NEQ             reduce using rule 94 (attributeref -> primary attribute_tag .)
    ISEQUAL         reduce using rule 94 (attributeref -> primary attribute_tag .)
    NOT             reduce using rule 94 (attributeref -> primary attribute_tag .)
    AND             reduce using rule 94 (attributeref -> primary attribute_tag .)
    OR              reduce using rule 94 (attributeref -> primary attribute_tag .)
    FOR             reduce using rule 94 (attributeref -> primary attribute_tag .)
    IF              reduce using rule 94 (attributeref -> primary attribute_tag .)
    ]               reduce using rule 94 (attributeref -> primary attribute_tag .)
    )               reduce using rule 94 (attributeref -> primary attribute_tag .)
    AUGOP           reduce using rule 94 (attributeref -> primary attribute_tag .)
    =               reduce using rule 94 (attributeref -> primary attribute_tag .)
    BREAK           reduce using rule 94 (attributeref -> primary attribute_tag .)
    NEXT            reduce using rule 94 (attributeref -> primary attribute_tag .)
    {               reduce using rule 94 (attributeref -> primary attribute_tag .)
    PRINT           reduce using rule 94 (attributeref -> primary attribute_tag .)
    WHERE           reduce using rule 94 (attributeref -> primary attribute_tag .)
    SWITCH          reduce using rule 94 (attributeref -> primary attribute_tag .)
    FUNCTION        reduce using rule 94 (attributeref -> primary attribute_tag .)
    DO              reduce using rule 94 (attributeref -> primary attribute_tag .)
    LOOP            reduce using rule 94 (attributeref -> primary attribute_tag .)
    WITH            reduce using rule 94 (attributeref -> primary attribute_tag .)
    ID              reduce using rule 94 (attributeref -> primary attribute_tag .)
    ITEM_TAG        reduce using rule 94 (attributeref -> primary attribute_tag .)
    INTEGER         reduce using rule 94 (attributeref -> primary attribute_tag .)
    HEXINT          reduce using rule 94 (attributeref -> primary attribute_tag .)
    OCTINT          reduce using rule 94 (attributeref -> primary attribute_tag .)
    BININT          reduce using rule 94 (attributeref -> primary attribute_tag .)
    IMAGINARY       reduce using rule 94 (attributeref -> primary attribute_tag .)
    STRPREFIX       reduce using rule 94 (attributeref -> primary attribute_tag .)
    SHORTSTRING     reduce using rule 94 (attributeref -> primary attribute_tag .)
    LONGSTRING      reduce using rule 94 (attributeref -> primary attribute_tag .)
    `               reduce using rule 94 (attributeref -> primary attribute_tag .)
    ;               reduce using rule 94 (attributeref -> primary attribute_tag .)
    $end            reduce using rule 94 (attributeref -> primary attribute_tag .)
    }               reduce using rule 94 (attributeref -> primary attribute_tag .)
    ELSE            reduce using rule 94 (attributeref -> primary attribute_tag .)
    DEFAULT         reduce using rule 94 (attributeref -> primary attribute_tag .)
    CASE            reduce using rule 94 (attributeref -> primary attribute_tag .)
    :               reduce using rule 94 (attributeref -> primary attribute_tag .)


state 109

    (121) fancy_drel_assignment_stmt -> primary ( . dotlist )
    (115) call -> primary ( . )
    (116) call -> primary ( . argument_list )
    (122) dotlist -> . . ID = expression
    (123) dotlist -> . dotlist , . ID = expression
    (117) argument_list -> . func_arg
    (118) argument_list -> . argument_list , func_arg
    (119) func_arg -> . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    )               shift and go to state 161
    .               shift and go to state 162
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    func_arg                       shift and go to state 159
    enclosure                      shift and go to state 29
    dotlist                        shift and go to state 160
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    argument_list                  shift and go to state 163
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 164

state 110

    (95) attribute_tag -> . . ID

    ID              shift and go to state 165


state 111

    (97) subscription -> primary [ . expression_list ]
    (100) simple_slicing -> primary [ . short_slice ]
    (105) extended_slicing -> primary [ . slice_list ]
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (101) short_slice -> . :
    (102) short_slice -> . expression : expression
    (103) short_slice -> . : expression
    (104) short_slice -> . expression :
    (106) slice_list -> . slice_item
    (107) slice_list -> . slice_list , slice_item
    (18) expression -> . or_test
    (108) slice_item -> . expression
    (109) slice_item -> . proper_slice
    (110) slice_item -> . ELLIPSIS
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (111) proper_slice -> . short_slice
    (112) proper_slice -> . long_slice
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (113) long_slice -> . short_slice :
    (114) long_slice -> . short_slice : expression
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    :               shift and go to state 169
    ELLIPSIS        shift and go to state 168
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    slice_list                     shift and go to state 166
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    short_slice                    shift and go to state 167
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    long_slice                     shift and go to state 170
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    proper_slice                   shift and go to state 171
    expression_list                shift and go to state 172
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    m_expr                         shift and go to state 82
    slice_item                     shift and go to state 173
    expression                     shift and go to state 174

state 112

    (155) switch_stmt -> SWITCH ID . open_brace caselist DEFAULT suite close_brace
    (140) open_brace -> . {

    {               shift and go to state 69

    open_brace                     shift and go to state 175

state 113

    (152) with_stmt -> with_head suite .

    }               reduce using rule 152 (with_stmt -> with_head suite .)
    BREAK           reduce using rule 152 (with_stmt -> with_head suite .)
    NEXT            reduce using rule 152 (with_stmt -> with_head suite .)
    IF              reduce using rule 152 (with_stmt -> with_head suite .)
    FOR             reduce using rule 152 (with_stmt -> with_head suite .)
    WHERE           reduce using rule 152 (with_stmt -> with_head suite .)
    SWITCH          reduce using rule 152 (with_stmt -> with_head suite .)
    FUNCTION        reduce using rule 152 (with_stmt -> with_head suite .)
    PRINT           reduce using rule 152 (with_stmt -> with_head suite .)
    DO              reduce using rule 152 (with_stmt -> with_head suite .)
    LOOP            reduce using rule 152 (with_stmt -> with_head suite .)
    WITH            reduce using rule 152 (with_stmt -> with_head suite .)
    (               reduce using rule 152 (with_stmt -> with_head suite .)
    [               reduce using rule 152 (with_stmt -> with_head suite .)
    ID              reduce using rule 152 (with_stmt -> with_head suite .)
    ITEM_TAG        reduce using rule 152 (with_stmt -> with_head suite .)
    INTEGER         reduce using rule 152 (with_stmt -> with_head suite .)
    HEXINT          reduce using rule 152 (with_stmt -> with_head suite .)
    OCTINT          reduce using rule 152 (with_stmt -> with_head suite .)
    BININT          reduce using rule 152 (with_stmt -> with_head suite .)
    REAL            reduce using rule 152 (with_stmt -> with_head suite .)
    IMAGINARY       reduce using rule 152 (with_stmt -> with_head suite .)
    STRPREFIX       reduce using rule 152 (with_stmt -> with_head suite .)
    SHORTSTRING     reduce using rule 152 (with_stmt -> with_head suite .)
    LONGSTRING      reduce using rule 152 (with_stmt -> with_head suite .)
    `               reduce using rule 152 (with_stmt -> with_head suite .)
    $end            reduce using rule 152 (with_stmt -> with_head suite .)
    ELSE            reduce using rule 152 (with_stmt -> with_head suite .)
    DEFAULT         reduce using rule 152 (with_stmt -> with_head suite .)
    CASE            reduce using rule 152 (with_stmt -> with_head suite .)


state 114

    (120) augmented_assignment_stmt -> target AUGOP . expression_list
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    expression_list                shift and go to state 176
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 87

state 115

    (150) do_stmt_head -> DO ID . = expression , expression
    (151) do_stmt_head -> DO ID . = expression , expression , expression

    =               shift and go to state 177


state 116

    (135) if_stmt -> IF expression . suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 178
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 117

    (7) stmt_list -> stmt_list ; . simple_stmt
    (8) stmt_list -> stmt_list ; . simple_stmt ;
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    PRINT           shift and go to state 28
    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    primary                        shift and go to state 42
    augmented_assignment_stmt      shift and go to state 27
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    print_stmt                     shift and go to state 50
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    assignment_stmt                shift and go to state 32
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    simple_stmt                    shift and go to state 179
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    target                         shift and go to state 54
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 118

    (124) assignment_stmt -> target_list = . expression_list
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    expression_list                shift and go to state 180
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 87

state 119

    (126) target_list -> target_list , . target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    primary_att                    shift and go to state 41
    primary                        shift and go to state 100
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    target                         shift and go to state 181
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 120

    (139) suite -> open_brace statement_block . close_brace
    (143) statement_block -> statement_block . statement
    (141) close_brace -> . }
    (4) statement -> . stmt_list
    (5) statement -> . compound_stmt
    (6) stmt_list -> . simple_stmt
    (7) stmt_list -> . stmt_list ; simple_stmt
    (8) stmt_list -> . stmt_list ; simple_stmt ;
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    }               shift and go to state 184
    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    PRINT           shift and go to state 28
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 14
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    statement                      shift and go to state 183
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 35
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    close_brace                    shift and go to state 182
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    stmt_list                      shift and go to state 62
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 121

    (142) statement_block -> statement .

    }               reduce using rule 142 (statement_block -> statement .)
    BREAK           reduce using rule 142 (statement_block -> statement .)
    NEXT            reduce using rule 142 (statement_block -> statement .)
    IF              reduce using rule 142 (statement_block -> statement .)
    FOR             reduce using rule 142 (statement_block -> statement .)
    WHERE           reduce using rule 142 (statement_block -> statement .)
    SWITCH          reduce using rule 142 (statement_block -> statement .)
    FUNCTION        reduce using rule 142 (statement_block -> statement .)
    PRINT           reduce using rule 142 (statement_block -> statement .)
    DO              reduce using rule 142 (statement_block -> statement .)
    LOOP            reduce using rule 142 (statement_block -> statement .)
    WITH            reduce using rule 142 (statement_block -> statement .)
    (               reduce using rule 142 (statement_block -> statement .)
    [               reduce using rule 142 (statement_block -> statement .)
    ID              reduce using rule 142 (statement_block -> statement .)
    ITEM_TAG        reduce using rule 142 (statement_block -> statement .)
    INTEGER         reduce using rule 142 (statement_block -> statement .)
    HEXINT          reduce using rule 142 (statement_block -> statement .)
    OCTINT          reduce using rule 142 (statement_block -> statement .)
    BININT          reduce using rule 142 (statement_block -> statement .)
    REAL            reduce using rule 142 (statement_block -> statement .)
    IMAGINARY       reduce using rule 142 (statement_block -> statement .)
    STRPREFIX       reduce using rule 142 (statement_block -> statement .)
    SHORTSTRING     reduce using rule 142 (statement_block -> statement .)
    LONGSTRING      reduce using rule 142 (statement_block -> statement .)
    `               reduce using rule 142 (statement_block -> statement .)


state 122

    (153) with_head -> WITH ID AS . ID

    ID              shift and go to state 185


state 123

    (27) not_test -> NOT not_test .

    AND             reduce using rule 27 (not_test -> NOT not_test .)
    OR              reduce using rule 27 (not_test -> NOT not_test .)
    )               reduce using rule 27 (not_test -> NOT not_test .)
    ,               reduce using rule 27 (not_test -> NOT not_test .)
    :               reduce using rule 27 (not_test -> NOT not_test .)
    ]               reduce using rule 27 (not_test -> NOT not_test .)
    FOR             reduce using rule 27 (not_test -> NOT not_test .)
    IF              reduce using rule 27 (not_test -> NOT not_test .)
    BREAK           reduce using rule 27 (not_test -> NOT not_test .)
    NEXT            reduce using rule 27 (not_test -> NOT not_test .)
    {               reduce using rule 27 (not_test -> NOT not_test .)
    PRINT           reduce using rule 27 (not_test -> NOT not_test .)
    WHERE           reduce using rule 27 (not_test -> NOT not_test .)
    SWITCH          reduce using rule 27 (not_test -> NOT not_test .)
    FUNCTION        reduce using rule 27 (not_test -> NOT not_test .)
    (               reduce using rule 27 (not_test -> NOT not_test .)
    [               reduce using rule 27 (not_test -> NOT not_test .)
    DO              reduce using rule 27 (not_test -> NOT not_test .)
    LOOP            reduce using rule 27 (not_test -> NOT not_test .)
    WITH            reduce using rule 27 (not_test -> NOT not_test .)
    ID              reduce using rule 27 (not_test -> NOT not_test .)
    ITEM_TAG        reduce using rule 27 (not_test -> NOT not_test .)
    INTEGER         reduce using rule 27 (not_test -> NOT not_test .)
    HEXINT          reduce using rule 27 (not_test -> NOT not_test .)
    OCTINT          reduce using rule 27 (not_test -> NOT not_test .)
    BININT          reduce using rule 27 (not_test -> NOT not_test .)
    REAL            reduce using rule 27 (not_test -> NOT not_test .)
    IMAGINARY       reduce using rule 27 (not_test -> NOT not_test .)
    STRPREFIX       reduce using rule 27 (not_test -> NOT not_test .)
    SHORTSTRING     reduce using rule 27 (not_test -> NOT not_test .)
    LONGSTRING      reduce using rule 27 (not_test -> NOT not_test .)
    `               reduce using rule 27 (not_test -> NOT not_test .)
    ;               reduce using rule 27 (not_test -> NOT not_test .)
    $end            reduce using rule 27 (not_test -> NOT not_test .)
    }               reduce using rule 27 (not_test -> NOT not_test .)
    ELSE            reduce using rule 27 (not_test -> NOT not_test .)
    DEFAULT         reduce using rule 27 (not_test -> NOT not_test .)
    CASE            reduce using rule 27 (not_test -> NOT not_test .)
    IN              reduce using rule 27 (not_test -> NOT not_test .)


state 124

    (49) power -> primary POWER . u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 186
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 125

    (115) call -> primary ( . )
    (116) call -> primary ( . argument_list )
    (117) argument_list -> . func_arg
    (118) argument_list -> . argument_list , func_arg
    (119) func_arg -> . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    )               shift and go to state 161
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    func_arg                       shift and go to state 159
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    argument_list                  shift and go to state 163
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 164

state 126

    (47) u_expr -> + u_expr .

    *               reduce using rule 47 (u_expr -> + u_expr .)
    /               reduce using rule 47 (u_expr -> + u_expr .)
    ^               reduce using rule 47 (u_expr -> + u_expr .)
    +               reduce using rule 47 (u_expr -> + u_expr .)
    -               reduce using rule 47 (u_expr -> + u_expr .)
    <               reduce using rule 47 (u_expr -> + u_expr .)
    >               reduce using rule 47 (u_expr -> + u_expr .)
    GTE             reduce using rule 47 (u_expr -> + u_expr .)
    LTE             reduce using rule 47 (u_expr -> + u_expr .)
    NEQ             reduce using rule 47 (u_expr -> + u_expr .)
    ISEQUAL         reduce using rule 47 (u_expr -> + u_expr .)
    IN              reduce using rule 47 (u_expr -> + u_expr .)
    NOT             reduce using rule 47 (u_expr -> + u_expr .)
    AND             reduce using rule 47 (u_expr -> + u_expr .)
    OR              reduce using rule 47 (u_expr -> + u_expr .)
    ,               reduce using rule 47 (u_expr -> + u_expr .)
    FOR             reduce using rule 47 (u_expr -> + u_expr .)
    ]               reduce using rule 47 (u_expr -> + u_expr .)
    )               reduce using rule 47 (u_expr -> + u_expr .)
    `               reduce using rule 47 (u_expr -> + u_expr .)
    ;               reduce using rule 47 (u_expr -> + u_expr .)
    BREAK           reduce using rule 47 (u_expr -> + u_expr .)
    NEXT            reduce using rule 47 (u_expr -> + u_expr .)
    IF              reduce using rule 47 (u_expr -> + u_expr .)
    WHERE           reduce using rule 47 (u_expr -> + u_expr .)
    SWITCH          reduce using rule 47 (u_expr -> + u_expr .)
    FUNCTION        reduce using rule 47 (u_expr -> + u_expr .)
    PRINT           reduce using rule 47 (u_expr -> + u_expr .)
    DO              reduce using rule 47 (u_expr -> + u_expr .)
    LOOP            reduce using rule 47 (u_expr -> + u_expr .)
    WITH            reduce using rule 47 (u_expr -> + u_expr .)
    (               reduce using rule 47 (u_expr -> + u_expr .)
    [               reduce using rule 47 (u_expr -> + u_expr .)
    ID              reduce using rule 47 (u_expr -> + u_expr .)
    ITEM_TAG        reduce using rule 47 (u_expr -> + u_expr .)
    INTEGER         reduce using rule 47 (u_expr -> + u_expr .)
    HEXINT          reduce using rule 47 (u_expr -> + u_expr .)
    OCTINT          reduce using rule 47 (u_expr -> + u_expr .)
    BININT          reduce using rule 47 (u_expr -> + u_expr .)
    REAL            reduce using rule 47 (u_expr -> + u_expr .)
    IMAGINARY       reduce using rule 47 (u_expr -> + u_expr .)
    STRPREFIX       reduce using rule 47 (u_expr -> + u_expr .)
    SHORTSTRING     reduce using rule 47 (u_expr -> + u_expr .)
    LONGSTRING      reduce using rule 47 (u_expr -> + u_expr .)
    $end            reduce using rule 47 (u_expr -> + u_expr .)
    }               reduce using rule 47 (u_expr -> + u_expr .)
    ELSE            reduce using rule 47 (u_expr -> + u_expr .)
    DEFAULT         reduce using rule 47 (u_expr -> + u_expr .)
    CASE            reduce using rule 47 (u_expr -> + u_expr .)
    {               reduce using rule 47 (u_expr -> + u_expr .)
    :               reduce using rule 47 (u_expr -> + u_expr .)


state 127

    (33) comp_operator -> LTE .

    -               reduce using rule 33 (comp_operator -> LTE .)
    +               reduce using rule 33 (comp_operator -> LTE .)
    ID              reduce using rule 33 (comp_operator -> LTE .)
    ITEM_TAG        reduce using rule 33 (comp_operator -> LTE .)
    INTEGER         reduce using rule 33 (comp_operator -> LTE .)
    HEXINT          reduce using rule 33 (comp_operator -> LTE .)
    OCTINT          reduce using rule 33 (comp_operator -> LTE .)
    BININT          reduce using rule 33 (comp_operator -> LTE .)
    REAL            reduce using rule 33 (comp_operator -> LTE .)
    IMAGINARY       reduce using rule 33 (comp_operator -> LTE .)
    STRPREFIX       reduce using rule 33 (comp_operator -> LTE .)
    SHORTSTRING     reduce using rule 33 (comp_operator -> LTE .)
    LONGSTRING      reduce using rule 33 (comp_operator -> LTE .)
    (               reduce using rule 33 (comp_operator -> LTE .)
    `               reduce using rule 33 (comp_operator -> LTE .)
    [               reduce using rule 33 (comp_operator -> LTE .)


state 128

    (29) comparison -> a_expr comp_operator . a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 187
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 129

    (39) a_expr -> a_expr + . m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 188
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 130

    (36) comp_operator -> IN .

    -               reduce using rule 36 (comp_operator -> IN .)
    +               reduce using rule 36 (comp_operator -> IN .)
    ID              reduce using rule 36 (comp_operator -> IN .)
    ITEM_TAG        reduce using rule 36 (comp_operator -> IN .)
    INTEGER         reduce using rule 36 (comp_operator -> IN .)
    HEXINT          reduce using rule 36 (comp_operator -> IN .)
    OCTINT          reduce using rule 36 (comp_operator -> IN .)
    BININT          reduce using rule 36 (comp_operator -> IN .)
    REAL            reduce using rule 36 (comp_operator -> IN .)
    IMAGINARY       reduce using rule 36 (comp_operator -> IN .)
    STRPREFIX       reduce using rule 36 (comp_operator -> IN .)
    SHORTSTRING     reduce using rule 36 (comp_operator -> IN .)
    LONGSTRING      reduce using rule 36 (comp_operator -> IN .)
    (               reduce using rule 36 (comp_operator -> IN .)
    `               reduce using rule 36 (comp_operator -> IN .)
    [               reduce using rule 36 (comp_operator -> IN .)


state 131

    (40) a_expr -> a_expr - . m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 189
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 132

    (32) comp_operator -> GTE .

    -               reduce using rule 32 (comp_operator -> GTE .)
    +               reduce using rule 32 (comp_operator -> GTE .)
    ID              reduce using rule 32 (comp_operator -> GTE .)
    ITEM_TAG        reduce using rule 32 (comp_operator -> GTE .)
    INTEGER         reduce using rule 32 (comp_operator -> GTE .)
    HEXINT          reduce using rule 32 (comp_operator -> GTE .)
    OCTINT          reduce using rule 32 (comp_operator -> GTE .)
    BININT          reduce using rule 32 (comp_operator -> GTE .)
    REAL            reduce using rule 32 (comp_operator -> GTE .)
    IMAGINARY       reduce using rule 32 (comp_operator -> GTE .)
    STRPREFIX       reduce using rule 32 (comp_operator -> GTE .)
    SHORTSTRING     reduce using rule 32 (comp_operator -> GTE .)
    LONGSTRING      reduce using rule 32 (comp_operator -> GTE .)
    (               reduce using rule 32 (comp_operator -> GTE .)
    `               reduce using rule 32 (comp_operator -> GTE .)
    [               reduce using rule 32 (comp_operator -> GTE .)


state 133

    (35) comp_operator -> ISEQUAL .

    -               reduce using rule 35 (comp_operator -> ISEQUAL .)
    +               reduce using rule 35 (comp_operator -> ISEQUAL .)
    ID              reduce using rule 35 (comp_operator -> ISEQUAL .)
    ITEM_TAG        reduce using rule 35 (comp_operator -> ISEQUAL .)
    INTEGER         reduce using rule 35 (comp_operator -> ISEQUAL .)
    HEXINT          reduce using rule 35 (comp_operator -> ISEQUAL .)
    OCTINT          reduce using rule 35 (comp_operator -> ISEQUAL .)
    BININT          reduce using rule 35 (comp_operator -> ISEQUAL .)
    REAL            reduce using rule 35 (comp_operator -> ISEQUAL .)
    IMAGINARY       reduce using rule 35 (comp_operator -> ISEQUAL .)
    STRPREFIX       reduce using rule 35 (comp_operator -> ISEQUAL .)
    SHORTSTRING     reduce using rule 35 (comp_operator -> ISEQUAL .)
    LONGSTRING      reduce using rule 35 (comp_operator -> ISEQUAL .)
    (               reduce using rule 35 (comp_operator -> ISEQUAL .)
    `               reduce using rule 35 (comp_operator -> ISEQUAL .)
    [               reduce using rule 35 (comp_operator -> ISEQUAL .)


state 134

    (37) comp_operator -> NOT . IN

    IN              shift and go to state 190


state 135

    (34) comp_operator -> NEQ .

    -               reduce using rule 34 (comp_operator -> NEQ .)
    +               reduce using rule 34 (comp_operator -> NEQ .)
    ID              reduce using rule 34 (comp_operator -> NEQ .)
    ITEM_TAG        reduce using rule 34 (comp_operator -> NEQ .)
    INTEGER         reduce using rule 34 (comp_operator -> NEQ .)
    HEXINT          reduce using rule 34 (comp_operator -> NEQ .)
    OCTINT          reduce using rule 34 (comp_operator -> NEQ .)
    BININT          reduce using rule 34 (comp_operator -> NEQ .)
    REAL            reduce using rule 34 (comp_operator -> NEQ .)
    IMAGINARY       reduce using rule 34 (comp_operator -> NEQ .)
    STRPREFIX       reduce using rule 34 (comp_operator -> NEQ .)
    SHORTSTRING     reduce using rule 34 (comp_operator -> NEQ .)
    LONGSTRING      reduce using rule 34 (comp_operator -> NEQ .)
    (               reduce using rule 34 (comp_operator -> NEQ .)
    `               reduce using rule 34 (comp_operator -> NEQ .)
    [               reduce using rule 34 (comp_operator -> NEQ .)


state 136

    (30) comp_operator -> < .

    -               reduce using rule 30 (comp_operator -> < .)
    +               reduce using rule 30 (comp_operator -> < .)
    ID              reduce using rule 30 (comp_operator -> < .)
    ITEM_TAG        reduce using rule 30 (comp_operator -> < .)
    INTEGER         reduce using rule 30 (comp_operator -> < .)
    HEXINT          reduce using rule 30 (comp_operator -> < .)
    OCTINT          reduce using rule 30 (comp_operator -> < .)
    BININT          reduce using rule 30 (comp_operator -> < .)
    REAL            reduce using rule 30 (comp_operator -> < .)
    IMAGINARY       reduce using rule 30 (comp_operator -> < .)
    STRPREFIX       reduce using rule 30 (comp_operator -> < .)
    SHORTSTRING     reduce using rule 30 (comp_operator -> < .)
    LONGSTRING      reduce using rule 30 (comp_operator -> < .)
    (               reduce using rule 30 (comp_operator -> < .)
    `               reduce using rule 30 (comp_operator -> < .)
    [               reduce using rule 30 (comp_operator -> < .)


state 137

    (31) comp_operator -> > .

    -               reduce using rule 31 (comp_operator -> > .)
    +               reduce using rule 31 (comp_operator -> > .)
    ID              reduce using rule 31 (comp_operator -> > .)
    ITEM_TAG        reduce using rule 31 (comp_operator -> > .)
    INTEGER         reduce using rule 31 (comp_operator -> > .)
    HEXINT          reduce using rule 31 (comp_operator -> > .)
    OCTINT          reduce using rule 31 (comp_operator -> > .)
    BININT          reduce using rule 31 (comp_operator -> > .)
    REAL            reduce using rule 31 (comp_operator -> > .)
    IMAGINARY       reduce using rule 31 (comp_operator -> > .)
    STRPREFIX       reduce using rule 31 (comp_operator -> > .)
    SHORTSTRING     reduce using rule 31 (comp_operator -> > .)
    LONGSTRING      reduce using rule 31 (comp_operator -> > .)
    (               reduce using rule 31 (comp_operator -> > .)
    `               reduce using rule 31 (comp_operator -> > .)
    [               reduce using rule 31 (comp_operator -> > .)


state 138

    (46) u_expr -> - u_expr .

    *               reduce using rule 46 (u_expr -> - u_expr .)
    /               reduce using rule 46 (u_expr -> - u_expr .)
    ^               reduce using rule 46 (u_expr -> - u_expr .)
    +               reduce using rule 46 (u_expr -> - u_expr .)
    -               reduce using rule 46 (u_expr -> - u_expr .)
    <               reduce using rule 46 (u_expr -> - u_expr .)
    >               reduce using rule 46 (u_expr -> - u_expr .)
    GTE             reduce using rule 46 (u_expr -> - u_expr .)
    LTE             reduce using rule 46 (u_expr -> - u_expr .)
    NEQ             reduce using rule 46 (u_expr -> - u_expr .)
    ISEQUAL         reduce using rule 46 (u_expr -> - u_expr .)
    IN              reduce using rule 46 (u_expr -> - u_expr .)
    NOT             reduce using rule 46 (u_expr -> - u_expr .)
    AND             reduce using rule 46 (u_expr -> - u_expr .)
    OR              reduce using rule 46 (u_expr -> - u_expr .)
    ,               reduce using rule 46 (u_expr -> - u_expr .)
    FOR             reduce using rule 46 (u_expr -> - u_expr .)
    ]               reduce using rule 46 (u_expr -> - u_expr .)
    )               reduce using rule 46 (u_expr -> - u_expr .)
    `               reduce using rule 46 (u_expr -> - u_expr .)
    ;               reduce using rule 46 (u_expr -> - u_expr .)
    BREAK           reduce using rule 46 (u_expr -> - u_expr .)
    NEXT            reduce using rule 46 (u_expr -> - u_expr .)
    IF              reduce using rule 46 (u_expr -> - u_expr .)
    WHERE           reduce using rule 46 (u_expr -> - u_expr .)
    SWITCH          reduce using rule 46 (u_expr -> - u_expr .)
    FUNCTION        reduce using rule 46 (u_expr -> - u_expr .)
    PRINT           reduce using rule 46 (u_expr -> - u_expr .)
    DO              reduce using rule 46 (u_expr -> - u_expr .)
    LOOP            reduce using rule 46 (u_expr -> - u_expr .)
    WITH            reduce using rule 46 (u_expr -> - u_expr .)
    (               reduce using rule 46 (u_expr -> - u_expr .)
    [               reduce using rule 46 (u_expr -> - u_expr .)
    ID              reduce using rule 46 (u_expr -> - u_expr .)
    ITEM_TAG        reduce using rule 46 (u_expr -> - u_expr .)
    INTEGER         reduce using rule 46 (u_expr -> - u_expr .)
    HEXINT          reduce using rule 46 (u_expr -> - u_expr .)
    OCTINT          reduce using rule 46 (u_expr -> - u_expr .)
    BININT          reduce using rule 46 (u_expr -> - u_expr .)
    REAL            reduce using rule 46 (u_expr -> - u_expr .)
    IMAGINARY       reduce using rule 46 (u_expr -> - u_expr .)
    STRPREFIX       reduce using rule 46 (u_expr -> - u_expr .)
    SHORTSTRING     reduce using rule 46 (u_expr -> - u_expr .)
    LONGSTRING      reduce using rule 46 (u_expr -> - u_expr .)
    $end            reduce using rule 46 (u_expr -> - u_expr .)
    }               reduce using rule 46 (u_expr -> - u_expr .)
    ELSE            reduce using rule 46 (u_expr -> - u_expr .)
    DEFAULT         reduce using rule 46 (u_expr -> - u_expr .)
    CASE            reduce using rule 46 (u_expr -> - u_expr .)
    {               reduce using rule 46 (u_expr -> - u_expr .)
    :               reduce using rule 46 (u_expr -> - u_expr .)


state 139

    (25) and_test -> and_test AND . not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    not_test                       shift and go to state 191
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 140

    (20) target -> ( target_list ) .

    AUGOP           reduce using rule 20 (target -> ( target_list ) .)
    =               reduce using rule 20 (target -> ( target_list ) .)
    ,               reduce using rule 20 (target -> ( target_list ) .)
    )               reduce using rule 20 (target -> ( target_list ) .)
    BREAK           reduce using rule 20 (target -> ( target_list ) .)
    NEXT            reduce using rule 20 (target -> ( target_list ) .)
    {               reduce using rule 20 (target -> ( target_list ) .)
    PRINT           reduce using rule 20 (target -> ( target_list ) .)
    IF              reduce using rule 20 (target -> ( target_list ) .)
    FOR             reduce using rule 20 (target -> ( target_list ) .)
    WHERE           reduce using rule 20 (target -> ( target_list ) .)
    SWITCH          reduce using rule 20 (target -> ( target_list ) .)
    FUNCTION        reduce using rule 20 (target -> ( target_list ) .)
    (               reduce using rule 20 (target -> ( target_list ) .)
    [               reduce using rule 20 (target -> ( target_list ) .)
    DO              reduce using rule 20 (target -> ( target_list ) .)
    LOOP            reduce using rule 20 (target -> ( target_list ) .)
    WITH            reduce using rule 20 (target -> ( target_list ) .)
    ID              reduce using rule 20 (target -> ( target_list ) .)
    ITEM_TAG        reduce using rule 20 (target -> ( target_list ) .)
    INTEGER         reduce using rule 20 (target -> ( target_list ) .)
    HEXINT          reduce using rule 20 (target -> ( target_list ) .)
    OCTINT          reduce using rule 20 (target -> ( target_list ) .)
    BININT          reduce using rule 20 (target -> ( target_list ) .)
    REAL            reduce using rule 20 (target -> ( target_list ) .)
    IMAGINARY       reduce using rule 20 (target -> ( target_list ) .)
    STRPREFIX       reduce using rule 20 (target -> ( target_list ) .)
    SHORTSTRING     reduce using rule 20 (target -> ( target_list ) .)
    LONGSTRING      reduce using rule 20 (target -> ( target_list ) .)
    `               reduce using rule 20 (target -> ( target_list ) .)
    ]               reduce using rule 20 (target -> ( target_list ) .)
    IN              reduce using rule 20 (target -> ( target_list ) .)


state 141

    (42) m_expr -> m_expr * . u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 192
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 142

    (43) m_expr -> m_expr / . u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 193
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 143

    (44) m_expr -> m_expr ^ . u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    enclosure                      shift and go to state 29
    power                          shift and go to state 75
    u_expr                         shift and go to state 194
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 144

    (75) parenth_form -> ( expression_list ) .

    POWER           reduce using rule 75 (parenth_form -> ( expression_list ) .)
    [               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    (               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    .               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    REAL            reduce using rule 75 (parenth_form -> ( expression_list ) .)
    *               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    /               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ^               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    +               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    -               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    <               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    >               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    GTE             reduce using rule 75 (parenth_form -> ( expression_list ) .)
    LTE             reduce using rule 75 (parenth_form -> ( expression_list ) .)
    NEQ             reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ISEQUAL         reduce using rule 75 (parenth_form -> ( expression_list ) .)
    IN              reduce using rule 75 (parenth_form -> ( expression_list ) .)
    NOT             reduce using rule 75 (parenth_form -> ( expression_list ) .)
    AND             reduce using rule 75 (parenth_form -> ( expression_list ) .)
    OR              reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ]               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    :               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ,               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    )               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    BREAK           reduce using rule 75 (parenth_form -> ( expression_list ) .)
    NEXT            reduce using rule 75 (parenth_form -> ( expression_list ) .)
    {               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    PRINT           reduce using rule 75 (parenth_form -> ( expression_list ) .)
    IF              reduce using rule 75 (parenth_form -> ( expression_list ) .)
    FOR             reduce using rule 75 (parenth_form -> ( expression_list ) .)
    WHERE           reduce using rule 75 (parenth_form -> ( expression_list ) .)
    SWITCH          reduce using rule 75 (parenth_form -> ( expression_list ) .)
    FUNCTION        reduce using rule 75 (parenth_form -> ( expression_list ) .)
    DO              reduce using rule 75 (parenth_form -> ( expression_list ) .)
    LOOP            reduce using rule 75 (parenth_form -> ( expression_list ) .)
    WITH            reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ID              reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ITEM_TAG        reduce using rule 75 (parenth_form -> ( expression_list ) .)
    INTEGER         reduce using rule 75 (parenth_form -> ( expression_list ) .)
    HEXINT          reduce using rule 75 (parenth_form -> ( expression_list ) .)
    OCTINT          reduce using rule 75 (parenth_form -> ( expression_list ) .)
    BININT          reduce using rule 75 (parenth_form -> ( expression_list ) .)
    IMAGINARY       reduce using rule 75 (parenth_form -> ( expression_list ) .)
    STRPREFIX       reduce using rule 75 (parenth_form -> ( expression_list ) .)
    SHORTSTRING     reduce using rule 75 (parenth_form -> ( expression_list ) .)
    LONGSTRING      reduce using rule 75 (parenth_form -> ( expression_list ) .)
    `               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ;               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    $end            reduce using rule 75 (parenth_form -> ( expression_list ) .)
    }               reduce using rule 75 (parenth_form -> ( expression_list ) .)
    ELSE            reduce using rule 75 (parenth_form -> ( expression_list ) .)
    DEFAULT         reduce using rule 75 (parenth_form -> ( expression_list ) .)
    CASE            reduce using rule 75 (parenth_form -> ( expression_list ) .)
    AUGOP           reduce using rule 75 (parenth_form -> ( expression_list ) .)
    =               reduce using rule 75 (parenth_form -> ( expression_list ) .)


state 145

    (17) expression_list -> expression_list , . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 195

state 146

    (23) or_test -> or_test OR . and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 196
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22

state 147

    (154) where_stmt -> WHERE expression suite . ELSE suite

    ELSE            shift and go to state 197


state 148

    (77) string_conversion -> ` expression_list ` .

    POWER           reduce using rule 77 (string_conversion -> ` expression_list ` .)
    [               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    (               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    .               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    REAL            reduce using rule 77 (string_conversion -> ` expression_list ` .)
    *               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    /               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ^               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    +               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    -               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    <               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    >               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    GTE             reduce using rule 77 (string_conversion -> ` expression_list ` .)
    LTE             reduce using rule 77 (string_conversion -> ` expression_list ` .)
    NEQ             reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ISEQUAL         reduce using rule 77 (string_conversion -> ` expression_list ` .)
    IN              reduce using rule 77 (string_conversion -> ` expression_list ` .)
    NOT             reduce using rule 77 (string_conversion -> ` expression_list ` .)
    AND             reduce using rule 77 (string_conversion -> ` expression_list ` .)
    OR              reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ,               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    BREAK           reduce using rule 77 (string_conversion -> ` expression_list ` .)
    NEXT            reduce using rule 77 (string_conversion -> ` expression_list ` .)
    {               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    PRINT           reduce using rule 77 (string_conversion -> ` expression_list ` .)
    IF              reduce using rule 77 (string_conversion -> ` expression_list ` .)
    FOR             reduce using rule 77 (string_conversion -> ` expression_list ` .)
    WHERE           reduce using rule 77 (string_conversion -> ` expression_list ` .)
    SWITCH          reduce using rule 77 (string_conversion -> ` expression_list ` .)
    FUNCTION        reduce using rule 77 (string_conversion -> ` expression_list ` .)
    DO              reduce using rule 77 (string_conversion -> ` expression_list ` .)
    LOOP            reduce using rule 77 (string_conversion -> ` expression_list ` .)
    WITH            reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ID              reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ITEM_TAG        reduce using rule 77 (string_conversion -> ` expression_list ` .)
    INTEGER         reduce using rule 77 (string_conversion -> ` expression_list ` .)
    HEXINT          reduce using rule 77 (string_conversion -> ` expression_list ` .)
    OCTINT          reduce using rule 77 (string_conversion -> ` expression_list ` .)
    BININT          reduce using rule 77 (string_conversion -> ` expression_list ` .)
    IMAGINARY       reduce using rule 77 (string_conversion -> ` expression_list ` .)
    STRPREFIX       reduce using rule 77 (string_conversion -> ` expression_list ` .)
    SHORTSTRING     reduce using rule 77 (string_conversion -> ` expression_list ` .)
    LONGSTRING      reduce using rule 77 (string_conversion -> ` expression_list ` .)
    `               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    )               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ;               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    $end            reduce using rule 77 (string_conversion -> ` expression_list ` .)
    }               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ELSE            reduce using rule 77 (string_conversion -> ` expression_list ` .)
    DEFAULT         reduce using rule 77 (string_conversion -> ` expression_list ` .)
    CASE            reduce using rule 77 (string_conversion -> ` expression_list ` .)
    ]               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    :               reduce using rule 77 (string_conversion -> ` expression_list ` .)
    AUGOP           reduce using rule 77 (string_conversion -> ` expression_list ` .)
    =               reduce using rule 77 (string_conversion -> ` expression_list ` .)


state 149

    (136) if_stmt -> if_stmt ELSE suite .

    BREAK           reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    NEXT            reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    IF              reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    FOR             reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    WHERE           reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    SWITCH          reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    FUNCTION        reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    PRINT           reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    DO              reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    LOOP            reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    WITH            reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    (               reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    [               reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    ID              reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    ITEM_TAG        reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    INTEGER         reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    HEXINT          reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    OCTINT          reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    BININT          reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    REAL            reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    IMAGINARY       reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    STRPREFIX       reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    SHORTSTRING     reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    LONGSTRING      reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    `               reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    $end            reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    }               reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    ELSE            reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    DEFAULT         reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)
    CASE            reduce using rule 136 (if_stmt -> if_stmt ELSE suite .)


state 150

    (146) loop_head -> LOOP ID AS . ID
    (147) loop_head -> LOOP ID AS . ID : ID
    (148) loop_head -> LOOP ID AS . ID : ID comp_operator ID

    ID              shift and go to state 198


state 151

    (144) for_stmt -> FOR target_list IN . expression_list suite
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    extended_slicing               shift and go to state 34
    expression_list                shift and go to state 199
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 87

state 152

    (158) funcdef -> FUNCTION ID ( . arglist ) suite
    (159) arglist -> . ID : list_display
    (160) arglist -> . arglist , ID : list_display

    ID              shift and go to state 201

    arglist                        shift and go to state 200

state 153

    (78) list_display -> [ listmaker ] .

    (               reduce using rule 78 (list_display -> [ listmaker ] .)
    [               reduce using rule 78 (list_display -> [ listmaker ] .)
    .               reduce using rule 78 (list_display -> [ listmaker ] .)
    REAL            reduce using rule 78 (list_display -> [ listmaker ] .)
    AUGOP           reduce using rule 78 (list_display -> [ listmaker ] .)
    =               reduce using rule 78 (list_display -> [ listmaker ] .)
    ,               reduce using rule 78 (list_display -> [ listmaker ] .)
    BREAK           reduce using rule 78 (list_display -> [ listmaker ] .)
    NEXT            reduce using rule 78 (list_display -> [ listmaker ] .)
    {               reduce using rule 78 (list_display -> [ listmaker ] .)
    PRINT           reduce using rule 78 (list_display -> [ listmaker ] .)
    IF              reduce using rule 78 (list_display -> [ listmaker ] .)
    FOR             reduce using rule 78 (list_display -> [ listmaker ] .)
    WHERE           reduce using rule 78 (list_display -> [ listmaker ] .)
    SWITCH          reduce using rule 78 (list_display -> [ listmaker ] .)
    FUNCTION        reduce using rule 78 (list_display -> [ listmaker ] .)
    DO              reduce using rule 78 (list_display -> [ listmaker ] .)
    LOOP            reduce using rule 78 (list_display -> [ listmaker ] .)
    WITH            reduce using rule 78 (list_display -> [ listmaker ] .)
    ID              reduce using rule 78 (list_display -> [ listmaker ] .)
    ITEM_TAG        reduce using rule 78 (list_display -> [ listmaker ] .)
    INTEGER         reduce using rule 78 (list_display -> [ listmaker ] .)
    HEXINT          reduce using rule 78 (list_display -> [ listmaker ] .)
    OCTINT          reduce using rule 78 (list_display -> [ listmaker ] .)
    BININT          reduce using rule 78 (list_display -> [ listmaker ] .)
    IMAGINARY       reduce using rule 78 (list_display -> [ listmaker ] .)
    STRPREFIX       reduce using rule 78 (list_display -> [ listmaker ] .)
    SHORTSTRING     reduce using rule 78 (list_display -> [ listmaker ] .)
    LONGSTRING      reduce using rule 78 (list_display -> [ listmaker ] .)
    `               reduce using rule 78 (list_display -> [ listmaker ] .)
    POWER           reduce using rule 78 (list_display -> [ listmaker ] .)
    *               reduce using rule 78 (list_display -> [ listmaker ] .)
    /               reduce using rule 78 (list_display -> [ listmaker ] .)
    ^               reduce using rule 78 (list_display -> [ listmaker ] .)
    +               reduce using rule 78 (list_display -> [ listmaker ] .)
    -               reduce using rule 78 (list_display -> [ listmaker ] .)
    <               reduce using rule 78 (list_display -> [ listmaker ] .)
    >               reduce using rule 78 (list_display -> [ listmaker ] .)
    GTE             reduce using rule 78 (list_display -> [ listmaker ] .)
    LTE             reduce using rule 78 (list_display -> [ listmaker ] .)
    NEQ             reduce using rule 78 (list_display -> [ listmaker ] .)
    ISEQUAL         reduce using rule 78 (list_display -> [ listmaker ] .)
    IN              reduce using rule 78 (list_display -> [ listmaker ] .)
    NOT             reduce using rule 78 (list_display -> [ listmaker ] .)
    AND             reduce using rule 78 (list_display -> [ listmaker ] .)
    OR              reduce using rule 78 (list_display -> [ listmaker ] .)
    )               reduce using rule 78 (list_display -> [ listmaker ] .)
    ;               reduce using rule 78 (list_display -> [ listmaker ] .)
    $end            reduce using rule 78 (list_display -> [ listmaker ] .)
    }               reduce using rule 78 (list_display -> [ listmaker ] .)
    ELSE            reduce using rule 78 (list_display -> [ listmaker ] .)
    DEFAULT         reduce using rule 78 (list_display -> [ listmaker ] .)
    CASE            reduce using rule 78 (list_display -> [ listmaker ] .)
    ]               reduce using rule 78 (list_display -> [ listmaker ] .)
    :               reduce using rule 78 (list_display -> [ listmaker ] .)


state 154

    (21) target -> [ target_list ] .

    AUGOP           reduce using rule 21 (target -> [ target_list ] .)
    =               reduce using rule 21 (target -> [ target_list ] .)
    ,               reduce using rule 21 (target -> [ target_list ] .)
    )               reduce using rule 21 (target -> [ target_list ] .)
    BREAK           reduce using rule 21 (target -> [ target_list ] .)
    NEXT            reduce using rule 21 (target -> [ target_list ] .)
    {               reduce using rule 21 (target -> [ target_list ] .)
    PRINT           reduce using rule 21 (target -> [ target_list ] .)
    IF              reduce using rule 21 (target -> [ target_list ] .)
    FOR             reduce using rule 21 (target -> [ target_list ] .)
    WHERE           reduce using rule 21 (target -> [ target_list ] .)
    SWITCH          reduce using rule 21 (target -> [ target_list ] .)
    FUNCTION        reduce using rule 21 (target -> [ target_list ] .)
    (               reduce using rule 21 (target -> [ target_list ] .)
    [               reduce using rule 21 (target -> [ target_list ] .)
    DO              reduce using rule 21 (target -> [ target_list ] .)
    LOOP            reduce using rule 21 (target -> [ target_list ] .)
    WITH            reduce using rule 21 (target -> [ target_list ] .)
    ID              reduce using rule 21 (target -> [ target_list ] .)
    ITEM_TAG        reduce using rule 21 (target -> [ target_list ] .)
    INTEGER         reduce using rule 21 (target -> [ target_list ] .)
    HEXINT          reduce using rule 21 (target -> [ target_list ] .)
    OCTINT          reduce using rule 21 (target -> [ target_list ] .)
    BININT          reduce using rule 21 (target -> [ target_list ] .)
    REAL            reduce using rule 21 (target -> [ target_list ] .)
    IMAGINARY       reduce using rule 21 (target -> [ target_list ] .)
    STRPREFIX       reduce using rule 21 (target -> [ target_list ] .)
    SHORTSTRING     reduce using rule 21 (target -> [ target_list ] .)
    LONGSTRING      reduce using rule 21 (target -> [ target_list ] .)
    `               reduce using rule 21 (target -> [ target_list ] .)
    ]               reduce using rule 21 (target -> [ target_list ] .)
    IN              reduce using rule 21 (target -> [ target_list ] .)


state 155

    (85) list_for -> FOR . expression_list IN testlist
    (86) list_for -> FOR . expression_list IN testlist list_iter
    (16) expression_list -> . expression
    (17) expression_list -> . expression_list , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    string_conversion              shift and go to state 49
    call                           shift and go to state 47
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    extended_slicing               shift and go to state 34
    expression_list                shift and go to state 202
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 87

state 156

    (80) listmaker -> expression listmaker2 .
    (83) listmaker2 -> listmaker2 . , expression

    ]               reduce using rule 80 (listmaker -> expression listmaker2 .)
    ,               shift and go to state 203


state 157

    (82) listmaker2 -> , . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 204

state 158

    (81) listmaker -> expression list_for .

    ]               reduce using rule 81 (listmaker -> expression list_for .)


state 159

    (117) argument_list -> func_arg .

    )               reduce using rule 117 (argument_list -> func_arg .)
    ,               reduce using rule 117 (argument_list -> func_arg .)


state 160

    (121) fancy_drel_assignment_stmt -> primary ( dotlist . )
    (123) dotlist -> dotlist . , . ID = expression

    )               shift and go to state 205
    ,               shift and go to state 206


state 161

    (115) call -> primary ( ) .

    [               reduce using rule 115 (call -> primary ( ) .)
    (               reduce using rule 115 (call -> primary ( ) .)
    POWER           reduce using rule 115 (call -> primary ( ) .)
    .               reduce using rule 115 (call -> primary ( ) .)
    REAL            reduce using rule 115 (call -> primary ( ) .)
    ]               reduce using rule 115 (call -> primary ( ) .)
    ,               reduce using rule 115 (call -> primary ( ) .)
    *               reduce using rule 115 (call -> primary ( ) .)
    /               reduce using rule 115 (call -> primary ( ) .)
    ^               reduce using rule 115 (call -> primary ( ) .)
    +               reduce using rule 115 (call -> primary ( ) .)
    -               reduce using rule 115 (call -> primary ( ) .)
    <               reduce using rule 115 (call -> primary ( ) .)
    >               reduce using rule 115 (call -> primary ( ) .)
    GTE             reduce using rule 115 (call -> primary ( ) .)
    LTE             reduce using rule 115 (call -> primary ( ) .)
    NEQ             reduce using rule 115 (call -> primary ( ) .)
    ISEQUAL         reduce using rule 115 (call -> primary ( ) .)
    IN              reduce using rule 115 (call -> primary ( ) .)
    NOT             reduce using rule 115 (call -> primary ( ) .)
    AND             reduce using rule 115 (call -> primary ( ) .)
    OR              reduce using rule 115 (call -> primary ( ) .)
    FOR             reduce using rule 115 (call -> primary ( ) .)
    )               reduce using rule 115 (call -> primary ( ) .)
    BREAK           reduce using rule 115 (call -> primary ( ) .)
    NEXT            reduce using rule 115 (call -> primary ( ) .)
    {               reduce using rule 115 (call -> primary ( ) .)
    PRINT           reduce using rule 115 (call -> primary ( ) .)
    IF              reduce using rule 115 (call -> primary ( ) .)
    WHERE           reduce using rule 115 (call -> primary ( ) .)
    SWITCH          reduce using rule 115 (call -> primary ( ) .)
    FUNCTION        reduce using rule 115 (call -> primary ( ) .)
    DO              reduce using rule 115 (call -> primary ( ) .)
    LOOP            reduce using rule 115 (call -> primary ( ) .)
    WITH            reduce using rule 115 (call -> primary ( ) .)
    ID              reduce using rule 115 (call -> primary ( ) .)
    ITEM_TAG        reduce using rule 115 (call -> primary ( ) .)
    INTEGER         reduce using rule 115 (call -> primary ( ) .)
    HEXINT          reduce using rule 115 (call -> primary ( ) .)
    OCTINT          reduce using rule 115 (call -> primary ( ) .)
    BININT          reduce using rule 115 (call -> primary ( ) .)
    IMAGINARY       reduce using rule 115 (call -> primary ( ) .)
    STRPREFIX       reduce using rule 115 (call -> primary ( ) .)
    SHORTSTRING     reduce using rule 115 (call -> primary ( ) .)
    LONGSTRING      reduce using rule 115 (call -> primary ( ) .)
    `               reduce using rule 115 (call -> primary ( ) .)
    ;               reduce using rule 115 (call -> primary ( ) .)
    $end            reduce using rule 115 (call -> primary ( ) .)
    }               reduce using rule 115 (call -> primary ( ) .)
    ELSE            reduce using rule 115 (call -> primary ( ) .)
    DEFAULT         reduce using rule 115 (call -> primary ( ) .)
    CASE            reduce using rule 115 (call -> primary ( ) .)
    :               reduce using rule 115 (call -> primary ( ) .)
    AUGOP           reduce using rule 115 (call -> primary ( ) .)
    =               reduce using rule 115 (call -> primary ( ) .)


state 162

    (122) dotlist -> . . ID = expression

    ID              shift and go to state 207


state 163

    (116) call -> primary ( argument_list . )
    (118) argument_list -> argument_list . , func_arg

    )               shift and go to state 208
    ,               shift and go to state 209


state 164

    (119) func_arg -> expression .

    )               reduce using rule 119 (func_arg -> expression .)
    ,               reduce using rule 119 (func_arg -> expression .)


state 165

    (95) attribute_tag -> . ID .

    POWER           reduce using rule 95 (attribute_tag -> . ID .)
    [               reduce using rule 95 (attribute_tag -> . ID .)
    (               reduce using rule 95 (attribute_tag -> . ID .)
    .               reduce using rule 95 (attribute_tag -> . ID .)
    REAL            reduce using rule 95 (attribute_tag -> . ID .)
    *               reduce using rule 95 (attribute_tag -> . ID .)
    /               reduce using rule 95 (attribute_tag -> . ID .)
    ^               reduce using rule 95 (attribute_tag -> . ID .)
    +               reduce using rule 95 (attribute_tag -> . ID .)
    -               reduce using rule 95 (attribute_tag -> . ID .)
    <               reduce using rule 95 (attribute_tag -> . ID .)
    >               reduce using rule 95 (attribute_tag -> . ID .)
    GTE             reduce using rule 95 (attribute_tag -> . ID .)
    LTE             reduce using rule 95 (attribute_tag -> . ID .)
    NEQ             reduce using rule 95 (attribute_tag -> . ID .)
    ISEQUAL         reduce using rule 95 (attribute_tag -> . ID .)
    IN              reduce using rule 95 (attribute_tag -> . ID .)
    NOT             reduce using rule 95 (attribute_tag -> . ID .)
    AND             reduce using rule 95 (attribute_tag -> . ID .)
    OR              reduce using rule 95 (attribute_tag -> . ID .)
    BREAK           reduce using rule 95 (attribute_tag -> . ID .)
    NEXT            reduce using rule 95 (attribute_tag -> . ID .)
    {               reduce using rule 95 (attribute_tag -> . ID .)
    PRINT           reduce using rule 95 (attribute_tag -> . ID .)
    IF              reduce using rule 95 (attribute_tag -> . ID .)
    FOR             reduce using rule 95 (attribute_tag -> . ID .)
    WHERE           reduce using rule 95 (attribute_tag -> . ID .)
    SWITCH          reduce using rule 95 (attribute_tag -> . ID .)
    FUNCTION        reduce using rule 95 (attribute_tag -> . ID .)
    DO              reduce using rule 95 (attribute_tag -> . ID .)
    LOOP            reduce using rule 95 (attribute_tag -> . ID .)
    WITH            reduce using rule 95 (attribute_tag -> . ID .)
    ID              reduce using rule 95 (attribute_tag -> . ID .)
    ITEM_TAG        reduce using rule 95 (attribute_tag -> . ID .)
    INTEGER         reduce using rule 95 (attribute_tag -> . ID .)
    HEXINT          reduce using rule 95 (attribute_tag -> . ID .)
    OCTINT          reduce using rule 95 (attribute_tag -> . ID .)
    BININT          reduce using rule 95 (attribute_tag -> . ID .)
    IMAGINARY       reduce using rule 95 (attribute_tag -> . ID .)
    STRPREFIX       reduce using rule 95 (attribute_tag -> . ID .)
    SHORTSTRING     reduce using rule 95 (attribute_tag -> . ID .)
    LONGSTRING      reduce using rule 95 (attribute_tag -> . ID .)
    `               reduce using rule 95 (attribute_tag -> . ID .)
    ,               reduce using rule 95 (attribute_tag -> . ID .)
    ;               reduce using rule 95 (attribute_tag -> . ID .)
    $end            reduce using rule 95 (attribute_tag -> . ID .)
    }               reduce using rule 95 (attribute_tag -> . ID .)
    ELSE            reduce using rule 95 (attribute_tag -> . ID .)
    DEFAULT         reduce using rule 95 (attribute_tag -> . ID .)
    CASE            reduce using rule 95 (attribute_tag -> . ID .)
    )               reduce using rule 95 (attribute_tag -> . ID .)
    ]               reduce using rule 95 (attribute_tag -> . ID .)
    :               reduce using rule 95 (attribute_tag -> . ID .)
    AUGOP           reduce using rule 95 (attribute_tag -> . ID .)
    =               reduce using rule 95 (attribute_tag -> . ID .)


state 166

    (105) extended_slicing -> primary [ slice_list . ]
    (107) slice_list -> slice_list . , slice_item

    ]               shift and go to state 211
    ,               shift and go to state 210


state 167

    (100) simple_slicing -> primary [ short_slice . ]
    (111) proper_slice -> short_slice .
    (113) long_slice -> short_slice . :
    (114) long_slice -> short_slice . : expression

  ! shift/reduce conflict for ] resolved as shift
    ]               shift and go to state 212
    ,               reduce using rule 111 (proper_slice -> short_slice .)
    :               shift and go to state 213

  ! ]               [ reduce using rule 111 (proper_slice -> short_slice .) ]


state 168

    (110) slice_item -> ELLIPSIS .

    ]               reduce using rule 110 (slice_item -> ELLIPSIS .)
    ,               reduce using rule 110 (slice_item -> ELLIPSIS .)


state 169

    (101) short_slice -> : .
    (103) short_slice -> : . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    :               reduce using rule 101 (short_slice -> : .)
    ]               reduce using rule 101 (short_slice -> : .)
    ,               reduce using rule 101 (short_slice -> : .)
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 214

state 170

    (112) proper_slice -> long_slice .

    ]               reduce using rule 112 (proper_slice -> long_slice .)
    ,               reduce using rule 112 (proper_slice -> long_slice .)


state 171

    (109) slice_item -> proper_slice .

    ]               reduce using rule 109 (slice_item -> proper_slice .)
    ,               reduce using rule 109 (slice_item -> proper_slice .)


state 172

    (97) subscription -> primary [ expression_list . ]
    (17) expression_list -> expression_list . , expression

    ]               shift and go to state 215
    ,               shift and go to state 145


state 173

    (106) slice_list -> slice_item .

    ]               reduce using rule 106 (slice_list -> slice_item .)
    ,               reduce using rule 106 (slice_list -> slice_item .)


state 174

    (16) expression_list -> expression .
    (102) short_slice -> expression . : expression
    (104) short_slice -> expression . :
    (108) slice_item -> expression .

  ! reduce/reduce conflict for ] resolved using rule 16 (expression_list -> expression .)
  ! reduce/reduce conflict for , resolved using rule 16 (expression_list -> expression .)
    ]               reduce using rule 16 (expression_list -> expression .)
    ,               reduce using rule 16 (expression_list -> expression .)
    :               shift and go to state 216

  ! ]               [ reduce using rule 108 (slice_item -> expression .) ]
  ! ,               [ reduce using rule 108 (slice_item -> expression .) ]


state 175

    (155) switch_stmt -> SWITCH ID open_brace . caselist DEFAULT suite close_brace
    (156) caselist -> . CASE target_list suite
    (157) caselist -> . caselist CASE target_list suite

    CASE            shift and go to state 217

    caselist                       shift and go to state 218

state 176

    (120) augmented_assignment_stmt -> target AUGOP expression_list .
    (17) expression_list -> expression_list . , expression

    BREAK           reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    NEXT            reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    IF              reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    FOR             reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    WHERE           reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    SWITCH          reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    FUNCTION        reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    PRINT           reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    DO              reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    LOOP            reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    WITH            reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    (               reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    [               reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    ID              reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    ITEM_TAG        reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    INTEGER         reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    HEXINT          reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    OCTINT          reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    BININT          reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    REAL            reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    IMAGINARY       reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    STRPREFIX       reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    SHORTSTRING     reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    LONGSTRING      reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    `               reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    $end            reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    }               reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    ELSE            reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    DEFAULT         reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    CASE            reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    ;               reduce using rule 120 (augmented_assignment_stmt -> target AUGOP expression_list .)
    ,               shift and go to state 145


state 177

    (150) do_stmt_head -> DO ID = . expression , expression
    (151) do_stmt_head -> DO ID = . expression , expression , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 219

state 178

    (135) if_stmt -> IF expression suite .

    BREAK           reduce using rule 135 (if_stmt -> IF expression suite .)
    NEXT            reduce using rule 135 (if_stmt -> IF expression suite .)
    IF              reduce using rule 135 (if_stmt -> IF expression suite .)
    FOR             reduce using rule 135 (if_stmt -> IF expression suite .)
    WHERE           reduce using rule 135 (if_stmt -> IF expression suite .)
    SWITCH          reduce using rule 135 (if_stmt -> IF expression suite .)
    FUNCTION        reduce using rule 135 (if_stmt -> IF expression suite .)
    PRINT           reduce using rule 135 (if_stmt -> IF expression suite .)
    DO              reduce using rule 135 (if_stmt -> IF expression suite .)
    LOOP            reduce using rule 135 (if_stmt -> IF expression suite .)
    WITH            reduce using rule 135 (if_stmt -> IF expression suite .)
    (               reduce using rule 135 (if_stmt -> IF expression suite .)
    [               reduce using rule 135 (if_stmt -> IF expression suite .)
    ID              reduce using rule 135 (if_stmt -> IF expression suite .)
    ITEM_TAG        reduce using rule 135 (if_stmt -> IF expression suite .)
    INTEGER         reduce using rule 135 (if_stmt -> IF expression suite .)
    HEXINT          reduce using rule 135 (if_stmt -> IF expression suite .)
    OCTINT          reduce using rule 135 (if_stmt -> IF expression suite .)
    BININT          reduce using rule 135 (if_stmt -> IF expression suite .)
    REAL            reduce using rule 135 (if_stmt -> IF expression suite .)
    IMAGINARY       reduce using rule 135 (if_stmt -> IF expression suite .)
    STRPREFIX       reduce using rule 135 (if_stmt -> IF expression suite .)
    SHORTSTRING     reduce using rule 135 (if_stmt -> IF expression suite .)
    LONGSTRING      reduce using rule 135 (if_stmt -> IF expression suite .)
    `               reduce using rule 135 (if_stmt -> IF expression suite .)
    $end            reduce using rule 135 (if_stmt -> IF expression suite .)
    }               reduce using rule 135 (if_stmt -> IF expression suite .)
    ELSE            reduce using rule 135 (if_stmt -> IF expression suite .)
    DEFAULT         reduce using rule 135 (if_stmt -> IF expression suite .)
    CASE            reduce using rule 135 (if_stmt -> IF expression suite .)


state 179

    (7) stmt_list -> stmt_list ; simple_stmt .
    (8) stmt_list -> stmt_list ; simple_stmt . ;

  ! shift/reduce conflict for ; resolved as shift
    }               reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    BREAK           reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    NEXT            reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    IF              reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    FOR             reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    WHERE           reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    SWITCH          reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    FUNCTION        reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    PRINT           reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    DO              reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    LOOP            reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    WITH            reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    (               reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    [               reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    ID              reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    ITEM_TAG        reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    INTEGER         reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    HEXINT          reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    OCTINT          reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    BININT          reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    REAL            reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    IMAGINARY       reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    STRPREFIX       reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    SHORTSTRING     reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    LONGSTRING      reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    `               reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    $end            reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .)
    ;               shift and go to state 220

  ! ;               [ reduce using rule 7 (stmt_list -> stmt_list ; simple_stmt .) ]


state 180

    (124) assignment_stmt -> target_list = expression_list .
    (17) expression_list -> expression_list . , expression

    BREAK           reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    NEXT            reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    IF              reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    FOR             reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    WHERE           reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    SWITCH          reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    FUNCTION        reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    PRINT           reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    DO              reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    LOOP            reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    WITH            reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    (               reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    [               reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    ID              reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    ITEM_TAG        reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    INTEGER         reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    HEXINT          reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    OCTINT          reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    BININT          reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    REAL            reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    IMAGINARY       reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    STRPREFIX       reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    SHORTSTRING     reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    LONGSTRING      reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    `               reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    $end            reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    }               reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    ELSE            reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    DEFAULT         reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    CASE            reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    ;               reduce using rule 124 (assignment_stmt -> target_list = expression_list .)
    ,               shift and go to state 145


state 181

    (126) target_list -> target_list , target .

    =               reduce using rule 126 (target_list -> target_list , target .)
    ,               reduce using rule 126 (target_list -> target_list , target .)
    )               reduce using rule 126 (target_list -> target_list , target .)
    BREAK           reduce using rule 126 (target_list -> target_list , target .)
    NEXT            reduce using rule 126 (target_list -> target_list , target .)
    {               reduce using rule 126 (target_list -> target_list , target .)
    PRINT           reduce using rule 126 (target_list -> target_list , target .)
    IF              reduce using rule 126 (target_list -> target_list , target .)
    FOR             reduce using rule 126 (target_list -> target_list , target .)
    WHERE           reduce using rule 126 (target_list -> target_list , target .)
    SWITCH          reduce using rule 126 (target_list -> target_list , target .)
    FUNCTION        reduce using rule 126 (target_list -> target_list , target .)
    (               reduce using rule 126 (target_list -> target_list , target .)
    [               reduce using rule 126 (target_list -> target_list , target .)
    DO              reduce using rule 126 (target_list -> target_list , target .)
    LOOP            reduce using rule 126 (target_list -> target_list , target .)
    WITH            reduce using rule 126 (target_list -> target_list , target .)
    ID              reduce using rule 126 (target_list -> target_list , target .)
    ITEM_TAG        reduce using rule 126 (target_list -> target_list , target .)
    INTEGER         reduce using rule 126 (target_list -> target_list , target .)
    HEXINT          reduce using rule 126 (target_list -> target_list , target .)
    OCTINT          reduce using rule 126 (target_list -> target_list , target .)
    BININT          reduce using rule 126 (target_list -> target_list , target .)
    REAL            reduce using rule 126 (target_list -> target_list , target .)
    IMAGINARY       reduce using rule 126 (target_list -> target_list , target .)
    STRPREFIX       reduce using rule 126 (target_list -> target_list , target .)
    SHORTSTRING     reduce using rule 126 (target_list -> target_list , target .)
    LONGSTRING      reduce using rule 126 (target_list -> target_list , target .)
    `               reduce using rule 126 (target_list -> target_list , target .)
    ]               reduce using rule 126 (target_list -> target_list , target .)
    IN              reduce using rule 126 (target_list -> target_list , target .)


state 182

    (139) suite -> open_brace statement_block close_brace .

    BREAK           reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    NEXT            reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    IF              reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    FOR             reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    WHERE           reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    SWITCH          reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    FUNCTION        reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    PRINT           reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    DO              reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    LOOP            reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    WITH            reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    (               reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    [               reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    ID              reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    ITEM_TAG        reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    INTEGER         reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    HEXINT          reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    OCTINT          reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    BININT          reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    REAL            reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    IMAGINARY       reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    STRPREFIX       reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    SHORTSTRING     reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    LONGSTRING      reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    `               reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    $end            reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    }               reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    ELSE            reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    DEFAULT         reduce using rule 139 (suite -> open_brace statement_block close_brace .)
    CASE            reduce using rule 139 (suite -> open_brace statement_block close_brace .)


state 183

    (143) statement_block -> statement_block statement .

    }               reduce using rule 143 (statement_block -> statement_block statement .)
    BREAK           reduce using rule 143 (statement_block -> statement_block statement .)
    NEXT            reduce using rule 143 (statement_block -> statement_block statement .)
    IF              reduce using rule 143 (statement_block -> statement_block statement .)
    FOR             reduce using rule 143 (statement_block -> statement_block statement .)
    WHERE           reduce using rule 143 (statement_block -> statement_block statement .)
    SWITCH          reduce using rule 143 (statement_block -> statement_block statement .)
    FUNCTION        reduce using rule 143 (statement_block -> statement_block statement .)
    PRINT           reduce using rule 143 (statement_block -> statement_block statement .)
    DO              reduce using rule 143 (statement_block -> statement_block statement .)
    LOOP            reduce using rule 143 (statement_block -> statement_block statement .)
    WITH            reduce using rule 143 (statement_block -> statement_block statement .)
    (               reduce using rule 143 (statement_block -> statement_block statement .)
    [               reduce using rule 143 (statement_block -> statement_block statement .)
    ID              reduce using rule 143 (statement_block -> statement_block statement .)
    ITEM_TAG        reduce using rule 143 (statement_block -> statement_block statement .)
    INTEGER         reduce using rule 143 (statement_block -> statement_block statement .)
    HEXINT          reduce using rule 143 (statement_block -> statement_block statement .)
    OCTINT          reduce using rule 143 (statement_block -> statement_block statement .)
    BININT          reduce using rule 143 (statement_block -> statement_block statement .)
    REAL            reduce using rule 143 (statement_block -> statement_block statement .)
    IMAGINARY       reduce using rule 143 (statement_block -> statement_block statement .)
    STRPREFIX       reduce using rule 143 (statement_block -> statement_block statement .)
    SHORTSTRING     reduce using rule 143 (statement_block -> statement_block statement .)
    LONGSTRING      reduce using rule 143 (statement_block -> statement_block statement .)
    `               reduce using rule 143 (statement_block -> statement_block statement .)


state 184

    (141) close_brace -> } .

    BREAK           reduce using rule 141 (close_brace -> } .)
    NEXT            reduce using rule 141 (close_brace -> } .)
    IF              reduce using rule 141 (close_brace -> } .)
    FOR             reduce using rule 141 (close_brace -> } .)
    WHERE           reduce using rule 141 (close_brace -> } .)
    SWITCH          reduce using rule 141 (close_brace -> } .)
    FUNCTION        reduce using rule 141 (close_brace -> } .)
    PRINT           reduce using rule 141 (close_brace -> } .)
    DO              reduce using rule 141 (close_brace -> } .)
    LOOP            reduce using rule 141 (close_brace -> } .)
    WITH            reduce using rule 141 (close_brace -> } .)
    (               reduce using rule 141 (close_brace -> } .)
    [               reduce using rule 141 (close_brace -> } .)
    ID              reduce using rule 141 (close_brace -> } .)
    ITEM_TAG        reduce using rule 141 (close_brace -> } .)
    INTEGER         reduce using rule 141 (close_brace -> } .)
    HEXINT          reduce using rule 141 (close_brace -> } .)
    OCTINT          reduce using rule 141 (close_brace -> } .)
    BININT          reduce using rule 141 (close_brace -> } .)
    REAL            reduce using rule 141 (close_brace -> } .)
    IMAGINARY       reduce using rule 141 (close_brace -> } .)
    STRPREFIX       reduce using rule 141 (close_brace -> } .)
    SHORTSTRING     reduce using rule 141 (close_brace -> } .)
    LONGSTRING      reduce using rule 141 (close_brace -> } .)
    `               reduce using rule 141 (close_brace -> } .)
    $end            reduce using rule 141 (close_brace -> } .)
    }               reduce using rule 141 (close_brace -> } .)
    ELSE            reduce using rule 141 (close_brace -> } .)
    DEFAULT         reduce using rule 141 (close_brace -> } .)
    CASE            reduce using rule 141 (close_brace -> } .)


state 185

    (153) with_head -> WITH ID AS ID .

    BREAK           reduce using rule 153 (with_head -> WITH ID AS ID .)
    NEXT            reduce using rule 153 (with_head -> WITH ID AS ID .)
    {               reduce using rule 153 (with_head -> WITH ID AS ID .)
    PRINT           reduce using rule 153 (with_head -> WITH ID AS ID .)
    IF              reduce using rule 153 (with_head -> WITH ID AS ID .)
    FOR             reduce using rule 153 (with_head -> WITH ID AS ID .)
    WHERE           reduce using rule 153 (with_head -> WITH ID AS ID .)
    SWITCH          reduce using rule 153 (with_head -> WITH ID AS ID .)
    FUNCTION        reduce using rule 153 (with_head -> WITH ID AS ID .)
    (               reduce using rule 153 (with_head -> WITH ID AS ID .)
    [               reduce using rule 153 (with_head -> WITH ID AS ID .)
    DO              reduce using rule 153 (with_head -> WITH ID AS ID .)
    LOOP            reduce using rule 153 (with_head -> WITH ID AS ID .)
    WITH            reduce using rule 153 (with_head -> WITH ID AS ID .)
    ID              reduce using rule 153 (with_head -> WITH ID AS ID .)
    ITEM_TAG        reduce using rule 153 (with_head -> WITH ID AS ID .)
    INTEGER         reduce using rule 153 (with_head -> WITH ID AS ID .)
    HEXINT          reduce using rule 153 (with_head -> WITH ID AS ID .)
    OCTINT          reduce using rule 153 (with_head -> WITH ID AS ID .)
    BININT          reduce using rule 153 (with_head -> WITH ID AS ID .)
    REAL            reduce using rule 153 (with_head -> WITH ID AS ID .)
    IMAGINARY       reduce using rule 153 (with_head -> WITH ID AS ID .)
    STRPREFIX       reduce using rule 153 (with_head -> WITH ID AS ID .)
    SHORTSTRING     reduce using rule 153 (with_head -> WITH ID AS ID .)
    LONGSTRING      reduce using rule 153 (with_head -> WITH ID AS ID .)
    `               reduce using rule 153 (with_head -> WITH ID AS ID .)


state 186

    (49) power -> primary POWER u_expr .

    *               reduce using rule 49 (power -> primary POWER u_expr .)
    /               reduce using rule 49 (power -> primary POWER u_expr .)
    ^               reduce using rule 49 (power -> primary POWER u_expr .)
    +               reduce using rule 49 (power -> primary POWER u_expr .)
    -               reduce using rule 49 (power -> primary POWER u_expr .)
    <               reduce using rule 49 (power -> primary POWER u_expr .)
    >               reduce using rule 49 (power -> primary POWER u_expr .)
    GTE             reduce using rule 49 (power -> primary POWER u_expr .)
    LTE             reduce using rule 49 (power -> primary POWER u_expr .)
    NEQ             reduce using rule 49 (power -> primary POWER u_expr .)
    ISEQUAL         reduce using rule 49 (power -> primary POWER u_expr .)
    IN              reduce using rule 49 (power -> primary POWER u_expr .)
    NOT             reduce using rule 49 (power -> primary POWER u_expr .)
    AND             reduce using rule 49 (power -> primary POWER u_expr .)
    OR              reduce using rule 49 (power -> primary POWER u_expr .)
    )               reduce using rule 49 (power -> primary POWER u_expr .)
    ,               reduce using rule 49 (power -> primary POWER u_expr .)
    BREAK           reduce using rule 49 (power -> primary POWER u_expr .)
    NEXT            reduce using rule 49 (power -> primary POWER u_expr .)
    {               reduce using rule 49 (power -> primary POWER u_expr .)
    PRINT           reduce using rule 49 (power -> primary POWER u_expr .)
    IF              reduce using rule 49 (power -> primary POWER u_expr .)
    FOR             reduce using rule 49 (power -> primary POWER u_expr .)
    WHERE           reduce using rule 49 (power -> primary POWER u_expr .)
    SWITCH          reduce using rule 49 (power -> primary POWER u_expr .)
    FUNCTION        reduce using rule 49 (power -> primary POWER u_expr .)
    (               reduce using rule 49 (power -> primary POWER u_expr .)
    [               reduce using rule 49 (power -> primary POWER u_expr .)
    DO              reduce using rule 49 (power -> primary POWER u_expr .)
    LOOP            reduce using rule 49 (power -> primary POWER u_expr .)
    WITH            reduce using rule 49 (power -> primary POWER u_expr .)
    ID              reduce using rule 49 (power -> primary POWER u_expr .)
    ITEM_TAG        reduce using rule 49 (power -> primary POWER u_expr .)
    INTEGER         reduce using rule 49 (power -> primary POWER u_expr .)
    HEXINT          reduce using rule 49 (power -> primary POWER u_expr .)
    OCTINT          reduce using rule 49 (power -> primary POWER u_expr .)
    BININT          reduce using rule 49 (power -> primary POWER u_expr .)
    REAL            reduce using rule 49 (power -> primary POWER u_expr .)
    IMAGINARY       reduce using rule 49 (power -> primary POWER u_expr .)
    STRPREFIX       reduce using rule 49 (power -> primary POWER u_expr .)
    SHORTSTRING     reduce using rule 49 (power -> primary POWER u_expr .)
    LONGSTRING      reduce using rule 49 (power -> primary POWER u_expr .)
    `               reduce using rule 49 (power -> primary POWER u_expr .)
    ;               reduce using rule 49 (power -> primary POWER u_expr .)
    $end            reduce using rule 49 (power -> primary POWER u_expr .)
    }               reduce using rule 49 (power -> primary POWER u_expr .)
    ELSE            reduce using rule 49 (power -> primary POWER u_expr .)
    DEFAULT         reduce using rule 49 (power -> primary POWER u_expr .)
    CASE            reduce using rule 49 (power -> primary POWER u_expr .)
    ]               reduce using rule 49 (power -> primary POWER u_expr .)
    :               reduce using rule 49 (power -> primary POWER u_expr .)


state 187

    (29) comparison -> a_expr comp_operator a_expr .
    (39) a_expr -> a_expr . + m_expr
    (40) a_expr -> a_expr . - m_expr

    AND             reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    OR              reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    )               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    ,               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    ]               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    FOR             reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    IF              reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    ;               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    BREAK           reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    NEXT            reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    WHERE           reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    SWITCH          reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    FUNCTION        reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    PRINT           reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    DO              reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    LOOP            reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    WITH            reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    (               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    [               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    ID              reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    ITEM_TAG        reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    INTEGER         reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    HEXINT          reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    OCTINT          reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    BININT          reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    REAL            reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    IMAGINARY       reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    STRPREFIX       reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    SHORTSTRING     reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    LONGSTRING      reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    `               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    $end            reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    }               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    ELSE            reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    DEFAULT         reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    CASE            reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    {               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    :               reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    IN              reduce using rule 29 (comparison -> a_expr comp_operator a_expr .)
    +               shift and go to state 129
    -               shift and go to state 131


state 188

    (39) a_expr -> a_expr + m_expr .
    (42) m_expr -> m_expr . * u_expr
    (43) m_expr -> m_expr . / u_expr
    (44) m_expr -> m_expr . ^ u_expr

    +               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    -               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    <               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    >               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    GTE             reduce using rule 39 (a_expr -> a_expr + m_expr .)
    LTE             reduce using rule 39 (a_expr -> a_expr + m_expr .)
    NEQ             reduce using rule 39 (a_expr -> a_expr + m_expr .)
    ISEQUAL         reduce using rule 39 (a_expr -> a_expr + m_expr .)
    IN              reduce using rule 39 (a_expr -> a_expr + m_expr .)
    NOT             reduce using rule 39 (a_expr -> a_expr + m_expr .)
    AND             reduce using rule 39 (a_expr -> a_expr + m_expr .)
    OR              reduce using rule 39 (a_expr -> a_expr + m_expr .)
    )               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    ,               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    BREAK           reduce using rule 39 (a_expr -> a_expr + m_expr .)
    NEXT            reduce using rule 39 (a_expr -> a_expr + m_expr .)
    {               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    PRINT           reduce using rule 39 (a_expr -> a_expr + m_expr .)
    IF              reduce using rule 39 (a_expr -> a_expr + m_expr .)
    FOR             reduce using rule 39 (a_expr -> a_expr + m_expr .)
    WHERE           reduce using rule 39 (a_expr -> a_expr + m_expr .)
    SWITCH          reduce using rule 39 (a_expr -> a_expr + m_expr .)
    FUNCTION        reduce using rule 39 (a_expr -> a_expr + m_expr .)
    (               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    [               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    DO              reduce using rule 39 (a_expr -> a_expr + m_expr .)
    LOOP            reduce using rule 39 (a_expr -> a_expr + m_expr .)
    WITH            reduce using rule 39 (a_expr -> a_expr + m_expr .)
    ID              reduce using rule 39 (a_expr -> a_expr + m_expr .)
    ITEM_TAG        reduce using rule 39 (a_expr -> a_expr + m_expr .)
    INTEGER         reduce using rule 39 (a_expr -> a_expr + m_expr .)
    HEXINT          reduce using rule 39 (a_expr -> a_expr + m_expr .)
    OCTINT          reduce using rule 39 (a_expr -> a_expr + m_expr .)
    BININT          reduce using rule 39 (a_expr -> a_expr + m_expr .)
    REAL            reduce using rule 39 (a_expr -> a_expr + m_expr .)
    IMAGINARY       reduce using rule 39 (a_expr -> a_expr + m_expr .)
    STRPREFIX       reduce using rule 39 (a_expr -> a_expr + m_expr .)
    SHORTSTRING     reduce using rule 39 (a_expr -> a_expr + m_expr .)
    LONGSTRING      reduce using rule 39 (a_expr -> a_expr + m_expr .)
    `               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    ;               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    $end            reduce using rule 39 (a_expr -> a_expr + m_expr .)
    }               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    ELSE            reduce using rule 39 (a_expr -> a_expr + m_expr .)
    DEFAULT         reduce using rule 39 (a_expr -> a_expr + m_expr .)
    CASE            reduce using rule 39 (a_expr -> a_expr + m_expr .)
    ]               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    :               reduce using rule 39 (a_expr -> a_expr + m_expr .)
    *               shift and go to state 141
    /               shift and go to state 142
    ^               shift and go to state 143


state 189

    (40) a_expr -> a_expr - m_expr .
    (42) m_expr -> m_expr . * u_expr
    (43) m_expr -> m_expr . / u_expr
    (44) m_expr -> m_expr . ^ u_expr

    +               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    -               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    <               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    >               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    GTE             reduce using rule 40 (a_expr -> a_expr - m_expr .)
    LTE             reduce using rule 40 (a_expr -> a_expr - m_expr .)
    NEQ             reduce using rule 40 (a_expr -> a_expr - m_expr .)
    ISEQUAL         reduce using rule 40 (a_expr -> a_expr - m_expr .)
    IN              reduce using rule 40 (a_expr -> a_expr - m_expr .)
    NOT             reduce using rule 40 (a_expr -> a_expr - m_expr .)
    AND             reduce using rule 40 (a_expr -> a_expr - m_expr .)
    OR              reduce using rule 40 (a_expr -> a_expr - m_expr .)
    )               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    ,               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    BREAK           reduce using rule 40 (a_expr -> a_expr - m_expr .)
    NEXT            reduce using rule 40 (a_expr -> a_expr - m_expr .)
    {               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    PRINT           reduce using rule 40 (a_expr -> a_expr - m_expr .)
    IF              reduce using rule 40 (a_expr -> a_expr - m_expr .)
    FOR             reduce using rule 40 (a_expr -> a_expr - m_expr .)
    WHERE           reduce using rule 40 (a_expr -> a_expr - m_expr .)
    SWITCH          reduce using rule 40 (a_expr -> a_expr - m_expr .)
    FUNCTION        reduce using rule 40 (a_expr -> a_expr - m_expr .)
    (               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    [               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    DO              reduce using rule 40 (a_expr -> a_expr - m_expr .)
    LOOP            reduce using rule 40 (a_expr -> a_expr - m_expr .)
    WITH            reduce using rule 40 (a_expr -> a_expr - m_expr .)
    ID              reduce using rule 40 (a_expr -> a_expr - m_expr .)
    ITEM_TAG        reduce using rule 40 (a_expr -> a_expr - m_expr .)
    INTEGER         reduce using rule 40 (a_expr -> a_expr - m_expr .)
    HEXINT          reduce using rule 40 (a_expr -> a_expr - m_expr .)
    OCTINT          reduce using rule 40 (a_expr -> a_expr - m_expr .)
    BININT          reduce using rule 40 (a_expr -> a_expr - m_expr .)
    REAL            reduce using rule 40 (a_expr -> a_expr - m_expr .)
    IMAGINARY       reduce using rule 40 (a_expr -> a_expr - m_expr .)
    STRPREFIX       reduce using rule 40 (a_expr -> a_expr - m_expr .)
    SHORTSTRING     reduce using rule 40 (a_expr -> a_expr - m_expr .)
    LONGSTRING      reduce using rule 40 (a_expr -> a_expr - m_expr .)
    `               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    ;               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    $end            reduce using rule 40 (a_expr -> a_expr - m_expr .)
    }               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    ELSE            reduce using rule 40 (a_expr -> a_expr - m_expr .)
    DEFAULT         reduce using rule 40 (a_expr -> a_expr - m_expr .)
    CASE            reduce using rule 40 (a_expr -> a_expr - m_expr .)
    ]               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    :               reduce using rule 40 (a_expr -> a_expr - m_expr .)
    *               shift and go to state 141
    /               shift and go to state 142
    ^               shift and go to state 143


state 190

    (37) comp_operator -> NOT IN .

    -               reduce using rule 37 (comp_operator -> NOT IN .)
    +               reduce using rule 37 (comp_operator -> NOT IN .)
    ID              reduce using rule 37 (comp_operator -> NOT IN .)
    ITEM_TAG        reduce using rule 37 (comp_operator -> NOT IN .)
    INTEGER         reduce using rule 37 (comp_operator -> NOT IN .)
    HEXINT          reduce using rule 37 (comp_operator -> NOT IN .)
    OCTINT          reduce using rule 37 (comp_operator -> NOT IN .)
    BININT          reduce using rule 37 (comp_operator -> NOT IN .)
    REAL            reduce using rule 37 (comp_operator -> NOT IN .)
    IMAGINARY       reduce using rule 37 (comp_operator -> NOT IN .)
    STRPREFIX       reduce using rule 37 (comp_operator -> NOT IN .)
    SHORTSTRING     reduce using rule 37 (comp_operator -> NOT IN .)
    LONGSTRING      reduce using rule 37 (comp_operator -> NOT IN .)
    (               reduce using rule 37 (comp_operator -> NOT IN .)
    `               reduce using rule 37 (comp_operator -> NOT IN .)
    [               reduce using rule 37 (comp_operator -> NOT IN .)


state 191

    (25) and_test -> and_test AND not_test .

    AND             reduce using rule 25 (and_test -> and_test AND not_test .)
    OR              reduce using rule 25 (and_test -> and_test AND not_test .)
    )               reduce using rule 25 (and_test -> and_test AND not_test .)
    ,               reduce using rule 25 (and_test -> and_test AND not_test .)
    BREAK           reduce using rule 25 (and_test -> and_test AND not_test .)
    NEXT            reduce using rule 25 (and_test -> and_test AND not_test .)
    {               reduce using rule 25 (and_test -> and_test AND not_test .)
    PRINT           reduce using rule 25 (and_test -> and_test AND not_test .)
    IF              reduce using rule 25 (and_test -> and_test AND not_test .)
    FOR             reduce using rule 25 (and_test -> and_test AND not_test .)
    WHERE           reduce using rule 25 (and_test -> and_test AND not_test .)
    SWITCH          reduce using rule 25 (and_test -> and_test AND not_test .)
    FUNCTION        reduce using rule 25 (and_test -> and_test AND not_test .)
    (               reduce using rule 25 (and_test -> and_test AND not_test .)
    [               reduce using rule 25 (and_test -> and_test AND not_test .)
    DO              reduce using rule 25 (and_test -> and_test AND not_test .)
    LOOP            reduce using rule 25 (and_test -> and_test AND not_test .)
    WITH            reduce using rule 25 (and_test -> and_test AND not_test .)
    ID              reduce using rule 25 (and_test -> and_test AND not_test .)
    ITEM_TAG        reduce using rule 25 (and_test -> and_test AND not_test .)
    INTEGER         reduce using rule 25 (and_test -> and_test AND not_test .)
    HEXINT          reduce using rule 25 (and_test -> and_test AND not_test .)
    OCTINT          reduce using rule 25 (and_test -> and_test AND not_test .)
    BININT          reduce using rule 25 (and_test -> and_test AND not_test .)
    REAL            reduce using rule 25 (and_test -> and_test AND not_test .)
    IMAGINARY       reduce using rule 25 (and_test -> and_test AND not_test .)
    STRPREFIX       reduce using rule 25 (and_test -> and_test AND not_test .)
    SHORTSTRING     reduce using rule 25 (and_test -> and_test AND not_test .)
    LONGSTRING      reduce using rule 25 (and_test -> and_test AND not_test .)
    `               reduce using rule 25 (and_test -> and_test AND not_test .)
    ;               reduce using rule 25 (and_test -> and_test AND not_test .)
    $end            reduce using rule 25 (and_test -> and_test AND not_test .)
    }               reduce using rule 25 (and_test -> and_test AND not_test .)
    ELSE            reduce using rule 25 (and_test -> and_test AND not_test .)
    DEFAULT         reduce using rule 25 (and_test -> and_test AND not_test .)
    CASE            reduce using rule 25 (and_test -> and_test AND not_test .)
    ]               reduce using rule 25 (and_test -> and_test AND not_test .)
    :               reduce using rule 25 (and_test -> and_test AND not_test .)
    IN              reduce using rule 25 (and_test -> and_test AND not_test .)


state 192

    (42) m_expr -> m_expr * u_expr .

    *               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    /               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ^               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    +               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    -               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    <               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    >               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    GTE             reduce using rule 42 (m_expr -> m_expr * u_expr .)
    LTE             reduce using rule 42 (m_expr -> m_expr * u_expr .)
    NEQ             reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ISEQUAL         reduce using rule 42 (m_expr -> m_expr * u_expr .)
    IN              reduce using rule 42 (m_expr -> m_expr * u_expr .)
    NOT             reduce using rule 42 (m_expr -> m_expr * u_expr .)
    AND             reduce using rule 42 (m_expr -> m_expr * u_expr .)
    OR              reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ;               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    BREAK           reduce using rule 42 (m_expr -> m_expr * u_expr .)
    NEXT            reduce using rule 42 (m_expr -> m_expr * u_expr .)
    IF              reduce using rule 42 (m_expr -> m_expr * u_expr .)
    FOR             reduce using rule 42 (m_expr -> m_expr * u_expr .)
    WHERE           reduce using rule 42 (m_expr -> m_expr * u_expr .)
    SWITCH          reduce using rule 42 (m_expr -> m_expr * u_expr .)
    FUNCTION        reduce using rule 42 (m_expr -> m_expr * u_expr .)
    PRINT           reduce using rule 42 (m_expr -> m_expr * u_expr .)
    DO              reduce using rule 42 (m_expr -> m_expr * u_expr .)
    LOOP            reduce using rule 42 (m_expr -> m_expr * u_expr .)
    WITH            reduce using rule 42 (m_expr -> m_expr * u_expr .)
    (               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    [               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ID              reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ITEM_TAG        reduce using rule 42 (m_expr -> m_expr * u_expr .)
    INTEGER         reduce using rule 42 (m_expr -> m_expr * u_expr .)
    HEXINT          reduce using rule 42 (m_expr -> m_expr * u_expr .)
    OCTINT          reduce using rule 42 (m_expr -> m_expr * u_expr .)
    BININT          reduce using rule 42 (m_expr -> m_expr * u_expr .)
    REAL            reduce using rule 42 (m_expr -> m_expr * u_expr .)
    IMAGINARY       reduce using rule 42 (m_expr -> m_expr * u_expr .)
    STRPREFIX       reduce using rule 42 (m_expr -> m_expr * u_expr .)
    SHORTSTRING     reduce using rule 42 (m_expr -> m_expr * u_expr .)
    LONGSTRING      reduce using rule 42 (m_expr -> m_expr * u_expr .)
    `               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    $end            reduce using rule 42 (m_expr -> m_expr * u_expr .)
    }               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ELSE            reduce using rule 42 (m_expr -> m_expr * u_expr .)
    DEFAULT         reduce using rule 42 (m_expr -> m_expr * u_expr .)
    CASE            reduce using rule 42 (m_expr -> m_expr * u_expr .)
    )               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ,               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    {               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    ]               reduce using rule 42 (m_expr -> m_expr * u_expr .)
    :               reduce using rule 42 (m_expr -> m_expr * u_expr .)


state 193

    (43) m_expr -> m_expr / u_expr .

    *               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    /               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ^               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    +               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    -               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    <               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    >               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    GTE             reduce using rule 43 (m_expr -> m_expr / u_expr .)
    LTE             reduce using rule 43 (m_expr -> m_expr / u_expr .)
    NEQ             reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ISEQUAL         reduce using rule 43 (m_expr -> m_expr / u_expr .)
    IN              reduce using rule 43 (m_expr -> m_expr / u_expr .)
    NOT             reduce using rule 43 (m_expr -> m_expr / u_expr .)
    AND             reduce using rule 43 (m_expr -> m_expr / u_expr .)
    OR              reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ;               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    BREAK           reduce using rule 43 (m_expr -> m_expr / u_expr .)
    NEXT            reduce using rule 43 (m_expr -> m_expr / u_expr .)
    IF              reduce using rule 43 (m_expr -> m_expr / u_expr .)
    FOR             reduce using rule 43 (m_expr -> m_expr / u_expr .)
    WHERE           reduce using rule 43 (m_expr -> m_expr / u_expr .)
    SWITCH          reduce using rule 43 (m_expr -> m_expr / u_expr .)
    FUNCTION        reduce using rule 43 (m_expr -> m_expr / u_expr .)
    PRINT           reduce using rule 43 (m_expr -> m_expr / u_expr .)
    DO              reduce using rule 43 (m_expr -> m_expr / u_expr .)
    LOOP            reduce using rule 43 (m_expr -> m_expr / u_expr .)
    WITH            reduce using rule 43 (m_expr -> m_expr / u_expr .)
    (               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    [               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ID              reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ITEM_TAG        reduce using rule 43 (m_expr -> m_expr / u_expr .)
    INTEGER         reduce using rule 43 (m_expr -> m_expr / u_expr .)
    HEXINT          reduce using rule 43 (m_expr -> m_expr / u_expr .)
    OCTINT          reduce using rule 43 (m_expr -> m_expr / u_expr .)
    BININT          reduce using rule 43 (m_expr -> m_expr / u_expr .)
    REAL            reduce using rule 43 (m_expr -> m_expr / u_expr .)
    IMAGINARY       reduce using rule 43 (m_expr -> m_expr / u_expr .)
    STRPREFIX       reduce using rule 43 (m_expr -> m_expr / u_expr .)
    SHORTSTRING     reduce using rule 43 (m_expr -> m_expr / u_expr .)
    LONGSTRING      reduce using rule 43 (m_expr -> m_expr / u_expr .)
    `               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    $end            reduce using rule 43 (m_expr -> m_expr / u_expr .)
    }               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ELSE            reduce using rule 43 (m_expr -> m_expr / u_expr .)
    DEFAULT         reduce using rule 43 (m_expr -> m_expr / u_expr .)
    CASE            reduce using rule 43 (m_expr -> m_expr / u_expr .)
    )               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ,               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    {               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    ]               reduce using rule 43 (m_expr -> m_expr / u_expr .)
    :               reduce using rule 43 (m_expr -> m_expr / u_expr .)


state 194

    (44) m_expr -> m_expr ^ u_expr .

    *               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    /               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ^               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    +               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    -               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    <               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    >               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    GTE             reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    LTE             reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    NEQ             reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ISEQUAL         reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    IN              reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    NOT             reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    AND             reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    OR              reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ;               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    BREAK           reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    NEXT            reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    IF              reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    FOR             reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    WHERE           reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    SWITCH          reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    FUNCTION        reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    PRINT           reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    DO              reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    LOOP            reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    WITH            reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    (               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    [               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ID              reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ITEM_TAG        reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    INTEGER         reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    HEXINT          reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    OCTINT          reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    BININT          reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    REAL            reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    IMAGINARY       reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    STRPREFIX       reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    SHORTSTRING     reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    LONGSTRING      reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    `               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    $end            reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    }               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ELSE            reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    DEFAULT         reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    CASE            reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    )               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ,               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    {               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    ]               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)
    :               reduce using rule 44 (m_expr -> m_expr ^ u_expr .)


state 195

    (17) expression_list -> expression_list , expression .

    )               reduce using rule 17 (expression_list -> expression_list , expression .)
    ,               reduce using rule 17 (expression_list -> expression_list , expression .)
    `               reduce using rule 17 (expression_list -> expression_list , expression .)
    IN              reduce using rule 17 (expression_list -> expression_list , expression .)
    ;               reduce using rule 17 (expression_list -> expression_list , expression .)
    BREAK           reduce using rule 17 (expression_list -> expression_list , expression .)
    NEXT            reduce using rule 17 (expression_list -> expression_list , expression .)
    IF              reduce using rule 17 (expression_list -> expression_list , expression .)
    FOR             reduce using rule 17 (expression_list -> expression_list , expression .)
    WHERE           reduce using rule 17 (expression_list -> expression_list , expression .)
    SWITCH          reduce using rule 17 (expression_list -> expression_list , expression .)
    FUNCTION        reduce using rule 17 (expression_list -> expression_list , expression .)
    PRINT           reduce using rule 17 (expression_list -> expression_list , expression .)
    DO              reduce using rule 17 (expression_list -> expression_list , expression .)
    LOOP            reduce using rule 17 (expression_list -> expression_list , expression .)
    WITH            reduce using rule 17 (expression_list -> expression_list , expression .)
    (               reduce using rule 17 (expression_list -> expression_list , expression .)
    [               reduce using rule 17 (expression_list -> expression_list , expression .)
    ID              reduce using rule 17 (expression_list -> expression_list , expression .)
    ITEM_TAG        reduce using rule 17 (expression_list -> expression_list , expression .)
    INTEGER         reduce using rule 17 (expression_list -> expression_list , expression .)
    HEXINT          reduce using rule 17 (expression_list -> expression_list , expression .)
    OCTINT          reduce using rule 17 (expression_list -> expression_list , expression .)
    BININT          reduce using rule 17 (expression_list -> expression_list , expression .)
    REAL            reduce using rule 17 (expression_list -> expression_list , expression .)
    IMAGINARY       reduce using rule 17 (expression_list -> expression_list , expression .)
    STRPREFIX       reduce using rule 17 (expression_list -> expression_list , expression .)
    SHORTSTRING     reduce using rule 17 (expression_list -> expression_list , expression .)
    LONGSTRING      reduce using rule 17 (expression_list -> expression_list , expression .)
    $end            reduce using rule 17 (expression_list -> expression_list , expression .)
    }               reduce using rule 17 (expression_list -> expression_list , expression .)
    ELSE            reduce using rule 17 (expression_list -> expression_list , expression .)
    DEFAULT         reduce using rule 17 (expression_list -> expression_list , expression .)
    CASE            reduce using rule 17 (expression_list -> expression_list , expression .)
    ]               reduce using rule 17 (expression_list -> expression_list , expression .)
    {               reduce using rule 17 (expression_list -> expression_list , expression .)


state 196

    (23) or_test -> or_test OR and_test .
    (25) and_test -> and_test . AND not_test

    ,               reduce using rule 23 (or_test -> or_test OR and_test .)
    OR              reduce using rule 23 (or_test -> or_test OR and_test .)
    FOR             reduce using rule 23 (or_test -> or_test OR and_test .)
    IF              reduce using rule 23 (or_test -> or_test OR and_test .)
    ]               reduce using rule 23 (or_test -> or_test OR and_test .)
    :               reduce using rule 23 (or_test -> or_test OR and_test .)
    IN              reduce using rule 23 (or_test -> or_test OR and_test .)
    ;               reduce using rule 23 (or_test -> or_test OR and_test .)
    BREAK           reduce using rule 23 (or_test -> or_test OR and_test .)
    NEXT            reduce using rule 23 (or_test -> or_test OR and_test .)
    WHERE           reduce using rule 23 (or_test -> or_test OR and_test .)
    SWITCH          reduce using rule 23 (or_test -> or_test OR and_test .)
    FUNCTION        reduce using rule 23 (or_test -> or_test OR and_test .)
    PRINT           reduce using rule 23 (or_test -> or_test OR and_test .)
    DO              reduce using rule 23 (or_test -> or_test OR and_test .)
    LOOP            reduce using rule 23 (or_test -> or_test OR and_test .)
    WITH            reduce using rule 23 (or_test -> or_test OR and_test .)
    (               reduce using rule 23 (or_test -> or_test OR and_test .)
    [               reduce using rule 23 (or_test -> or_test OR and_test .)
    ID              reduce using rule 23 (or_test -> or_test OR and_test .)
    ITEM_TAG        reduce using rule 23 (or_test -> or_test OR and_test .)
    INTEGER         reduce using rule 23 (or_test -> or_test OR and_test .)
    HEXINT          reduce using rule 23 (or_test -> or_test OR and_test .)
    OCTINT          reduce using rule 23 (or_test -> or_test OR and_test .)
    BININT          reduce using rule 23 (or_test -> or_test OR and_test .)
    REAL            reduce using rule 23 (or_test -> or_test OR and_test .)
    IMAGINARY       reduce using rule 23 (or_test -> or_test OR and_test .)
    STRPREFIX       reduce using rule 23 (or_test -> or_test OR and_test .)
    SHORTSTRING     reduce using rule 23 (or_test -> or_test OR and_test .)
    LONGSTRING      reduce using rule 23 (or_test -> or_test OR and_test .)
    `               reduce using rule 23 (or_test -> or_test OR and_test .)
    $end            reduce using rule 23 (or_test -> or_test OR and_test .)
    }               reduce using rule 23 (or_test -> or_test OR and_test .)
    ELSE            reduce using rule 23 (or_test -> or_test OR and_test .)
    DEFAULT         reduce using rule 23 (or_test -> or_test OR and_test .)
    CASE            reduce using rule 23 (or_test -> or_test OR and_test .)
    )               reduce using rule 23 (or_test -> or_test OR and_test .)
    {               reduce using rule 23 (or_test -> or_test OR and_test .)
    AND             shift and go to state 139


state 197

    (154) where_stmt -> WHERE expression suite ELSE . suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 221
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 198

    (146) loop_head -> LOOP ID AS ID .
    (147) loop_head -> LOOP ID AS ID . : ID
    (148) loop_head -> LOOP ID AS ID . : ID comp_operator ID

    BREAK           reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    NEXT            reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    {               reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    PRINT           reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    IF              reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    FOR             reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    WHERE           reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    SWITCH          reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    FUNCTION        reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    (               reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    [               reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    DO              reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    LOOP            reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    WITH            reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    ID              reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    ITEM_TAG        reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    INTEGER         reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    HEXINT          reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    OCTINT          reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    BININT          reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    REAL            reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    IMAGINARY       reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    STRPREFIX       reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    SHORTSTRING     reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    LONGSTRING      reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    `               reduce using rule 146 (loop_head -> LOOP ID AS ID .)
    :               shift and go to state 222


state 199

    (144) for_stmt -> FOR target_list IN expression_list . suite
    (17) expression_list -> expression_list . , expression
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    ,               shift and go to state 145
    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 223
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 200

    (158) funcdef -> FUNCTION ID ( arglist . ) suite
    (160) arglist -> arglist . , ID : list_display

    )               shift and go to state 224
    ,               shift and go to state 225


state 201

    (159) arglist -> ID . : list_display

    :               shift and go to state 226


state 202

    (85) list_for -> FOR expression_list . IN testlist
    (86) list_for -> FOR expression_list . IN testlist list_iter
    (17) expression_list -> expression_list . , expression

    IN              shift and go to state 227
    ,               shift and go to state 145


state 203

    (83) listmaker2 -> listmaker2 , . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 228

state 204

    (82) listmaker2 -> , expression .

    ,               reduce using rule 82 (listmaker2 -> , expression .)
    ]               reduce using rule 82 (listmaker2 -> , expression .)


state 205

    (121) fancy_drel_assignment_stmt -> primary ( dotlist ) .

    ;               reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    }               reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    BREAK           reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    NEXT            reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    IF              reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    FOR             reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    WHERE           reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    SWITCH          reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    FUNCTION        reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    PRINT           reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    DO              reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    LOOP            reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    WITH            reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    (               reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    [               reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    ID              reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    ITEM_TAG        reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    INTEGER         reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    HEXINT          reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    OCTINT          reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    BININT          reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    REAL            reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    IMAGINARY       reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    STRPREFIX       reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    SHORTSTRING     reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    LONGSTRING      reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    `               reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    $end            reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    ELSE            reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    DEFAULT         reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)
    CASE            reduce using rule 121 (fancy_drel_assignment_stmt -> primary ( dotlist ) .)


state 206

    (123) dotlist -> dotlist , . . ID = expression

    .               shift and go to state 229


state 207

    (122) dotlist -> . ID . = expression

    =               shift and go to state 230


state 208

    (116) call -> primary ( argument_list ) .

    [               reduce using rule 116 (call -> primary ( argument_list ) .)
    (               reduce using rule 116 (call -> primary ( argument_list ) .)
    POWER           reduce using rule 116 (call -> primary ( argument_list ) .)
    .               reduce using rule 116 (call -> primary ( argument_list ) .)
    REAL            reduce using rule 116 (call -> primary ( argument_list ) .)
    ]               reduce using rule 116 (call -> primary ( argument_list ) .)
    ,               reduce using rule 116 (call -> primary ( argument_list ) .)
    *               reduce using rule 116 (call -> primary ( argument_list ) .)
    /               reduce using rule 116 (call -> primary ( argument_list ) .)
    ^               reduce using rule 116 (call -> primary ( argument_list ) .)
    +               reduce using rule 116 (call -> primary ( argument_list ) .)
    -               reduce using rule 116 (call -> primary ( argument_list ) .)
    <               reduce using rule 116 (call -> primary ( argument_list ) .)
    >               reduce using rule 116 (call -> primary ( argument_list ) .)
    GTE             reduce using rule 116 (call -> primary ( argument_list ) .)
    LTE             reduce using rule 116 (call -> primary ( argument_list ) .)
    NEQ             reduce using rule 116 (call -> primary ( argument_list ) .)
    ISEQUAL         reduce using rule 116 (call -> primary ( argument_list ) .)
    IN              reduce using rule 116 (call -> primary ( argument_list ) .)
    NOT             reduce using rule 116 (call -> primary ( argument_list ) .)
    AND             reduce using rule 116 (call -> primary ( argument_list ) .)
    OR              reduce using rule 116 (call -> primary ( argument_list ) .)
    FOR             reduce using rule 116 (call -> primary ( argument_list ) .)
    )               reduce using rule 116 (call -> primary ( argument_list ) .)
    BREAK           reduce using rule 116 (call -> primary ( argument_list ) .)
    NEXT            reduce using rule 116 (call -> primary ( argument_list ) .)
    {               reduce using rule 116 (call -> primary ( argument_list ) .)
    PRINT           reduce using rule 116 (call -> primary ( argument_list ) .)
    IF              reduce using rule 116 (call -> primary ( argument_list ) .)
    WHERE           reduce using rule 116 (call -> primary ( argument_list ) .)
    SWITCH          reduce using rule 116 (call -> primary ( argument_list ) .)
    FUNCTION        reduce using rule 116 (call -> primary ( argument_list ) .)
    DO              reduce using rule 116 (call -> primary ( argument_list ) .)
    LOOP            reduce using rule 116 (call -> primary ( argument_list ) .)
    WITH            reduce using rule 116 (call -> primary ( argument_list ) .)
    ID              reduce using rule 116 (call -> primary ( argument_list ) .)
    ITEM_TAG        reduce using rule 116 (call -> primary ( argument_list ) .)
    INTEGER         reduce using rule 116 (call -> primary ( argument_list ) .)
    HEXINT          reduce using rule 116 (call -> primary ( argument_list ) .)
    OCTINT          reduce using rule 116 (call -> primary ( argument_list ) .)
    BININT          reduce using rule 116 (call -> primary ( argument_list ) .)
    IMAGINARY       reduce using rule 116 (call -> primary ( argument_list ) .)
    STRPREFIX       reduce using rule 116 (call -> primary ( argument_list ) .)
    SHORTSTRING     reduce using rule 116 (call -> primary ( argument_list ) .)
    LONGSTRING      reduce using rule 116 (call -> primary ( argument_list ) .)
    `               reduce using rule 116 (call -> primary ( argument_list ) .)
    ;               reduce using rule 116 (call -> primary ( argument_list ) .)
    $end            reduce using rule 116 (call -> primary ( argument_list ) .)
    }               reduce using rule 116 (call -> primary ( argument_list ) .)
    ELSE            reduce using rule 116 (call -> primary ( argument_list ) .)
    DEFAULT         reduce using rule 116 (call -> primary ( argument_list ) .)
    CASE            reduce using rule 116 (call -> primary ( argument_list ) .)
    :               reduce using rule 116 (call -> primary ( argument_list ) .)
    AUGOP           reduce using rule 116 (call -> primary ( argument_list ) .)
    =               reduce using rule 116 (call -> primary ( argument_list ) .)


state 209

    (118) argument_list -> argument_list , . func_arg
    (119) func_arg -> . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    func_arg                       shift and go to state 231
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 164

state 210

    (107) slice_list -> slice_list , . slice_item
    (108) slice_item -> . expression
    (109) slice_item -> . proper_slice
    (110) slice_item -> . ELLIPSIS
    (18) expression -> . or_test
    (111) proper_slice -> . short_slice
    (112) proper_slice -> . long_slice
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (101) short_slice -> . :
    (102) short_slice -> . expression : expression
    (103) short_slice -> . : expression
    (104) short_slice -> . expression :
    (113) long_slice -> . short_slice :
    (114) long_slice -> . short_slice : expression
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    ELLIPSIS        shift and go to state 168
    :               shift and go to state 169
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    short_slice                    shift and go to state 232
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    long_slice                     shift and go to state 170
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    proper_slice                   shift and go to state 171
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    m_expr                         shift and go to state 82
    slice_item                     shift and go to state 233
    expression                     shift and go to state 234

state 211

    (105) extended_slicing -> primary [ slice_list ] .

    (               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    [               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    .               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    REAL            reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    AUGOP           reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    =               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ,               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    POWER           reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    *               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    /               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ^               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    +               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    -               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    <               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    >               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    GTE             reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    LTE             reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    NEQ             reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ISEQUAL         reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    IN              reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    NOT             reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    AND             reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    OR              reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    )               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    BREAK           reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    NEXT            reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    {               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    PRINT           reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    IF              reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    FOR             reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    WHERE           reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    SWITCH          reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    FUNCTION        reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    DO              reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    LOOP            reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    WITH            reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ID              reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ITEM_TAG        reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    INTEGER         reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    HEXINT          reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    OCTINT          reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    BININT          reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    IMAGINARY       reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    STRPREFIX       reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    SHORTSTRING     reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    LONGSTRING      reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    `               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ;               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    $end            reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    }               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ELSE            reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    DEFAULT         reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    CASE            reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    ]               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)
    :               reduce using rule 105 (extended_slicing -> primary [ slice_list ] .)


state 212

    (100) simple_slicing -> primary [ short_slice ] .

    (               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    [               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    .               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    REAL            reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    AUGOP           reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    =               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ,               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    POWER           reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    *               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    /               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ^               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    +               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    -               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    <               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    >               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    GTE             reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    LTE             reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    NEQ             reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ISEQUAL         reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    IN              reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    NOT             reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    AND             reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    OR              reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    FOR             reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    IF              reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ]               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    )               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    BREAK           reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    NEXT            reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    {               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    PRINT           reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    WHERE           reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    SWITCH          reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    FUNCTION        reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    DO              reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    LOOP            reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    WITH            reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ID              reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ITEM_TAG        reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    INTEGER         reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    HEXINT          reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    OCTINT          reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    BININT          reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    IMAGINARY       reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    STRPREFIX       reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    SHORTSTRING     reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    LONGSTRING      reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    `               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ;               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    $end            reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    }               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    ELSE            reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    DEFAULT         reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    CASE            reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)
    :               reduce using rule 100 (simple_slicing -> primary [ short_slice ] .)


state 213

    (113) long_slice -> short_slice : .
    (114) long_slice -> short_slice : . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    ]               reduce using rule 113 (long_slice -> short_slice : .)
    ,               reduce using rule 113 (long_slice -> short_slice : .)
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 235

state 214

    (103) short_slice -> : expression .

    :               reduce using rule 103 (short_slice -> : expression .)
    ]               reduce using rule 103 (short_slice -> : expression .)
    ,               reduce using rule 103 (short_slice -> : expression .)


state 215

    (97) subscription -> primary [ expression_list ] .

    POWER           reduce using rule 97 (subscription -> primary [ expression_list ] .)
    [               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    (               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    .               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    REAL            reduce using rule 97 (subscription -> primary [ expression_list ] .)
    *               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    /               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ^               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    +               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    -               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    <               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    >               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    GTE             reduce using rule 97 (subscription -> primary [ expression_list ] .)
    LTE             reduce using rule 97 (subscription -> primary [ expression_list ] .)
    NEQ             reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ISEQUAL         reduce using rule 97 (subscription -> primary [ expression_list ] .)
    IN              reduce using rule 97 (subscription -> primary [ expression_list ] .)
    NOT             reduce using rule 97 (subscription -> primary [ expression_list ] .)
    AND             reduce using rule 97 (subscription -> primary [ expression_list ] .)
    OR              reduce using rule 97 (subscription -> primary [ expression_list ] .)
    )               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ,               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    BREAK           reduce using rule 97 (subscription -> primary [ expression_list ] .)
    NEXT            reduce using rule 97 (subscription -> primary [ expression_list ] .)
    {               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    PRINT           reduce using rule 97 (subscription -> primary [ expression_list ] .)
    IF              reduce using rule 97 (subscription -> primary [ expression_list ] .)
    FOR             reduce using rule 97 (subscription -> primary [ expression_list ] .)
    WHERE           reduce using rule 97 (subscription -> primary [ expression_list ] .)
    SWITCH          reduce using rule 97 (subscription -> primary [ expression_list ] .)
    FUNCTION        reduce using rule 97 (subscription -> primary [ expression_list ] .)
    DO              reduce using rule 97 (subscription -> primary [ expression_list ] .)
    LOOP            reduce using rule 97 (subscription -> primary [ expression_list ] .)
    WITH            reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ID              reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ITEM_TAG        reduce using rule 97 (subscription -> primary [ expression_list ] .)
    INTEGER         reduce using rule 97 (subscription -> primary [ expression_list ] .)
    HEXINT          reduce using rule 97 (subscription -> primary [ expression_list ] .)
    OCTINT          reduce using rule 97 (subscription -> primary [ expression_list ] .)
    BININT          reduce using rule 97 (subscription -> primary [ expression_list ] .)
    IMAGINARY       reduce using rule 97 (subscription -> primary [ expression_list ] .)
    STRPREFIX       reduce using rule 97 (subscription -> primary [ expression_list ] .)
    SHORTSTRING     reduce using rule 97 (subscription -> primary [ expression_list ] .)
    LONGSTRING      reduce using rule 97 (subscription -> primary [ expression_list ] .)
    `               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ;               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    $end            reduce using rule 97 (subscription -> primary [ expression_list ] .)
    }               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ELSE            reduce using rule 97 (subscription -> primary [ expression_list ] .)
    DEFAULT         reduce using rule 97 (subscription -> primary [ expression_list ] .)
    CASE            reduce using rule 97 (subscription -> primary [ expression_list ] .)
    ]               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    :               reduce using rule 97 (subscription -> primary [ expression_list ] .)
    AUGOP           reduce using rule 97 (subscription -> primary [ expression_list ] .)
    =               reduce using rule 97 (subscription -> primary [ expression_list ] .)


state 216

    (102) short_slice -> expression : . expression
    (104) short_slice -> expression : .
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    :               reduce using rule 104 (short_slice -> expression : .)
    ]               reduce using rule 104 (short_slice -> expression : .)
    ,               reduce using rule 104 (short_slice -> expression : .)
    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 236

state 217

    (156) caselist -> CASE . target_list suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    primary_att                    shift and go to state 41
    primary                        shift and go to state 100
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    target_list                    shift and go to state 237
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    target                         shift and go to state 84
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 218

    (155) switch_stmt -> SWITCH ID open_brace caselist . DEFAULT suite close_brace
    (157) caselist -> caselist . CASE target_list suite

    DEFAULT         shift and go to state 239
    CASE            shift and go to state 238


state 219

    (150) do_stmt_head -> DO ID = expression . , expression
    (151) do_stmt_head -> DO ID = expression . , expression , expression

    ,               shift and go to state 240


state 220

    (8) stmt_list -> stmt_list ; simple_stmt ; .

    ;               reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    }               reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    BREAK           reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    NEXT            reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    IF              reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    FOR             reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    WHERE           reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    SWITCH          reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    FUNCTION        reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    PRINT           reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    DO              reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    LOOP            reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    WITH            reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    (               reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    [               reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    ID              reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    ITEM_TAG        reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    INTEGER         reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    HEXINT          reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    OCTINT          reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    BININT          reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    REAL            reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    IMAGINARY       reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    STRPREFIX       reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    SHORTSTRING     reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    LONGSTRING      reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    `               reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)
    $end            reduce using rule 8 (stmt_list -> stmt_list ; simple_stmt ; .)


state 221

    (154) where_stmt -> WHERE expression suite ELSE suite .

    BREAK           reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    NEXT            reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    IF              reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    FOR             reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    WHERE           reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    SWITCH          reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    FUNCTION        reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    PRINT           reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    DO              reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    LOOP            reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    WITH            reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    (               reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    [               reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    ID              reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    ITEM_TAG        reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    INTEGER         reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    HEXINT          reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    OCTINT          reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    BININT          reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    REAL            reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    IMAGINARY       reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    STRPREFIX       reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    SHORTSTRING     reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    LONGSTRING      reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    `               reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    $end            reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    }               reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    ELSE            reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    DEFAULT         reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)
    CASE            reduce using rule 154 (where_stmt -> WHERE expression suite ELSE suite .)


state 222

    (147) loop_head -> LOOP ID AS ID : . ID
    (148) loop_head -> LOOP ID AS ID : . ID comp_operator ID

    ID              shift and go to state 241


state 223

    (144) for_stmt -> FOR target_list IN expression_list suite .

    BREAK           reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    NEXT            reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    IF              reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    FOR             reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    WHERE           reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    SWITCH          reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    FUNCTION        reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    PRINT           reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    DO              reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    LOOP            reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    WITH            reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    (               reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    [               reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    ID              reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    ITEM_TAG        reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    INTEGER         reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    HEXINT          reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    OCTINT          reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    BININT          reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    REAL            reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    IMAGINARY       reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    STRPREFIX       reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    SHORTSTRING     reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    LONGSTRING      reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    `               reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    $end            reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    ELSE            reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    }               reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    DEFAULT         reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)
    CASE            reduce using rule 144 (for_stmt -> FOR target_list IN expression_list suite .)


state 224

    (158) funcdef -> FUNCTION ID ( arglist ) . suite
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 242
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 225

    (160) arglist -> arglist , . ID : list_display

    ID              shift and go to state 243


state 226

    (159) arglist -> ID : . list_display
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    [               shift and go to state 93

    list_display                   shift and go to state 244

state 227

    (85) list_for -> FOR expression_list IN . testlist
    (86) list_for -> FOR expression_list IN . testlist list_iter
    (87) testlist -> . or_test
    (88) testlist -> . testlist , or_test
    (89) testlist -> . testlist , or_test ,
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    string_conversion              shift and go to state 49
    call                           shift and go to state 47
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    testlist                       shift and go to state 245
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    or_test                        shift and go to state 246

state 228

    (83) listmaker2 -> listmaker2 , expression .

    ,               reduce using rule 83 (listmaker2 -> listmaker2 , expression .)
    ]               reduce using rule 83 (listmaker2 -> listmaker2 , expression .)


state 229

    (123) dotlist -> dotlist , . . ID = expression

    ID              shift and go to state 247


state 230

    (122) dotlist -> . ID = . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 248

state 231

    (118) argument_list -> argument_list , func_arg .

    )               reduce using rule 118 (argument_list -> argument_list , func_arg .)
    ,               reduce using rule 118 (argument_list -> argument_list , func_arg .)


state 232

    (111) proper_slice -> short_slice .
    (113) long_slice -> short_slice . :
    (114) long_slice -> short_slice . : expression

    ]               reduce using rule 111 (proper_slice -> short_slice .)
    ,               reduce using rule 111 (proper_slice -> short_slice .)
    :               shift and go to state 213


state 233

    (107) slice_list -> slice_list , slice_item .

    ]               reduce using rule 107 (slice_list -> slice_list , slice_item .)
    ,               reduce using rule 107 (slice_list -> slice_list , slice_item .)


state 234

    (108) slice_item -> expression .
    (102) short_slice -> expression . : expression
    (104) short_slice -> expression . :

    ]               reduce using rule 108 (slice_item -> expression .)
    ,               reduce using rule 108 (slice_item -> expression .)
    :               shift and go to state 216


state 235

    (114) long_slice -> short_slice : expression .

    ]               reduce using rule 114 (long_slice -> short_slice : expression .)
    ,               reduce using rule 114 (long_slice -> short_slice : expression .)


state 236

    (102) short_slice -> expression : expression .

    :               reduce using rule 102 (short_slice -> expression : expression .)
    ]               reduce using rule 102 (short_slice -> expression : expression .)
    ,               reduce using rule 102 (short_slice -> expression : expression .)


state 237

    (156) caselist -> CASE target_list . suite
    (126) target_list -> target_list . , target
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    ,               shift and go to state 119
    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 249
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    if_stmt                        shift and go to state 21
    target                         shift and go to state 54
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 238

    (157) caselist -> caselist CASE . target_list suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    (               shift and go to state 6
    [               shift and go to state 38
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    primary_att                    shift and go to state 41
    primary                        shift and go to state 100
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    simple_slicing                 shift and go to state 37
    slicing                        shift and go to state 17
    target_list                    shift and go to state 250
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    target                         shift and go to state 84
    list_display                   shift and go to state 22
    stringliteral                  shift and go to state 23

state 239

    (155) switch_stmt -> SWITCH ID open_brace caselist DEFAULT . suite close_brace
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 251
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    target                         shift and go to state 54
    if_stmt                        shift and go to state 21
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 240

    (150) do_stmt_head -> DO ID = expression , . expression
    (151) do_stmt_head -> DO ID = expression , . expression , expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 252

state 241

    (147) loop_head -> LOOP ID AS ID : ID .
    (148) loop_head -> LOOP ID AS ID : ID . comp_operator ID
    (30) comp_operator -> . <
    (31) comp_operator -> . >
    (32) comp_operator -> . GTE
    (33) comp_operator -> . LTE
    (34) comp_operator -> . NEQ
    (35) comp_operator -> . ISEQUAL
    (36) comp_operator -> . IN
    (37) comp_operator -> . NOT IN

    BREAK           reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    NEXT            reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    {               reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    PRINT           reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    IF              reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    FOR             reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    WHERE           reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    SWITCH          reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    FUNCTION        reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    (               reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    [               reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    DO              reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    LOOP            reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    WITH            reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    ID              reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    ITEM_TAG        reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    INTEGER         reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    HEXINT          reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    OCTINT          reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    BININT          reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    REAL            reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    IMAGINARY       reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    STRPREFIX       reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    SHORTSTRING     reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    LONGSTRING      reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    `               reduce using rule 147 (loop_head -> LOOP ID AS ID : ID .)
    <               shift and go to state 136
    >               shift and go to state 137
    GTE             shift and go to state 132
    LTE             shift and go to state 127
    NEQ             shift and go to state 135
    ISEQUAL         shift and go to state 133
    IN              shift and go to state 130
    NOT             shift and go to state 134

    comp_operator                  shift and go to state 253

state 242

    (158) funcdef -> FUNCTION ID ( arglist ) suite .

    BREAK           reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    NEXT            reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    IF              reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    FOR             reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    WHERE           reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    SWITCH          reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    FUNCTION        reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    PRINT           reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    DO              reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    LOOP            reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    WITH            reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    (               reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    [               reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    ID              reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    ITEM_TAG        reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    INTEGER         reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    HEXINT          reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    OCTINT          reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    BININT          reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    REAL            reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    IMAGINARY       reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    STRPREFIX       reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    SHORTSTRING     reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    LONGSTRING      reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    `               reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    $end            reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    }               reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    ELSE            reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    DEFAULT         reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)
    CASE            reduce using rule 158 (funcdef -> FUNCTION ID ( arglist ) suite .)


state 243

    (160) arglist -> arglist , ID . : list_display

    :               shift and go to state 254


state 244

    (159) arglist -> ID : list_display .

    )               reduce using rule 159 (arglist -> ID : list_display .)
    ,               reduce using rule 159 (arglist -> ID : list_display .)


state 245

    (85) list_for -> FOR expression_list IN testlist .
    (86) list_for -> FOR expression_list IN testlist . list_iter
    (88) testlist -> testlist . , or_test
    (89) testlist -> testlist . , or_test ,
    (90) list_iter -> . list_for
    (91) list_iter -> . list_if
    (85) list_for -> . FOR expression_list IN testlist
    (86) list_for -> . FOR expression_list IN testlist list_iter
    (92) list_if -> . IF or_test
    (93) list_if -> . IF or_test list_iter

    ]               reduce using rule 85 (list_for -> FOR expression_list IN testlist .)
    ,               shift and go to state 255
    FOR             shift and go to state 155
    IF              shift and go to state 259

    list_iter                      shift and go to state 256
    list_if                        shift and go to state 257
    list_for                       shift and go to state 258

state 246

    (87) testlist -> or_test .
    (23) or_test -> or_test . OR and_test

    ,               reduce using rule 87 (testlist -> or_test .)
    FOR             reduce using rule 87 (testlist -> or_test .)
    IF              reduce using rule 87 (testlist -> or_test .)
    ]               reduce using rule 87 (testlist -> or_test .)
    OR              shift and go to state 146


state 247

    (123) dotlist -> dotlist , . ID . = expression

    =               shift and go to state 260


state 248

    (122) dotlist -> . ID = expression .

    )               reduce using rule 122 (dotlist -> . ID = expression .)
    ,               reduce using rule 122 (dotlist -> . ID = expression .)


state 249

    (156) caselist -> CASE target_list suite .

    DEFAULT         reduce using rule 156 (caselist -> CASE target_list suite .)
    CASE            reduce using rule 156 (caselist -> CASE target_list suite .)


state 250

    (157) caselist -> caselist CASE target_list . suite
    (126) target_list -> target_list . , target
    (137) suite -> . simple_stmt
    (138) suite -> . compound_stmt
    (139) suite -> . open_brace statement_block close_brace
    (9) simple_stmt -> . assignment_stmt
    (10) simple_stmt -> . augmented_assignment_stmt
    (11) simple_stmt -> . fancy_drel_assignment_stmt
    (12) simple_stmt -> . print_stmt
    (13) simple_stmt -> . BREAK
    (14) simple_stmt -> . NEXT
    (127) compound_stmt -> . if_stmt
    (128) compound_stmt -> . for_stmt
    (129) compound_stmt -> . do_stmt
    (130) compound_stmt -> . loop_stmt
    (131) compound_stmt -> . with_stmt
    (132) compound_stmt -> . where_stmt
    (133) compound_stmt -> . switch_stmt
    (134) compound_stmt -> . funcdef
    (140) open_brace -> . {
    (124) assignment_stmt -> . target_list = expression_list
    (120) augmented_assignment_stmt -> . target AUGOP expression_list
    (121) fancy_drel_assignment_stmt -> . primary ( dotlist )
    (15) print_stmt -> . PRINT expression
    (135) if_stmt -> . IF expression suite
    (136) if_stmt -> . if_stmt ELSE suite
    (144) for_stmt -> . FOR target_list IN expression_list suite
    (149) do_stmt -> . do_stmt_head suite
    (145) loop_stmt -> . loop_head suite
    (152) with_stmt -> . with_head suite
    (154) where_stmt -> . WHERE expression suite ELSE suite
    (155) switch_stmt -> . SWITCH ID open_brace caselist DEFAULT suite close_brace
    (158) funcdef -> . FUNCTION ID ( arglist ) suite
    (125) target_list -> . target
    (126) target_list -> . target_list , target
    (19) target -> . primary
    (20) target -> . ( target_list )
    (21) target -> . [ target_list ]
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (150) do_stmt_head -> . DO ID = expression , expression
    (151) do_stmt_head -> . DO ID = expression , expression , expression
    (146) loop_head -> . LOOP ID AS ID
    (147) loop_head -> . LOOP ID AS ID : ID
    (148) loop_head -> . LOOP ID AS ID : ID comp_operator ID
    (153) with_head -> . WITH ID AS ID
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    ,               shift and go to state 119
    BREAK           shift and go to state 56
    NEXT            shift and go to state 7
    {               shift and go to state 69
    PRINT           shift and go to state 28
    IF              shift and go to state 61
    FOR             shift and go to state 30
    WHERE           shift and go to state 19
    SWITCH          shift and go to state 46
    FUNCTION        shift and go to state 36
    (               shift and go to state 6
    [               shift and go to state 38
    DO              shift and go to state 58
    LOOP            shift and go to state 25
    WITH            shift and go to state 5
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    `               shift and go to state 20

    fancy_drel_assignment_stmt     shift and go to state 26
    primary_att                    shift and go to state 41
    atom                           shift and go to state 2
    primary                        shift and go to state 42
    stringliteral                  shift and go to state 23
    item_tag                       shift and go to state 52
    switch_stmt                    shift and go to state 43
    do_stmt_head                   shift and go to state 4
    enclosure                      shift and go to state 29
    parenth_form                   shift and go to state 8
    simple_stmt                    shift and go to state 66
    literal                        shift and go to state 45
    assignment_stmt                shift and go to state 32
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    with_head                      shift and go to state 51
    suite                          shift and go to state 261
    loop_head                      shift and go to state 12
    do_stmt                        shift and go to state 13
    compound_stmt                  shift and go to state 67
    attributeref                   shift and go to state 9
    simple_slicing                 shift and go to state 37
    print_stmt                     shift and go to state 50
    loop_stmt                      shift and go to state 15
    slicing                        shift and go to state 17
    target_list                    shift and go to state 63
    for_stmt                       shift and go to state 18
    augmented_assignment_stmt      shift and go to state 27
    funcdef                        shift and go to state 3
    if_stmt                        shift and go to state 21
    target                         shift and go to state 54
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    where_stmt                     shift and go to state 39
    open_brace                     shift and go to state 68
    with_stmt                      shift and go to state 24
    subscription                   shift and go to state 53

state 251

    (155) switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite . close_brace
    (141) close_brace -> . }

    }               shift and go to state 184

    close_brace                    shift and go to state 262

state 252

    (150) do_stmt_head -> DO ID = expression , expression .
    (151) do_stmt_head -> DO ID = expression , expression . , expression

    BREAK           reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    NEXT            reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    {               reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    PRINT           reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    IF              reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    FOR             reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    WHERE           reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    SWITCH          reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    FUNCTION        reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    (               reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    [               reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    DO              reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    LOOP            reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    WITH            reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    ID              reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    ITEM_TAG        reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    INTEGER         reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    HEXINT          reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    OCTINT          reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    BININT          reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    REAL            reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    IMAGINARY       reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    STRPREFIX       reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    SHORTSTRING     reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    LONGSTRING      reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    `               reduce using rule 150 (do_stmt_head -> DO ID = expression , expression .)
    ,               shift and go to state 263


state 253

    (148) loop_head -> LOOP ID AS ID : ID comp_operator . ID

    ID              shift and go to state 264


state 254

    (160) arglist -> arglist , ID : . list_display
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    [               shift and go to state 93

    list_display                   shift and go to state 265

state 255

    (88) testlist -> testlist , . or_test
    (89) testlist -> testlist , . or_test ,
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 266

state 256

    (86) list_for -> FOR expression_list IN testlist list_iter .

    ]               reduce using rule 86 (list_for -> FOR expression_list IN testlist list_iter .)


state 257

    (91) list_iter -> list_if .

    ]               reduce using rule 91 (list_iter -> list_if .)


state 258

    (90) list_iter -> list_for .

    ]               reduce using rule 90 (list_iter -> list_for .)


state 259

    (92) list_if -> IF . or_test
    (93) list_if -> IF . or_test list_iter
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    string_conversion              shift and go to state 49
    call                           shift and go to state 47
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    extended_slicing               shift and go to state 34
    list_display                   shift and go to state 22
    or_test                        shift and go to state 267

state 260

    (123) dotlist -> dotlist , . ID = . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 268

state 261

    (157) caselist -> caselist CASE target_list suite .

    DEFAULT         reduce using rule 157 (caselist -> caselist CASE target_list suite .)
    CASE            reduce using rule 157 (caselist -> caselist CASE target_list suite .)


state 262

    (155) switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .

    DEFAULT         reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    CASE            reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    }               reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    BREAK           reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    NEXT            reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    IF              reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    FOR             reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    WHERE           reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    SWITCH          reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    FUNCTION        reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    PRINT           reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    DO              reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    LOOP            reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    WITH            reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    (               reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    [               reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    ID              reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    ITEM_TAG        reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    INTEGER         reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    HEXINT          reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    OCTINT          reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    BININT          reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    REAL            reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    IMAGINARY       reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    STRPREFIX       reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    SHORTSTRING     reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    LONGSTRING      reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    `               reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    $end            reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)
    ELSE            reduce using rule 155 (switch_stmt -> SWITCH ID open_brace caselist DEFAULT suite close_brace .)


state 263

    (151) do_stmt_head -> DO ID = expression , expression , . expression
    (18) expression -> . or_test
    (22) or_test -> . and_test
    (23) or_test -> . or_test OR and_test
    (24) and_test -> . not_test
    (25) and_test -> . and_test AND not_test
    (26) not_test -> . comparison
    (27) not_test -> . NOT not_test
    (28) comparison -> . a_expr
    (29) comparison -> . a_expr comp_operator a_expr
    (38) a_expr -> . m_expr
    (39) a_expr -> . a_expr + m_expr
    (40) a_expr -> . a_expr - m_expr
    (41) m_expr -> . u_expr
    (42) m_expr -> . m_expr * u_expr
    (43) m_expr -> . m_expr / u_expr
    (44) m_expr -> . m_expr ^ u_expr
    (45) u_expr -> . power
    (46) u_expr -> . - u_expr
    (47) u_expr -> . + u_expr
    (48) power -> . primary
    (49) power -> . primary POWER u_expr
    (50) primary -> . atom
    (51) primary -> . primary_att
    (52) primary -> . subscription
    (53) primary -> . slicing
    (54) primary -> . call
    (56) atom -> . ID
    (57) atom -> . item_tag
    (58) atom -> . literal
    (59) atom -> . enclosure
    (55) primary_att -> . attributeref
    (97) subscription -> . primary [ expression_list ]
    (98) slicing -> . simple_slicing
    (99) slicing -> . extended_slicing
    (115) call -> . primary ( )
    (116) call -> . primary ( argument_list )
    (60) item_tag -> . ITEM_TAG
    (61) literal -> . stringliteral
    (62) literal -> . INTEGER
    (63) literal -> . HEXINT
    (64) literal -> . OCTINT
    (65) literal -> . BININT
    (66) literal -> . REAL
    (67) literal -> . IMAGINARY
    (72) enclosure -> . parenth_form
    (73) enclosure -> . string_conversion
    (74) enclosure -> . list_display
    (94) attributeref -> . primary attribute_tag
    (100) simple_slicing -> . primary [ short_slice ]
    (105) extended_slicing -> . primary [ slice_list ]
    (68) stringliteral -> . STRPREFIX SHORTSTRING
    (69) stringliteral -> . STRPREFIX LONGSTRING
    (70) stringliteral -> . SHORTSTRING
    (71) stringliteral -> . LONGSTRING
    (75) parenth_form -> . ( expression_list )
    (76) parenth_form -> . ( )
    (77) string_conversion -> . ` expression_list `
    (78) list_display -> . [ listmaker ]
    (79) list_display -> . [ ]

    NOT             shift and go to state 72
    -               shift and go to state 79
    +               shift and go to state 77
    ID              shift and go to state 60
    ITEM_TAG        shift and go to state 64
    INTEGER         shift and go to state 55
    HEXINT          shift and go to state 57
    OCTINT          shift and go to state 33
    BININT          shift and go to state 44
    REAL            shift and go to state 40
    IMAGINARY       shift and go to state 59
    STRPREFIX       shift and go to state 10
    SHORTSTRING     shift and go to state 31
    LONGSTRING      shift and go to state 16
    (               shift and go to state 94
    `               shift and go to state 20
    [               shift and go to state 93

    primary_att                    shift and go to state 41
    primary                        shift and go to state 92
    stringliteral                  shift and go to state 23
    not_test                       shift and go to state 74
    enclosure                      shift and go to state 29
    simple_slicing                 shift and go to state 37
    u_expr                         shift and go to state 71
    parenth_form                   shift and go to state 8
    literal                        shift and go to state 45
    attributeref                   shift and go to state 9
    call                           shift and go to state 47
    string_conversion              shift and go to state 49
    extended_slicing               shift and go to state 34
    power                          shift and go to state 75
    a_expr                         shift and go to state 78
    and_test                       shift and go to state 80
    slicing                        shift and go to state 17
    m_expr                         shift and go to state 82
    atom                           shift and go to state 2
    item_tag                       shift and go to state 52
    subscription                   shift and go to state 53
    comparison                     shift and go to state 83
    list_display                   shift and go to state 22
    or_test                        shift and go to state 86
    expression                     shift and go to state 269

state 264

    (148) loop_head -> LOOP ID AS ID : ID comp_operator ID .

    BREAK           reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    NEXT            reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    {               reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    PRINT           reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    IF              reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    FOR             reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    WHERE           reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    SWITCH          reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    FUNCTION        reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    (               reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    [               reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    DO              reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    LOOP            reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    WITH            reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    ID              reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    ITEM_TAG        reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    INTEGER         reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    HEXINT          reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    OCTINT          reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    BININT          reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    REAL            reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    IMAGINARY       reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    STRPREFIX       reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    SHORTSTRING     reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    LONGSTRING      reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)
    `               reduce using rule 148 (loop_head -> LOOP ID AS ID : ID comp_operator ID .)


state 265

    (160) arglist -> arglist , ID : list_display .

    )               reduce using rule 160 (arglist -> arglist , ID : list_display .)
    ,               reduce using rule 160 (arglist -> arglist , ID : list_display .)


state 266

    (88) testlist -> testlist , or_test .
    (89) testlist -> testlist , or_test . ,
    (23) or_test -> or_test . OR and_test

  ! shift/reduce conflict for , resolved as shift
    FOR             reduce using rule 88 (testlist -> testlist , or_test .)
    IF              reduce using rule 88 (testlist -> testlist , or_test .)
    ]               reduce using rule 88 (testlist -> testlist , or_test .)
    ,               shift and go to state 270
    OR              shift and go to state 146

  ! ,               [ reduce using rule 88 (testlist -> testlist , or_test .) ]


state 267

    (92) list_if -> IF or_test .
    (93) list_if -> IF or_test . list_iter
    (23) or_test -> or_test . OR and_test
    (90) list_iter -> . list_for
    (91) list_iter -> . list_if
    (85) list_for -> . FOR expression_list IN testlist
    (86) list_for -> . FOR expression_list IN testlist list_iter
    (92) list_if -> . IF or_test
    (93) list_if -> . IF or_test list_iter

    ]               reduce using rule 92 (list_if -> IF or_test .)
    OR              shift and go to state 146
    FOR             shift and go to state 155
    IF              shift and go to state 259

    list_iter                      shift and go to state 271
    list_if                        shift and go to state 257
    list_for                       shift and go to state 258

state 268

    (123) dotlist -> dotlist , . ID = expression .

    )               reduce using rule 123 (dotlist -> dotlist , . ID = expression .)
    ,               reduce using rule 123 (dotlist -> dotlist , . ID = expression .)


state 269

    (151) do_stmt_head -> DO ID = expression , expression , expression .

    BREAK           reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    NEXT            reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    {               reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    PRINT           reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    IF              reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    FOR             reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    WHERE           reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    SWITCH          reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    FUNCTION        reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    (               reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    [               reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    DO              reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    LOOP            reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    WITH            reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    ID              reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    ITEM_TAG        reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    INTEGER         reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    HEXINT          reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    OCTINT          reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    BININT          reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    REAL            reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    IMAGINARY       reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    STRPREFIX       reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    SHORTSTRING     reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    LONGSTRING      reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)
    `               reduce using rule 151 (do_stmt_head -> DO ID = expression , expression , expression .)


state 270

    (89) testlist -> testlist , or_test , .

    ,               reduce using rule 89 (testlist -> testlist , or_test , .)
    FOR             reduce using rule 89 (testlist -> testlist , or_test , .)
    IF              reduce using rule 89 (testlist -> testlist , or_test , .)
    ]               reduce using rule 89 (testlist -> testlist , or_test , .)


state 271

    (93) list_if -> IF or_test list_iter .

    ]               reduce using rule 93 (list_if -> IF or_test list_iter .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 21 resolved as shift
WARNING: shift/reduce conflict for IN in state 78 resolved as shift
WARNING: shift/reduce conflict for [ in state 92 resolved as shift
WARNING: shift/reduce conflict for ( in state 92 resolved as shift
WARNING: shift/reduce conflict for REAL in state 92 resolved as shift
WARNING: shift/reduce conflict for [ in state 100 resolved as shift
WARNING: shift/reduce conflict for ( in state 100 resolved as shift
WARNING: shift/reduce conflict for REAL in state 100 resolved as shift
WARNING: shift/reduce conflict for , in state 106 resolved as shift
WARNING: shift/reduce conflict for ] in state 167 resolved as shift
WARNING: shift/reduce conflict for ; in state 179 resolved as shift
WARNING: shift/reduce conflict for , in state 266 resolved as shift
WARNING: reduce/reduce conflict in state 73 resolved using rule (target -> primary)
WARNING: rejected rule (power -> primary) in state 73
WARNING: reduce/reduce conflict in state 174 resolved using rule (expression_list -> expression)
WARNING: rejected rule (slice_item -> expression) in state 174
